{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "pSymm",
  "functions": [
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7V3bbty6Dv2XPPdBEklR2r+ycVD0kl0ECJIibQ9wUPTfjyeJPG4tW3to2Y41fCk6rZYprkVJ1M3+efP59uOPL+/vHv55/Hbz198/b+4fP334fvf40P36+evdzcenu/v7uy/vh/98Y05/WMvPgG9fPzycfn/7/uHp+81fYEN8d3P78Ln7K1juHvHP3f3tzV8x/vrPuxvrvACEmANZNPgKssg0BL0bFzYIIZU2yLEvzvbFRljfBsEGNjbww2/gh9/AD84Go42UgtFG5nkbwaayAbAvCp4yZb01r2U9+N/KnioT8C1VJsu+8zbx6TzjfGWYA6fa2EGbtsY/m4hufRO8tglnYH0T63th3fomVo8o59b3wq2vBazvBfjFJqxjS6ljcoHNb0Yy5Sn6VNxbPygNmdLovX0tjX7w7K7fzvR6ZFJNAjn7Ryfv0G7vrIe+0/bBFZztgip1xZ34g9Jkss/2/QjIFn8rfXKXzHW5S1flrt9b3Vhwlz28FmY+t3J0L7UPR649w6Frz9vXnh30wcxcqD0Yk0YIMD4WGoozNg1xXYIURg0l+KtyN9rrcndndQMuaIpg8NC1j0euvd2hEw+YMgAbqJT6koUU+mQHpbOpb2mFAyxflbsVZoCHcve61IXrUheuS12kN+9u7N3tVsz+rD+9/ZFlvv5vP9x8ONcf5sPNR5eSAHOutXPPG0rg335PUs/XPXT1Z1+DLfkK2MclcMFXjiE5Gwz6UkVKnQ5bJWeaHK/kTJITNHJmyNHImSYnauTMkBNbIicYSqte4dn4bEVct5OVvIyDbbvT4tr40db3u17OnHl0MbeghqFfQcEA59yvy4ROtKNpKkk4DO22qa5gTdqdPdNOrkA7R0ylOUYolIZ+gw4Hp2Zcdl36XA3nAIaFT3LuskChcq4mp3aKLcmJ2tk2JSepnA3Juce5JZVzPTm1dTYlp07LW5LTg8rZkpw6UWlJzrY2pVROTYWaklNToZbkzF+7VDmPKmdQORuSM+qOSlNy6kSlITnJ6ESlKTl1otKSnFZ3VJqSE1XOluTUiUpLcjrdUWlKTp2otCQn6ESlKTmbul5y9XKiTlSakhNVzpbk1P3OluQknagcS06w6QqZA+dHcuoyQkty6sHMtuTUZYSW5NSDmW3JqfudTcmpE5WW5AyaCjUlp6ZCLcmpBzPbklNbZ0Nyej2Y2Zacut/Zkpx6MLMtOVHlbElO3VFpSU6nE5Wm5NRUqCU5QVOhpuTUHZWW5NSDmW3JiSrnoeTk/pMxjglHcup+Z0ty6sHMtuTUHZWW5PS6o9KUnDpRaUpOTYVakpNR5WxJTm2dLcmpBzPbknOPiYp1ZzmxICeYvipgsVT60g+0mRQqGNy53q8faPO7HHM8DDleyZkih3c5gncYcjRypsmxGjkz5GjkTJPjjJIzTQ4qOdPkRCVnkhwAJWeanKDkTJKD1zN9eHb3egbnk7t0PYnas7vUlrtHeF0Tc2NN6hCkh8Ya9jFI1+5lB9Iby/sPQXpEJX170jXSNyc9mMZmzscgvbENvUOQ3tqi/TFI15RxB9J1IN2edKcD6Q6kN7a0fQjSobEl82OQrquM25OOmjLuQLqmjDuQrinj9qQTKunbk64p4/ake00ZdyBdVxm3J501ZdyBdE0Ztyc9NHaU+Riko5K+PemaMm5PetT19M1Jj0YjfRXS6Uy6//Olb7G1mx1HuFMdQQfSHUjX7mV70lu74XIM0nW7bnvSSWekO5CuA+kOpGvKuD3pXiN9B9I1ZdyedN4jZYzpnraNg4WJE43PVeI3V6VdrsPNVynukAHF2C9uGPsvXvyWqkLgBxHN7sWB7Zu7M9C3BYOh4AAGwNTKAp4bcP7NdcSpJwkUeFi4c9aaHS7fuHN35QyZgrexf/NejPZPsbr6hz3CDc/1t3+2AGssvL06OfsG61Rhhmo4fczCmnhuOadxbfzkrr9KT440aGacCzymkKrP3tB8M2MI6dGMrtAmrQVOQW0tDt6ikFpljU/ktMlMjfOwlzETU4Xgt7GFX4O4xrHFqhWq8U2BqhWqcfLqkgqB5RSe4IwpBHMw0L/a1QxCPx/MAWIK5hBNKZgx9P2lpcGndlIw+6jM5JnhjTtAcH2FAAZdWp6ZroPG/tE03E2DbTf15nZSO6e9kriURGuskricRG3OFUiMSuJiEmt8h1tJ1EhcTmKN29pKIiuJi0kETXEqkKgpTgUSdWBZTiLqwFKBxKAkLiaRnJK4nERdxVlOotcUpwKJmuJUIFFTnOUk1vj2p5KoKc5yEoOmOBVI1FWc5SRGTXEqkKgpzmISnTFK4nISUUlcTqKmOMtJtLqeWIFETXH+BYlg+2Oo4PyIRKfJdgUSdT1xOYmgKU4FElFJXE6ipjjLSUQdWCqQqAPLchJJV3EqkKiRuJxErynO0lvsHYm6nliBRN0yXU4i6ypOBRJ1FWc5iUFTnAok6sCynMSoKU4FEjUSK5CoKc5iEsFsnuL0d967CVSJxB2v08P2+6BHYWb7+6CHYSYqM3lmXI23rsWYSndUw/DtSLl3KRGn0t6UXnCG3tvUpXoueBvIJGcDOTvytcZG14W+ept6eQ+u5Cv27wtCMnbe1+hjCsfIjsa+5vuC0Jvo/hqGvr6gogSFIlsoskUgQgUJyotseZGtiXdEllAsQU1MWksoL0FNnOQMLpxRsdTzRnNO2aIbvUgLJl4OU9UITpwErGyENjBit/DEXSr8C8pLUCCyBSJbKLKFIlskskUiW15ky4tsscgWi2wFka0gshVFtiIJUHRxd/SCEtmyIltWZitKUBMvICmhggQFToRiCUrU25CotyESqUwilUmk8sQr40sokcosiigWqRxEESXqo0jUR5Goj/KiPsobFKEkEeUtiFCSiPLOiVCSiPKijMiLMiKPIpVRFFEoUplEEUUilb0oorxIZRZFlCiP8qI8ygeRylEUUVGkcpREFBsQoSQRxdaJUJKIYtGsjUWzNgYjQpEIJVIZUYQSqUyiiMq/ILtbW+uXnwn8r9mpfP9NBT5/UQFfXnfN+SNf1R6fz7HqPT6s+vh81lbv8etKG9etfX5JrtbjQz7bq/b4/E5avcevW3u3bu3z/Xa9x68bOejWffyqrTbQurVfdzgJHtZ9/Kr9feB1ued1uQ/63doXaipfPHDpC2IOgIaFX1hnZX171qPG+h6s60eaV2F99mpTNFZZ34F1UtZ3YF2/07wD63t8AlJZt5o57sC609F0D9Z1NN2BdTDK+g6sa6zvwbpmjpuz7ozJrsMQpmUEGnwfvsf4yzHWCjACO05gxwns5HvmAkZgBwX+5Dc45jEkiIP86RsK6ToQBTfC5L/OXMDw5Zj8+WXft0k/emmmm/gK8DwmGAFGYCcK7ESJnXgxZuJzq/MYawQYfznGWQGGL8fkTxzPY/JtwZr+2rE1IY5RXoLiLN/WUn9FxLIbo4IElT/1WkLlT70WUZRHBd/nAWbEhstH0ulGTEKhG9lyzohQKEIFCSofhSUUivxCUQ3zZ6g6kXuVie0YFSWoiZZSQOVHjiKKJaj8jm8RJbI10b6ov6R6Omo9RkUBCgxKUNaJUCxBOStCkQgl4jD/plUL0KOARu0L8l9jLKJYgsrffSuiSISKEpQXseFFzLPIFouYDyLmg4j5MMG8P1+yD6PeBibG5XkU5mejRRRLUBZEqCBB5WeYJRRIxmUEFKEkozmiyNbEzbLZ1+04nGjLPvSjHpuxrYnRvISKElRAESrPPEful6bsaN0GI4hQLEBR/vxCEUUiVJSgLIhQEuYn7rEWUSLmQcQ8iJgHEfMoYgNFbJCIjfyB2W69uR/1Io5R+WsVBVTIt2X2qWNjP+rXJk5MRH9+d8zIzsR+fwHDl2PyWXIBQ4L1iYmdriIKRagoQaHIFopskcgWiWx5kS0W6cUyWyK/AohQLEFNzK1LKEFLAZO/sT3Xx3SYLO9dU03tGDOYi/slmNgVmbcDgrrls9V5TP5WSQHjL+eArAAjsJN/YX4MKQ5+20ZMGLocwwI7+XY+8CeHEcRbfkY7j8mfPC9gLh47wRoQYMLlGCuwYwX+XJ4LdBgSYC6Mg1/dr/9+eLr78PH+9luHOP3nj4dP3+8eH15/fv/f1/Q/H5/u7u/vvrz/+vT46fbzj6fb9/ePn07/d2Ne//ibILwjiqe6nH45fEeA3a/nHSvo1uwghtPPEx3U9brkXVeHrh7/Bw==",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "get_config",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5276036973553878575": {
            "error_kind": "string",
            "string": "Function get_config can only be called statically"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "custody_balance_from",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "custody_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "deposit_owner",
            "type": {
              "kind": "struct",
              "path": "types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "length": 17,
            "item_types": []
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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+czx0POZ46GnM4946PnM8dDzmeOh5zPHQ89nbjA/nTkeej5zPPR85njo+czx0POZ46GnM6/9vNkumeOh5zPHQ89njoeez9xgfjpzPPR85njo+czx0POZ46HnM8dDT2e+4qHnM8dDz2eOh57PHA89n7nB/HTmeOj5zPHQ85njoeczx0PPZ46Hns18nfDQ85njoeczx0PPZ46Hns/cYH46czz0fOZ46PnM8dDzmeOh5zPHQ09n7vDQ85njoeczx0PPZ46Hns/cYH46czz0fOZ46PnM8dDzmeOh5zPHQ09n7vHQ85njoeczx0PPZ46Hns/cYH46czz0fOZ46PnM8dDzmeOh5zPHQ09nHvDQ85njoeczx0PPZ46Hns/cYH46czz0fOZ46PnM8dDzmeOh5zPHQ09nbnjo+czx0POZ46HnM8dDz2duMD+dOR56PnM89HzmeOj5zPHQ85njoaczn/HQ85njoeczx0PPZ46Hns/cYH46czz0fOZ46PnM8dDzmeOh5zPHQ09nvuCh5zPHQ89njoeezxwPPZ+5wfx05njo+czx0POZ46HnM8dDz2eOh57OPOKh5zPHQ89njoeezxwPPZ+5wfx05njo+czx0POZ46HnM8dDz2eOh57OPOGh5zPHQ89njoeezxwPPZ+5wfx05njo+czx0POZ46HnM8dDz2eOh57OfMVDz2eOh57PHA89nzkeej5zg/npzPHQ85njoeczx0PPZ46Hns8cDz2ZeZgmPPR85njo+czx0POZ46HnMzeYn84cDz2fOR56PnM89HzmeOj5zPHQ05k7PPR85njo+czx0POZ46HnMzeYn84cDz2fOR56PnM89HzmeOj5zPHQ05l7PPR85njo+czx0POZ46HnMzeYn84cDz2fOR56PnM89HzmeOj5zPHQ05kHPPR85njo+czx0POZ46HnMzeYn84cDz2fOR56PnM89HzmeOj5zPHQ05kbHno+czz0fOZ46PnM8dDzmRvMT2eOh57PHA89nzkeej5zPPR85njo6cxnPPR85njo+czx0POZ46HnMzeYn84cDz2fOR56PnM89HzmeOj5zPHQ05kveOj5zPHQ85njoeczx0PPZ24wP505Hno+czz0fOZ46PnM8dDzmeOhpzOPeOj5zPHQ85njoeczx0PPZ24wP505Hno+czz0fOZ46PnM8dDzmeOhpzNPeOj5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Pw6RuQVo3/jtaMx5AJbxj5fJS/6y3wu3P5jDATF4/2o/bW5/2Nz+uLn9aXP78+b2l73trz8JspH9dnP7pefflv2b51+3ef51m+dft3n+dZvnX7d5/nWb51+/ef71m+dfv3n+9ZvnX795/vWb51+/ef71m+dfv3n+9ZvnX9o8/9Lm+Zc2z7+0ef6lzfMvbZ5/afP8S5vnX9o8/9Lm+Tdsnn/D5vk3bJ5/w+b5N2yef8Pm+Tdsnn/D5vk3bJ5/w+b5N26ef+Pm+Tdunn/j5vk3bp5/4+b5N26ef+Pm+Tdunn/j5vk3bZ5/0+b5N22ef9Pm+Tdtnn/T5vk3bZ5/0+b5N22ef9Pm+Tdvnn/z5vk3b55/8+b5N2+ef/Pm+Tdvnn/z5vk3b55/8+b5t2yef8vm+bdsnn/L5vm3bJ5/y+b5t2yef8vm+bdsnn/L3vmXzN75l8ze+ZfM3vmXzN75l8ze+ZfM3vmXzN75l8ze+ZfM3vmXzOb5126ef+3m+Vf8+Vct+zfPv5uff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn39Fm59/RZuff0Wbn38VNj//Kmx+/lXY/PyrsPn5V8HsnX/D5udfhc3Pvwqbn38VNj//Kmx+/lXY/PyrsPn5V2Hz86/C5udfBfHnXz1+OqZin+2vXGzyca2Ljx++id3XKj1X91yr9Lzec63Sa4Cea5VeL/Rcq/TaouNaxZ8D1nOt0muWnmuVXt/0XKv0WqjnWknRWhXVTeLPQ+u5VkV1k/hz1nquVXrdZMxhSTQ+vvSk0s9kCyUc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",
      "brillig_names": [
        "discover_new_messages",
        "get_notes_internal",
        "get_collapse_hints",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "custody_to_address",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "counterparties",
            "type": {
              "kind": "array",
              "length": 1,
              "type": {
                "kind": "struct",
                "path": "types::address::aztec_address::AztecAddress",
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            },
            "visibility": "private"
          },
          {
            "name": "custody_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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mW9rFtqaxbZmqa1Z2ygxbaPEtI0S0zZKTNsoMW2jxLSNEtM2SkzbKDFto8S0jRLbNkps2yixbaPEto0S2zZKbNsosW2jxLaNEts2SmzbKHFto8S1jRLXNkpc2yhxbaPEtY0S1zZK2mqvua32mttqr7mt9prbaq+5rfaa22qvua32mttqr7mt9prbaq+5rfaa22qvua32mttqr7mt9prbaq+5rfaa22qvua32mttqr7mt9prbaq+5rfaa22qvua32mttqr7mt9prbaq+5rfaa22qvua32mttqr7mt9prbaq+5rfaa22qvua32mttqr7mt9prbaq+5rfaa22qvua32mttqr7mt9prbaq+5rfaa22qvua32mttqr7mt9prbaq+5rfaa22qvua32mttqr7mt9prbaq+5rfaa22qvua32mptqr35rqr3empm2ZratmWtrRm3NfFuz0NYstjVLbc3aRolpGyWmbZSYtlFi2kaJaRslpm2UmLZRYtpGiWkbJaZtlNi2UXJSe83Hy3vmVlIpNDsZJTEezbL91qy04izTfha3cNxc4dBc4fi5wglzhRPnCifNFU6eKpyzZwejwjFzhTPXXdnNdVd2c92V3Vx3ZTfXXdnNdVd2c92V3Vx3Zep9V367FdMtHjNZPHayeNxk8dBk8fjJ4vn43nxvFtuapbZmxXuSNWlfwsNa4yvQTIju2N03xPBYWKe4IUJy+yIybntehMeUlwLdjgWwbrPdcXRO9/jLj5Init9vuwDBO/cavxEevxUevxMePwmP3wuPPwiPPwqPPwmPf/b5txJ/ED7/BuHzbxA+/wbh828QPv8G4fNvED7/BuHzbxA+/wbh828UPv9G4fNvFD7/RuHzbxQ+/0bh828UPv9G4fNvFD7/RuHzbxI+/ybh828SPv8m4fNvEj7/JuHzbxI+/ybh828SPv8m4fNvFj7/ZuHzbxY+/2bh828WPv9m4fNvFj7/ZuHzbxY+/2bZ86/ZZM+/ZpM9/5pN9vxrNtnzr9lkz79mkz3/mk32/Gs22fOv2WTPv2YTPv8a4fOvET7/GuHzrxE+/xrh868RPv8a4fOvET7/GuHzrxE+/1rh868VPv9a4fOvFT7/WuHzrxU+/1rh868VPv9a4fOvFT7/OuHzrxM+/zrh868TPv864fOvEz7/OuHzrxM+/zrh868TPv+S8PmXhM+/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irc9rnjb44q3Pa542+OKtz2ueNvjirc9rnjb44q3Pa541+OKdz2ueNfjinc9rnjX44p3Pa541+OKdz2ueNfjinc9rnjqccVTjyueelzx1OOKpx5XPPW44qnHFU89rnjqccVTjyve97jifY8r3ve44n2PK973uOJ9jyve97jifY8r3ve44n2PKz70uOJDjys+9LjiQ48rPvS44kOPKz70uOJDjys+9LjiQ48rPva44mOPKz72uOJjjys+9rjiY48rPva44mOPKz72uOJjjys+9bjiU48rPvW44lOPKz71uOJTjys+9bjiU48rPvW44lOPKz73uOJzjys+97jic48rPve44nOPKz73uOJzjys+97jie7xzZ3q8c2d6vHNnerxzZ3q8c2c26nES3+MkocdJYo+TpB4n6XHF93jnzvR45870eOfO9HjnzvR45870eOfO9HjnzvR45870eOfO9HjnzvR45870eOfOcLxz526J1X4Sa2pHxz2g+PiAntxXNG6qaGiqaPxU0YSpoolTRZOmiibPFA3Hu4uM0ZipopnqXuymuhe7qe7Fbqp7sZvqXuymuhe7qe7Fbqp7MU11L6ap7sXll/xuN8V9kabbyHps45Kp8PPkHsuLPoXiw/0M5Tf8WM9gLj+DvfwM7vIz0OVn8L8+g39cBaF0hnD5GeLvz3CsjexjLpwhXX6G31/TPu9Kh829niFsl5/BcJ7BmMIZ7OVncJef4ffXdIhmP0PaCmfwl5/h99d0SPsChCFT4Qzx8jP8/pqOx0Zr0aTCGfLVZ4gb5xmeFnp/nMFcfgZ7+Rl+f00/1pNPW2EsRbr8DL+/ptNBKRXHUrj8DL+/ppPbF6ROZAtnSJefIXOewRfurWm7/Azm8jP8/prOZj82l67p5C4/w++v6ez2WTRTIRNI/vIz/P6azkfunUOJUrz8DInzDLFwb0356jPk7fIz/P6aNpvfLYrZQuGqzrbDOcrXNdl9djQUw/tzuNstdC+0mKfNX2y0xbJM3NN1t6XHrOVMKB0dj41xXHy68/05+h4/CY/fC48/CI8/Co8/CY8/i47flt/wFBS/ER6/FR6/7PnXbrLnX7vJnn/tJnv+tZvs+ddusudfuwmff43w+dcIn3+N8PnXCJ9/jfD51wiff43w+dcIn3+N8PnXCJ9/rfD51wqff23/+fd4BOKMj5X4P91GfDv2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",
      "brillig_names": [
        "discover_new_messages",
        "random",
        "notify_created_note_oracle_wrapper",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "custody_balance",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "custody_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "length": 17,
            "item_types": []
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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/y2O/+L33+L4L37/LY3/4tvTlcd/8ftvcfwXv/8Wx3/x+29x/JXffy++PV15/JXffy++Pd2Ux+Fx8TLnwkvbsk729VGmnN/mevF7tXSuF7+vK+d68S3ytHO9eF6QzvXi2UI614vnEOlcraO5XjzfSOd68Sz0rbne2l2Piy1vzLWl3FSaa0u5qTTXlnJTYa4X39pQO9eWclNpri3lptJcW8pNpblaR3NtKTdN05qb8kZuuvgWj9q5NpWbCnNtKjcV5tpUbvp0rtPFt6TUzrWp3FSYa1O5qTDXpnJTYa7W0Vz7yU3Txbfm/Gyu9/HXm4Xu468339zHf+3MMg/DYyDzOIeP47/41pzl8V87W5THf+28UB7/tTNAefzXvq+Xx3/te3V5/Ne+/5bHf+37b3n8177/lsdf+f334ltzlsdf+f334ltzlsdf+f334ltzlsdf+f334ltzlsdf+f334ltzlsdf+f334ltzlsdf+f334ltzlsdf+f334ltzlsdf+f334ltdlsdf+f334jtHlsdf+f334vswlsdf+f334rsalsdf+f334jsKlsdf+f334nv/lcdf+f334nv/lcdf+f334nv/lcdf+f334nv/lcdf+f334nv/lcdf+f334nv/lcdf+f334nv/lcdf+f334nv/lcdf+f334nv/lcdf+f334nv/lcdf+f334nv/lcdf+f334nv/lcdf+f334nv/lcdf+f334nv/lcdf+f334nv/lcdf+f334nv/lcdf+f334vv5lcdf+f334vvulcdf+f334vvjlcdf+f334vvYlcdf+f334vvNlcdf+f334vvClcdf+f334vu3lcdf+f334vuslcdf+f334vuhlcdf+f334vuWlcdf+f334vuLlcdf9/13vvg+YOXx133/nS++X1d5/HXff+eh7vvvfPG9ssrjr/v+O198/6vy+Ou+/86V7381V77/1Vz5/ldz5ftfzZXvfzVXvv/VXPn+V3Pl+1/Nle9/NVe+/9Vc+f5Xc+X7X82V7381V77/1Vz5/ldz5ftfzZXvfzVXvv/VXPn+V3Pl+1/Nle9/NV99/yvLj4vnKcSN8V/8/jumlf/tPyy8dB7s7eI8Ps9Zjn/OXP5w7ZIfL7ws76+9c7n4ff00LhfPC6dxMbhscrl4vjmNy8Vz02lcLp7HTuNy8Zx3GpeL58ezuFx9X7jT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Hs484aHHM8dDj2eOhx7PHA89nrnB/HDmeOjxzPHQ45njocczx0OPZ46HHs4846HHM8dDj2eOhx7PHA89nrnB/HDmeOjxzPHQ45njocczx0OPZ46HHs58wUOPZ46HHs8cDz2eOR56PHOD+eHM8dDjmeOhxzPHQ49njocezxwPPZj5OAx46PHM8dDjmeOhxzPHQ49nbjA/nDkeejxzPPR45njo8czx0OOZ46GHMw946PHM8dDjmeOhxzPHQ49nbjA/nDkeejxzPPR45njo8czx0OOZ46GHM4946PHM8dDjmeOhxzPHQ49nbjA/nDkeejxzPPR45njo8czx0OOZ46GHMx/x0OOZ46HHM8dDj2eOhx7P3GB+OHM89HjmeOjxzPHQ45njocczx0MPZ2546PHM8dDjmeOhxzPHQ49nbjA/nDkeejxzPPR45njo8czx0OOZ46GHM5/w0OOZ46HHM8dDj2eOhx7P3GB+OHM89HjmeOjxzPHQ45njocczx0MPZz7jocczx0OPZ46HHs8cDz2eucH8cOZ46PHM8dDjmeOhxzPHQ49njocezjzhocczx0OPZ46HHs8cDz2eucH8cOZ46PHM8dDjmeOhxzPHQ49njocezjzjocczx0OPZ46HHs8cDz2eucH8cOZ46PHM8dDjmeOhxzPHQ49njoceznzBQ49njocezxwPPZ45Hno8c4P54czx0OOZ46HHM8dDj2eOhx7PHA89mnkY8NDjmeOhxzPHQ49njocez9xgfjhzPPR45njo8czx0OOZ46HHM8dDD2ce8NDjmeOhxzPHQ49njocez9xgfjhzPPR45njo8czx0OOZ46HHM8dDD2ce8dDjmeOhxzPHQ49njocez9xgfjhzPPR45njo8czx0OOZ46HHM8dDD2c+4qHHM8dDj2eOhx7PHA89nrnB/HDmeOjxzPHQ45njocczx0OPZ46HHs7c8NDjmeOhxzPHQ49njocez9xgfjhzPPR45njo8czx0OOZ46HHM8dDD2c+4aHHM8dDj2eOhx7PHA89nrnB/HDmeOjxzPHQ45njocczx0OPZ46HHs58xkOPZ46HHs8cDz2eOR56PHOD+eHM8dDjmeOhxzPHQ49njocezxwPPZx5wkOPZ46HHs8cDz2eOR56PHOD+eHM8dDjmeOhxzPHQ49njocez7xbD03Lk3n6nHnM4UFjCK+X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",
      "brillig_names": [
        "discover_new_messages",
        "get_notes_internal",
        "get_collapse_hints",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "address_to_custody",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "counterparties",
            "type": {
              "kind": "array",
              "length": 1,
              "type": {
                "kind": "struct",
                "path": "types::address::aztec_address::AztecAddress",
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            },
            "visibility": "private"
          },
          {
            "name": "custody_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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x018j5uky59kxJGnvP2WLvrt+luY629hr7+Fu/4WdP0t/PW34MhT3n4oFn28/hbp+lvky/OUsF1/C3P9Lez1t7g+Zwx0/S389bcI198iXn6Lk9XbLR7Nvv7O/53yT5Zkt5iPlHpLJrw0c23NqK2Zb2tWduyWnHs0e9p1fW8W25qltma5qVk68Vt+7D+/5WBemp2QzGnfh96YbXshmUJbs9jWLDf1rbxaV292MnBydk9G+pdmtq2Za2tGbc3K7r5dmh/N7LMD/q+fu6u8FsZ9k9jjJunvN6ms65U3DOS8RSrvjcd7C/PpLe7NbFsz19aMWp4+afNtzUJbs9jWLLU1y03NzNbWzLQ1s23NXFuzk/f//fFgjfH5k89Sambjdrytc1tgeLlFuv4W+fJbnCz/sN7CXH8Le/0t3PW3oOtv4a+/Rbj+FtePbnv96LbXj253/eh2149ud/3odtePbnf96HbXj253/eh2H4/ue7PU1iw3NaOtrZlpa2bbmrm2ZtTWzLc1C23N2qKE2qKE2qLEt0WJb4sS3xYlvi1KfFuU+LYo8W1R4tuixLdFiW+LktAWJaEtSkJblIS2KAltURLaoiS0RUloi5LQFiWhLUpiW5TEtiiJbVES26IktkVJbIuS2BYlsS1KYluUxLYoSW1RktqiJLVFSWqLktQWJaktSlJblKS2KEltUZLaoiS3RUlui5LcFiW5LUpyW5TktijJbVGS26Ikt0VJboqSvG1tzUxbM9vWzLU1o7Zmvq1ZaGsW25qltmZtUWLaosS0RYlpixLTFiWmLUpMW5SYtigxbVFi2qLEtEWJbYsS2xYlti1KbFuU2LYosW1RYtuixLZFiW2LEtsWJa4tSlxblLi2KHFtUeLaosS1RYlri5K22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mptqr35pqr7dmpq2ZbWvm2ppRWzPf1iy0NYttzVJbs7YoMW1RYtqixLRFiWmLEtMWJaYtSkxblJi2KDFtUWLaosS2RclJ7TUfL++ZW0ml0OwkSmI8mmX7o1lpx1mm8yxu5ri5zKG5zPFzmRPmMifOZU6ay5w8lTlnawejzDFzmTPXU9nN9VR2cz2V3VxPZTfXU9nN9VR2cz2V3VxPZer9VH57FNPNHjOZPXYye9xk9tBk9vjJ7Pn42XxvFtuapbZmxWeSNWnfwsNa4yvQTIjuON03xPDYWKd4IEJy+yYybnvehMeUtwLdjg2wbrPdcXVOd/vLS8kT2e+33QHBO/dqvxFuvxVuvxNuPwm33wu3Pwi3Pwq3Pwm3f/b5t2J/ED7/BuHzbxA+/wbh828QPv8G4fNvED7/BuHzbxA+/wbh828UPv9G4fNvFD7/RuHzbxQ+/0bh828UPv9G4fNvFD7/RuHzbxI+/ybh828SPv8m4fNvEj7/JuHzbxI+/ybh828SPv8m4fNvFj7/ZuHzbxY+/2bh828WPv9m4fNvFj7/ZuHzbxY+/2bZ86/ZZM+/ZpM9/5pN9vxrNtnzr9lkz79mkz3/mk32/Gs22fOv2WTPv2YTPv8a4fOvET7/GuHzrxE+/xrh868RPv8a4fOvET7/GuHzrxE+/1rh868VPv9a4fOvFT7/WuHzrxU+/1rh868VPv9a4fOvFT7/OuHzrxM+/zrh868TPv864fOvEz7/OuHzrxM+/zrh868TPv+S8PmXhM+/JHz+JeHzLwmff0n4/EvC518SPv+S8Pl3+v2vKvYL3//KCN//ygjf/8oI3//KCN//ygjf/8oI3//KCN//ygjf/8oI3//KCN//ygjf/8oI3//KCN//ygjf/8oI3//KCN//ygjf/8oI3//KCN//ygjf/8oI3//KCN//ygjf/8oI3//KCN//ygjf/8oI3//KCN//ygjf/8oI3//KCN//ygjf/8oI3//KCN//ygjf/8oI3//KCN//ygjf/8oI3//KCN//ygjf/8oI3//KCN//ygjf/8oI3//KCN//ygjf/8oI3//KCN//ygrf/8oK3//KCt//ygrf/8pusudfK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kyt8/ysrfP8rK3z/Kzv9/lePnw4xm2f7Cxdvab/WhscP35rd+zr7XM3Z19nndc6+kqK+zp4vcPZ19tyCs6+z5yGcfZ09Z+Hs6+z5DWNfp9+LjLOvivKm6fc44+yrorxp+r3TOPuqKG+afk+2bdstCZsLL5p09j3ZfPY7/5hMfu8rH2gX4D7Fp5/eSlcnE/P31bdfjsfVNm/fbCbPnYaymTzXGslm9n3qhrKZPJcbymby3G8om8lzxaFsCGxO2UyVi95NmiplvJs0VRZ4N2mq5Otu0lQ5zz+T5tqS727SVDP83aSpJta7SVPNZ3eTpppG7ibN9/SeaxO6u0nzPb3n2irubtJ8T++5NnS7mzTf03uubdfuJs339J5rc7S7SfM9vefawuxu0nxP77k2GrubNN3T2821HdjdpOme3m6uTbvuJk339HbbdE9vN9duWXeTpnt6u7n2tLqbNN3T282189Q/k+baTOpu0nxP77m2fLqbNN/Te66Nme4mzff0nmv7pLtJ8z2959rk6G7SfE/vubYiups039N7rg2D7ibN9/Sea1ufu0nzPb3n2nznbtJ8T++5tsi5mzTf03uujWzuJs339J5ru5m7SfM9vefaFOZu0nxP77m2brmbNN/Te64NVu4mzff0nmsblLtJ8z2959qs5G7SfE/vubYUuZs039N7ro0/7ibN9/Sea3uOu0nzPb3n2kTjbtJ8T++5tq+4mzTf03uuzSDuJs339J5ra4W7SfM9vefaqOBu0nxP77k++7+bNN/Te66P6O8mzff0nuuT9LtJ8z295/rA+27SfE/vuT6Vvps039N7rg+D7ybN9/Se6zPYu0nzPb3n+ujzbtJ8T+/5vrV0831r6eb71tLN962lm+9bSzfft5Zuvm8t3XzfWrr5vrV0831r6eb71tLN962lm+9bSzfft5Zuvm8t3XzfWrr5vrV0831r6eb71tLN962lm+tby9ern376F9sAxt3qkMLjh7+3AXRzfcR5cV+X2lK40telthR+21ea63vWi/u61JbClb7K2Vbu1lf7vq8U824HJZeOi91GRbNNPKx29Lia/DcbOdvK9WdD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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "random",
        "notify_created_note_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3Rruw6d535Lr72hUROUWS/SqMROLETGDDswHEaaAR+965zaklV61+q4t46LM1Jzi8Xwf6PpSXyG1PSHEMq6v/83T/+03/93//jv/zzv/73f/tff/d//d//5+/+5d/+2z/8xz//27/e/tf/+c+//7v/+u///C//8s//4788/+e/m/74/+Yw/bnD//qf//Cvf/zv//Uf//Dv//F3/9c8yZz//u/+6V//8c9/r+vtj/z3f/6Xf/rjf6X//Psf2685fW2dJ9m3XePBpktYvjZdlunxZyX/5//z97fhzC2Gk+O6DWcp74cjsXxtKin/HE5oMpws23BKfj+cNG10Ukg/hxNbDKeE8LV1iUtlOHn62nSdDsSSw+HEPG8HmGNZ58pwQpnmr83jlJ4mPX0dZbnkKOmSo6yXHCVfcpRyxVHidMlR5kuOEi45SrzkKJec+/GScz9ecu7HS879eMm5Hy859+WSc18uOfflknNfLjn35ZJzXy459+WSc18uOfflknNfLjn3l0vO/eWSc3+55NxfLjn3l0vO/eWSc3+55NxfLjn3l0vO/eWScz9dcu6nS879dMm5ny4599Ml53665NxPl5z76ZJzP11y7qdLzv31knN/veTcXy8599dLzv31knN/veTcXy8599dLzv31knN/veTcz5ec+/mScz9fcu7nS879fMm5ny8593OTcz9OS9qPUp4euMzz/SjrJUfJlxylXHGUMl1ylPmSozQ59+PtWd52lBDKt6P83PpmZrcx3ZxNeNp6OXrqmePXxkt8OkeW+zlSosL48/7k83aFzpXxL2ndnyKnHPetU7hPQHqfwNL7BFLvE1h7n0DufQKl7wmEaep9AnPvEwi9T6DzO3GY7N+JV9kap2Vd5HkCB+5imbfGKSxPwz7cOC/bMPL61GTJoW2Z91fWwu2p1L61HI4iPyzOt03/JG6/dRiNuP1eZzTi9puz0Yjb7yZHI26//R2M+Gy/Xx+NuH2DMRpx+45oNOL2LdxoxAXiFxPHc15NHM95NXE859XE8ZxXE8dzXkw84DmvJo7nvJo4nvNq4njOq4kLxC8mjue8mjie82rieM6rieM5ryaO57yYeMRzXk0cz3k18R485/wgnt9DnPP+i5O5hFj507OUbVG7eVnD85/+k00P7lCLjcDmJZseHJcWmx68kRabHlyMFpse/IYWmx6cgRIb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xw/x4vFP00PMnz/E58/u8vmzu3z+7C6fP7vL58/u8vmzu3z+7C4fP7vnafr8IebPH+K3z+77bvHcbnJut+Xcbuncbuu53fK53cqp3ebp3G7zud3OVcl8rkrmc1Uyn6uS+VyVzOeqZD5XJfO5KgnnqiScq5JwrkrCuSoJ56oknKuScK5KwrkqCeeqJJyrkniuSuK5KonnqiSeq5J4rkriuSqJ56oknquSeK5K4rkqkXNVIueqRM5ViZyrEjlXJXKuSuRclci5KpFzVSLnqmQ5VyXLuSpZzlXJcq5KlnNVspyrkuVclSznqmQ5VyXLuSpJ56oknauSdK5K0rkqSeeqJJ2rknSuStK5KknnqiSdq5L1XJWs56pkPVcl67kqWc9VyXquStZzVbKeq5L1XJWs56okn6uSfK5K8rkqyeeqJJ+rknyuSvK5KsnnqiSfq5J8rkrKuSop56qknKuScq5KyrkqKeeqpJyrknKuSsq5KimnqiRM07nd5nO7hXO7xXO7ybndlnO7pXO7red2y+d2O1cl57LXcC57Deey13Auew3nstdwLnsN57LXcC57Deey13Auew3nstdwLnsN57LXcC57Deey13Auew3nstdwLnsN57LXcC57Deey13Auew3nstdwLnsN57LXcC57Deey13Auew3nstdwLnsN57LXcC57Deey13Auew3nstdwLnsN57LXcC57Deey13Auew3nstdwLnsN57LXcC57Deey13Auew3nstdwLnsN57LXcC57Deey13Auew3nstdwLnsN57LXcC57Deey13Auew3nstdwLnsN57LXcC57Deey13Auew3nstdwLnsN57LXcC57Deey13Auew3nstdwLnsN57LXcC57Deey13Auew0vsteyv7x3S/nmg91eVMm67ruV8G23oxVnG33P4jacbGs4xdRwXmXQWsOZbQ0n2BpOtDUcsTWcxdZwkq3h2LoqF1tX5WLqqhwnU1flOJm6KsfJ1FU5TqauynEydVWO09VX5befYrqNJxkbz2psPNnYeIqt8cyTsfH89rX5vls4t1s8t9vhNen28HNbwuP2iHGpQJvTGvev+6Y1PRbWOfwgQo7bIjK321es/O00TfsCWFN8/Ji85K/xL8bHv0ybAGmJ8ef4U+fjXzsff+58/KXv8R+/99DR+OfOxx86H3/sfPzW77+18Xd+/w2d339D5/ff0Pn9N3R+/42d339j5/ff2Pn9N3Z+/42d339j5/ff2Pn9N3Z+/42d339j5/df6fz+K53ff6Xz+690fv+Vzu+/0vn9Vzq//0rn91/p/P4rnd9/l87vv0vn99+l8/vv0vn9d+n8/rt0fv9dOr//Lp3ff5fO779L5/ff1Pn9N3V+/02d339T5/ff1Pn9N3V+/02d339T5/ff1Pn9N3V+/107v/+und9/187vv2vn99+18/vv2vn9d+38/rt2fv9dO7//rp3ff3Pn99/c+f03d37/zZ3ff3Pn99/c+f03d37/zZ3ff3Pn99/c+f23dH7/LZ3ff0vn99/S+f23dH7/LZ3ff0vn99/S+f23dH7/LX3ff2Xq+/4rU9/3X5n6vv/K1Pf9V6a+778y9X3/lanv+69Mfd9/Zer7/itT5/ffufP779z5/Xfu/P47d37/Nb/+VW38nd9/O1//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9KOl//Sjpf/0o6X/9q6Xz9q6Xz9a+Wzte/Wjpf/2qZ+r7/Lp2vf7V0vv7V0vn6V0vn618tna9/tXS+/tXS+fpXS+frXy2dr3+1dL7+1dL5+leL+fWvHn86rWV+Hv/BxlPetg3p8Ydvu93nav1e3XKu1u/rLedqvQdoOFfz63W1nKv13qLlXK33IS3nar1naTlXcTRX671Qy7k66pvMr3HWcq6O+ibza6c1nKv5ddZaztV63zRN20jSFNMPT2p9TbalLBv/Nc/lvVZLks2AL3l9+tPT0dZ5XsvX1re/vO5bhzJ9sTHe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",
      "brillig_names": [
        "sync_notes"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "DepositNote"
            },
            {
              "fields": [
                {
                  "name": "deposit_owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "deposit_amount",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "is_deposit",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000004"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "pSymm"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "custody_map",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "counterparties",
                    "type": {
                      "kind": "array",
                      "length": 1,
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress"
                      }
                    }
                  },
                  {
                    "name": "custody_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "pSymm::address_to_custody_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "pSymm::address_to_custody_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "counterparties",
                    "type": {
                      "kind": "array",
                      "length": 1,
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "types::address::aztec_address::AztecAddress"
                      }
                    }
                  },
                  {
                    "name": "custody_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "pSymm::custody_to_address_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "pSymm::custody_to_address_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "custody_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "pSymm::custody_balance_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "pSymm::custody_balance_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "pSymm::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "pSymm::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "custody_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "deposit_owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "pSymm::custody_balance_from_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "pSymm::custody_balance_from_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "pSymm::get_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "pSymm::get_config_abi"
        }
      ]
    }
  },
  "file_map": {
    "102": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "103": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "106": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "108": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "109": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "111": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "112": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "113": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "115": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "116": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "117": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "118": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "125": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "126": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "131": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "133": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "136": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "139": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "142": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "145": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "146": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "147": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "148": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "149": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "150": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "154": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "155": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "156": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "157": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "158": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "160": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "161": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "162": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "163": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "165": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "171": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\nmod test;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateSet<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:insert\n    pub fn insert<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        let (retrieved_notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < retrieved_notes.len() {\n                let retrieved_note = retrieved_notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, retrieved_note, note_hash);\n            }\n        }\n\n        // Since the notes were already destroyed, we no longer need the additional data in RetrievedNote and can\n        // discard it.\n        retrieved_notes.map(|retrieved_note| retrieved_note.note)\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, retrieved_note: RetrievedNote<Note>) {\n        let note_hash = compute_note_hash_for_read_request(retrieved_note, self.storage_slot);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, retrieved_note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note> PrivateSet<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes<let N: u32>(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\n    where\n        Note: Packable<N>,\n    {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "173": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "188": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "189": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    // Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "191": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "192": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "194": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "195": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "197": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "199": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "20": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "200": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "203": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "227": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "229": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "272": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "287": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "289": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "290": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "291": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "300": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "304": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "306": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "307": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "316": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "327": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "341": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "345": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "346": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "362": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "363": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "365": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "371": {
      "path": "/home/qbit/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "392": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "51": {
      "path": "/home/qbit/Desktop/work/otc-noirhack/contracts/psymm/src/custody.nr",
      "source": "use dep::aztec::{\n    context::PrivateContext,\n    messages::logs::note::encode_and_encrypt_note,\n    note::{\n        retrieved_note::RetrievedNote,\n        note_getter_options::NoteGetterOptions,\n    },\n    state_vars::{PrivateSet, storage::Storage},\n    macros::notes::note,\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n        utils::field::full_field_less_than,\n    },\n};\n\n\n\n#[note]\n#[derive(Eq)]\npub struct DepositNote {\n    deposit_owner: AztecAddress,\n    deposit_amount: Field,\n    owner: AztecAddress, // view-only for decryption\n    is_deposit: bool,    // true for deposits, false for withdrawals\n    randomness: Field,   // prevent brute-forcing note\n}\n\nimpl DepositNote {\n    pub fn new(deposit_owner: AztecAddress, deposit_amount: Field, owner: AztecAddress, is_deposit: bool) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n\n        let randomness = unsafe { random() };\n\n        DepositNote { deposit_owner, deposit_amount, owner, is_deposit, randomness }\n    }\n\n    pub fn deposit_owner(self) -> AztecAddress {\n        self.deposit_owner\n    }\n    pub fn owner(self) -> AztecAddress {\n        self.owner\n    }\n    pub fn deposit_amount(self) -> Field {\n        self.deposit_amount\n    }\n    pub fn is_deposit(self) -> bool {\n        self.is_deposit\n    }\n}\n\n\npub struct Custody<Context> {\n    context: Context,\n    set: PrivateSet<DepositNote, Context>,\n}\n\n// TODO(#13824): remove this impl once we allow structs to hold state variables.\nimpl<Context> Storage<1> for Custody<Context> {\n    fn get_storage_slot(self) -> Field {\n        self.set.get_storage_slot()\n    }\n}\n\nimpl<Context> Custody<Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        Custody { context, set: PrivateSet::new(context, storage_slot) }\n    }\n}\n\npub struct BalanceArgs {\n    from: AztecAddress,\n}\n\npub fn filter_notes_by_owner(\n    notes: [Option<RetrievedNote<DepositNote>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    args: BalanceArgs,\n) -> [Option<RetrievedNote<DepositNote>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    let mut selected = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n\n    for i in 0..notes.len() {\n        if notes[i].is_some() {\n            let retrieved_note = notes[i].unwrap_unchecked();\n            if retrieved_note.note.owner().eq(args.from) {\n                selected[i] = Option::some(retrieved_note);\n            }\n        }\n    }\n\n    selected\n}\n\nimpl Custody<&mut PrivateContext> {\n    pub fn add_deposit(self, amount: u64, deposit_owner: AztecAddress, owner: AztecAddress) {\n        let note = DepositNote::new(deposit_owner, amount as Field, owner, true);\n        self.set.insert(note).emit(encode_and_encrypt_note(self.context, owner, owner));\n    }\n\n    pub fn add_withdrawal(self, amount: u64, deposit_owner: AztecAddress, owner: AztecAddress) {\n        let note = DepositNote::new(deposit_owner, amount as Field, owner, false);\n        self.set.insert(note).emit(encode_and_encrypt_note(self.context, owner, owner));\n    }\n\n    pub fn get_balance(self, from: AztecAddress) -> Field {\n        let mut balance = 0;\n        let mut options = NoteGetterOptions::with_filter(filter_notes_by_owner, BalanceArgs { from });\n        let notes = self.set.get_notes(options);\n        \n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i).note;\n                if note.is_deposit() {\n                    balance += note.deposit_amount();\n                } else {\n                    balance -= note.deposit_amount();\n                }\n            }\n        }\n        \n        balance\n    }\n\n    pub fn get_balance_from(self, from: AztecAddress, deposit_owner: AztecAddress) -> Field {\n        let mut balance = 0;\n        let mut options = NoteGetterOptions::with_filter(filter_notes_by_owner, BalanceArgs { from });\n        let notes = self.set.get_notes(options);\n        \n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i).note;\n                if note.deposit_owner().eq(deposit_owner) {\n                    if note.is_deposit() {\n                        balance += note.deposit_amount();\n                    } else {\n                        balance -= note.deposit_amount();\n                    }\n                }\n            }\n        }\n        \n        balance\n    }\n}\n\n"
    },
    "52": {
      "path": "/home/qbit/Desktop/work/otc-noirhack/contracts/psymm/src/main.nr",
      "source": "mod config;\nmod custody;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract pSymm {\n    use dep::aztec::{\n        context::UtilityContext,\n        macros::{\n            functions::{initializer, private, public, view, utility, internal},\n            storage::storage,\n        },\n        prelude::{AztecAddress, Map, PrivateSet, PublicImmutable},\n        note::note_viewer_options::NoteViewerOptions,\n    };\n\n    use dep::token::Token;\n    use dep::types::traits::FromField;\n    use dep::authwit::auth::assert_inner_hash_valid_authwit;\n\n    use crate::config::Config;\n    use crate::custody::{Custody, DepositNote};\n\n    global MAX_COUNTERPARTIES: u32 = 1;\n\n    #[storage]\n    struct Storage<Context> {\n        /// L2 token address for custody operations\n        config: PublicImmutable<Config, Context>,\n        /// custody_id -> N*N of notes (N deposit notes with N owners)\n        custody_map: Map<Field, Custody<Context>, Context>,\n    }\n\n    /// Initialize with the L2 token address\n    #[public]\n    #[initializer]\n    fn constructor(token: AztecAddress) {\n        storage.config.initialize(Config { token });\n    }\n\n    /// Read-only view of the contract config\n    #[private]\n    #[view]\n    fn get_config() -> Config {\n        storage.config.read()\n    }\n\n    #[private]\n    fn custody_balance(custody_id: Field) -> Field {\n        storage.custody_map.at(custody_id).get_balance(context.msg_sender())\n    }\n\n    #[private]\n    fn custody_balance_from(custody_id: Field, deposit_owner: AztecAddress) -> Field {\n        storage.custody_map.at(custody_id).get_balance_from(context.msg_sender(), deposit_owner)\n    }\n\n\n    #[private]\n    fn address_to_custody(\n        from: AztecAddress,\n        // counterparties used to share note ownership\n        counterparties: [AztecAddress; MAX_COUNTERPARTIES],\n        custody_id: Field,\n        amount: u64, nonce: Field\n    ) {\n        assert(from.eq(context.msg_sender()));\n        // assert from is sender\n        let cfg = storage.config.read();\n        Token::at(cfg.token)\n            .transfer_to_public(from, context.this_address(), amount as u128, nonce)\n            .call(&mut context);\n\n        storage.custody_map.at(custody_id).add_deposit(amount, from, from);\n        for i in 0..MAX_COUNTERPARTIES {\n            if !counterparties[i].eq(AztecAddress::from_field(0)) {\n                storage.custody_map.at(custody_id).add_deposit(amount, from, counterparties[i]);\n            }\n        }\n    }\n\n    #[private]\n    fn custody_to_address(\n        to: AztecAddress, counterparties: [AztecAddress; MAX_COUNTERPARTIES],\n        custody_id: Field, amount: u64, nonce: Field\n    ) {\n        storage.custody_map.at(custody_id).add_withdrawal(amount, to, to);\n        for i in 0..MAX_COUNTERPARTIES {\n            if !counterparties[i].eq(AztecAddress::from_field(0)) {\n                storage.custody_map.at(custody_id).add_withdrawal(amount, to, counterparties[i]);\n            }\n        }\n\n        assert_inner_hash_valid_authwit(&mut context, to, 0);\n\n        for i in 0..MAX_COUNTERPARTIES {\n            if !counterparties[i].eq(AztecAddress::from_field(0)) {\n                assert_inner_hash_valid_authwit(&mut context, counterparties[i], 0);\n            }\n        }\n\n        let cfg = storage.config.read();\n        Token::at(cfg.token)\n            .transfer_in_public(context.this_address(), to, amount as u128, 0)\n            .enqueue(&mut context);\n\n    }\n}\n"
    },
    "54": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "63": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "70": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "72": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "73": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "77": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "89": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "92": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "93": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "94": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "98": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "99": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    }
  }
}
