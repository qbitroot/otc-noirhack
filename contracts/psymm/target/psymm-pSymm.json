{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "pSymm",
  "functions": [
    {
      "name": "deposit",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "custody_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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tttX0bZbpWjb7ado2+2vaNsdoGjbHaho2x0UiG33CkXb7mBF2+4xirbdIYq23aGKtt1jFW27wxRtu8cp2nZ5RduuoGjbFRVtu35F225A0bYbVLTthhRtu2FF225E0bYbVbTtHq9o2z1B0bZ7oqJt9yRF2+7JirbdUxRtu9WKtt1TFW27pynadocr2nZHKNp2RyradmsUbbujArHtXqlo2x2taNsdo2jbPV3RtnuGom13rKJtd5yibXe8om13gqJtd6KibXeSom13sqJtd4qibXeqom33TEXb7jRF2+50RdvuWYq23bMVbbszFG275yjadmcq2nbPVbTtnqdo2z1f0bZ7gaJtN6Zo240r2nYTirbdpKJtN6Vo200HYtu9StG2W6to252laNutU7Ttzla07c5RtO3OVbTtzlO07dYr2nbnK9p2Fyjadhcq2nYXKdp2GxRtu42Ktt0mRdtus6Jtd7GibXeJom13qaJtd5mibXe5om13haJtt0XRtrtS0ba7StG2Kynadlcr2nbXKNp21yradi9UtO2uC8S2e7WibXe9om23VdG2e5GibXeDom13o6Jtd5OibXezom13i6Jtd6uibXebom33YkXb7nZF2+4ORdvuTkXb7i5F2+5uRdvuHkXb7l5F226bom13n6Jtd7+ibfeAom33oKJt95Cibfewom33EkXb7qWKtt3LFG27lyvadq9QtO1eGYht9xpF2+5VirbdqxVtu9co2navVbTtXqdo271e0bZ7g6Jt90ZF2+5NirbdmxVtu7co2nZvVbTt3qZo271d0bZ7h6Jt905F2+5dirbduxVtu/co2nbvVbTt/p+ibfc+Rdvu/Yq23QcUbbsPKtp2H1K07f5N0bb7sKJt9xFF2+6jirbdxwKx7V6raNt9XNG2+4SibfdJRdvuU4q23acVbbvPKNp2/65o231W0bb7D0Xb7nOKtt3nFW27Lyjadl9UtO2+pGjbfVnRtvuKom33VUXb7muKtt3XFW27byjadt9UtO2+pWjbfVvRtvuOom33XUXb7nuKtt33FW27Hyjadj9UtO1+pGjb/diTbdcW/2rR+clIz058XWZ2ypxvzhVen9Hj35/a/ZQ5o1zmN2TCoPONgdD5pkDofHMgdL4lEDrfGgidbwuEzrcHQuc7AqHznYHQ+a5A6Hx3IHS+JxA63xsInf8vEDrfFwid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",
      "debug_symbols": "7P3dbuzasl6Jvsu+9gXZGfzzqxwcFFxVrsIGDPvA9rky6t1Lc0jJTC2R6imNyIjoPVpdFJY3cmqQ7QuK0b5MMf/Xv/2f//l/////3//bv//X/+u//Y9/+4//n//1b//lv/0f/+l//vt/+69v/6//9W+j/Pm//Y//33/6r//8P//H//xP//1//tt/LLOs/+Hf/vN//T/f/ucylv/nP/zb//Xv/+U//9t/3Pf/5z98fXGR4fbistxfvA4nL56Gff548TQu2/cvHud9vB3H2/+ehuPlZZvOXr/M2+3ly7oer56G058+LdPt1TIOn179//0P/zbOkLkgs0Dmgswam8wsdzIPLz8nU8ay3I5klPkvyWyQuSCzn5KRbbyTmb4nI+N4O3wZ5/u/sEz//ANlePU/MJ79A+NU5lte4zRt8/f/xNvLx+PV83J/8XLy4n3fj2t8GEZ5PKCzuGR+yOvhSD6OvzR+/NP58W9jOY5oX8fH4//nv5LTsRiH+z9V7v/SPJ6OxXIjJFO5XzXjspz+pt2O62Atd0LjG6J/jmcOdjxLsONZgx3PFux49ljHMw3BjmcMdjwl2PFMwY4n2O/nyfr3c5nW29JRZB6/HI/17+dSynYcz/qZzwnNYTpWymGuvXrd5baurvs+VfbPab0f9n13KGfLZ1nvS/M6V148rve1ZBuXyouH4yePw7Y/vvifdFbSCZzORjqB07HeZIrsRzrzNFd4P/Qrw4OGb+XktVsZb9lsZS6VbLpLUgaS7CTJkSQ7SbKQZCdJTqGTHMt2bDFSxsco/zl4afng59gHv0/HjO3L9P1F9HYt3K6h8fESOp30Mt4U+W2jXT+9+h8sC1jOsKxgOcOyZcUylQOLfMUS2368sMyxVcINS+y9/IVY5juWh/f2blhiL7luWIJvjF5YJO0N+gFL+YIl7Za7HmdY9uULlrRb7vdY0m6532NJu+U+/G7Zv+4tHW2523IvaR5+8jmX17VQ0922plIrlqbpeK97emzOft5CLR0t5kGSdOoTl45cInmSHemPWpL/cInuP8fHjMd9nys34+Oj4+vjB7b300/QbssNS9m2h48SbX+oCFROqES3Hx8q0eXHh0p09/GhEl19fKhENx8XKmt0i/ChEn0j96ESfbv1ocJue0ZFoHJChd32jAq77RkVdtszKuy2Z1TYbU+obOy2Z1TYbc+osNueUWG3PaMiUDmhwm57RoXd9owKu+0ZFXbbMyrstidUdnbbMyrstmdU2G3PqLDbnlERqJxQYbc9o8Jue0aF3faMCrvtGRV22xMq48Bye4qF7fYUC+vtKRb221MsApYzLB1tuPcz3bbhE5Y/Z9rR1lo504420X15fHB1Zdbnqdz+YO7tMGpPVe/ur1De/k8EnzP4jnyC4H8Q/NiRMRH8T4LvyAkJ/ifBd2S9BP+T4DvyeoL/SfBC8DmD76ibIfifBN9RVUXwPwme5i5p8DR3SYOnucsZfKG5Sxo8zV3S4GnukgZPc5c0eCH4nMHT3CUNnuYuafA0d0mDp7lLGjzNXc7gJ5q7pMHT3CUNnuYuafA0d0mDF4LPGTzNXdLgae6SBk9zlzR4mrukwdPc5QxeaO6SBk9zlzR4mrukwdPcJQ1eCD5n8DR3SYOnuUsaPM1d0uBp7pIGT3OXM/iZ5i5p8DR3SYOnuUsaPM1d0uCF4HMGT3OXNHiau6TB09wlDZ7mLmnwNHc5g19o7pIGT3OXNHiau6TB09wlDV4IPmfwNHdJg6e5Sxo8zV3S4GnukgZPc5cz+JXmLmnwNHdJg6e5Sxo8zV3S4IXgcwZPc5c0eJq7pMHT3CUNnuYuafA0dzmD32jukgZPc5c0eJq7pMHT3CUNXgg+Z/A0d0mDp7lLGjzNXdLgae6SBk9zlzP4neYuafA0d0mDp7lLGjzNXdLgheBzBk9zlzR4mrukwdPcJQ2e5i5p8DR3KYMvA81d0uBp7pIGT3OXNHiau6TBC8HnDJ7mLmnwNHdJg6e5Sxo8zV3S4GnucgY/0twlDZ7mLmnwNHdJg6e5Sxq8EHzO4GnukgZPc5c0eJq7pMHT3CUNnuYuZ/CF5i5p8DR3SYOnuUsaPM1d0uCF4HMGT3OXNHiau6TB09wlDZ7mLmnwNHc5g59o7pIGT3OXNHiau6TB09wlDV4IPmfwNHdJg6e5Sxo8zV3S4GnukgZPc5czeKG5Sxo8zV3S4GnukgZPc5c0eCH4nMHT3CUNnuYuafA0d0mDp7lLGjzNXc7gZ5q7pMHT3CUNnuYuafA0d0mDF4LPGTzNXdLgae6SBk9zlzR4mrukwdPc5Qx+oblLGjzNXdLgae6SBk9zlzR4IficwdPcJQ2e5i5p8DR3SYOnuUsaPM1dzuBXmrukwdPcJQ2e5i5p8DR3SYMXgs8ZPM1d0uBp7pIGT3OXNHiau6TB09zlDH6juUsaPM1d0uBp7pIGT3OXNHgh+JzB09wlDZ7mLmnwNHdJg6e5Sxo8zV3O4Heau6TB09wlDZ7mLmnwNHdJgxeCzxk8zV3S4GnukgZPc5c0eJq7pMHT3KUMfhpo7pIGT3OXNHiau6TB09wlDV4IPmfwNHdJgw/e3G3Hz/7X4P8cfez6qcz7bVzK8pDq6diOpRwzXqbhePE0n/3ofdpur95lWO8Hsp0N4rTdhnya9ocXr2cvHsptut4WgenxxX+Qxy5+ukQeu3LpEfkYu+zoEnnsmqFN5ON8O8XpbWv4gjy24HeJPLZaN4r8OMWpjNP3Ly5LGY8znCovHvdpPNZP2b6EKYTZTphlGA7HGkrlxfM63bRw3x9P70/usW2Z3F+Ve2xZJvdX5U7N0FTucuQyLPvf5E7XkTN3CpeWcr8bVxk3+dclvVDldBQmJVFHYVI/tRRmOQ6jfEJ9WpxMx/11nPbxS/K0YFmTF5LvNfl5vL14nKX8xf5d6NcYkuqQUMYxJNUhobnrd0iW4725+bNc/HRIqPkYkuqQ0Al6D8m8HmdYq3crb9xPdIINhan3Rt5EfZgzd5rGpnLXeiNvomfMmbuQe0O5f/820UQb2FGYtHYdhUm71lKYim/jTVRmWZOnB+s2ebW3XYR+jSGpDgllHENSHRKau36HROu9OaHmY0iqQyIMie+QrNNxhuvydxYidIIdhUkn2FKYersd9WHO3CkPc+ZOddhU7lqb90wbmDN3Cj793MsqR+5bzbQVn3U1U8Q1FKbeRydnurWcuQu5p8ydZq2p3LU+MjtTwuXMnRKupdy//0DmTLPWUZjUZf2EudCBtRSm4gdmF1qwrMlTmXWbvNqbYgv9GkNSHRJhSBiS2pDQ3PU7JFrvyS7UfAxJdUjoBL2HRO9ZVwudYENh6r2Rt1Afpsx9pWlsKnetN/JWesacudMytpT7928TrbSBHYUphNlPmLRrLYWp+DbeSmWWNXl6sG6TV3vbZaVfY0iqQ0IZx5DUhmSjuet3SLTem9uo+RiS6pDQCToPieLjkTY6wY7CFMJsKEy93Y76MGfulIc5c6c6bCp3tc2bNjBn7sELvmU/PnW8znMjuQ/lZtrT8Pmj0v8g34PXZT0iD14+9Yg8eJXTI/LghUuTyO+frpnGdf+CXEBujTx4I9Em8h99aYbe0zn34DUDYX56sdofe+zBawZyf1HuwWsGcn9R7tQMTeWu9Ec+MtB15MydwqWl3L/9ExIZqHI6CpOSqKMwhTAbClPvT3xkoAXLmjyVWbfJa32M540OQ8KQ1IaEMo4hqQ4JzV2/Q6L0KTIZqfkYkuqQ0Al6D4na0zllpBNsKEy1N/JkpD7MmbuQe0u5a72RN9Iz5sydlrGl3L9/m2ikDewoTFq7jsKkXWspTMW38QqVWdbk6cG6TV7tbZdCv8aQVIeEMo4hqQ6JMCTdDonWe3OFmo8hqQ4JnaDzkOg90FEKnWBHYdIJthSm3m5HfZgy94nyMGfuVIdN5a61eU+0gTlzp+Dz/tIMtWddySSE2U6Yeh+dnOjWcuZOXZYzd5q1pnLX+sjsRAmXM3dKuJZy//4DmUKz1lGY1GUdhUkH1lKYih+YFVqwrMkLyfeavNqbYkK/xpBUh4QyjiGpDgnNXb9DovWerFDzMSTVIaET9B4SvWddzXSCDYWp90beTH2YM3eaxqZy13ojb6ZnzJm7kHtDuX//NtFMG9hRmLR2HYVJu9ZSmIpv481UZlmTpwfrNnm1t10W+jWGpDoklHEMSXVIaO76HRKt9+YWaj6GpDokwpD4Doni45EWOsGOwqQTbClMvd2O+jBn7pSHOXOnOmwqd63Ne6UNzJl78IJv224HX/axPOb+5+iDN0/bUu5HP305+tiVyDSUG/tpWJcvRy9NH725nM7bcX3Pu3w6+j8HtEQ7oDXaAW3RDsh8V1qONa8sMnw5oG2IdkBjtAMyv2G8/d4/bgEPv4aOA7q4B0z3z/Q8lDGnBzSP5Xb08/RQ7O7z2a/FUW5HP40Pi9R8/jt0n48XP+wk63C6k+zjeiwl+8PeVbbp7PXL8bmlcVnvq9Q0nP70aTnqKRmHT6/+w1HgqMJx7ojjLHeODy8/51juh11Gmf+W4wJHFY4rHFU4bjWOZV6+5zhN5UDzyPEczbodN8mHNxPkffvedoWjWQ8Tl2n5/mjGpdzf3VjkwcWX6c8B7UO0AxqND2h9uI289Q/zlwMq0Q5oUj2gZRi/P6CyL4dP3q/dZX4/GDk9mGk9WisZK3vlW1N1bIrT+HAwH6d7fmOWciiKyP79v/C25R4zNz4+e33ezjum208e7sXL2++Ak9euu9wOY933qfKbbVrvC/Tdqk5/8FuDNtx7v8qLx3U/FqdtXCovHo6fPA4P1195/325L+C2xL3+Pe5xO35flIf75Tnued5vx7Ns5cHth9NGeRyPox/LQ+27yPvhb20f/l49/EUqhz8Pd2mZP/8TX1+9HJvE8vhuVZHTg7933WVfHn8vfn3xVsbbMW9lLpUr43XX0XS3/qnULo1pun/y4vGYf34dzcNAkp0kOZJkJ0kWkuxiS5mHiSQ7SVJIspMkZ5LsJMnFOMn1KFy2apLb8Z7Mvj2q/PR+6KvxoW9yK662dawc+tu72LefPG+rPPZoZ62zzA+185fabR62PKda1+K1YvXzfHz26oHKWE4r83m/t5EPF954+km0t/ep52NDXbfKq98aheOilsdP95++Wt5+b91+XYyPl8Y4nu/K631XfjiS7exnL/tw+5W47GPl43Zv1YYcvxKX8vjifwIaBwKKHdBIQLEDKgQUO6CJgGIHJAQUO6CZgGIHtBBQ7IBWAood0EZAsQOiSYgdUKFJCB4QTULwgGgSggdEkxA8ICGg2AHRJAQPiCYheEA0CcEDokkIHhBNQuyAJpqE4AHRJAQPiCYheEA0CcEDEgKKHRBNQvCAaBKCB0STEDwgmoTgAdEkxA5IaBKCB0STEDwgmoTgAdEk6Ae0Frk9SWgtj0w+mAvMzZnj+/bMUfhXMD/Ocp3Gr8yxcnvmiLY9c9zZnPmMDtszx3DN95YZabVnjofaMxeYm/8+x0PtmeOh9szxUHvmeKg9czzUnPmCh9ozx0PN9/MFD7VnjofaMxeYmzPHQ+2Z46H2ewseas8cD7VnjoeaM1/xUHvmeKg9czzUnjkeas9cYG7OHA8199AVD7VnjofaM8dD7ZnjoebMNzzUfG/Z8FB75nioPXM81J65wNycOR5qzxwPtWeOh9ozx0PtmeOh5h6646H2zPFQe+Z4qD1zPNSeucDcem/Z8VB75nioPXM81J45HmrPHA+1Zr4MeKg9czzUnjkeas8cD7X20GUQmJszx0PtmeOh9szxUHvmeKj93oKHmjMf8VB75nioPXM81J45HmrPXGBuzhwPtWeOh9ozx0PNPXTEQ+2Z46HmzAseas8cD7Vnjoea7y0FD7VnLjA3Z46H2jPHQ+2Z46H2zPFQe+Z4qDnzCQ+1Z46HmnvohIfaM8dD7ZkLzM2Z46H2zPFQ+70FD7VnjofaM8dDzZkLHmrPHA+1Z46H2jPHQ+2ZC8zNmeOh5h4qeKg9czzUnjkeas8cDzVnPuOh5nvLjIfaM8dD7ZnjofbMBebmzPFQe+Z4qD1zPNSeOR5qzxwPNffQBQ+1Z46H2jPHQ+2Z46H2zAXm1nvLgofaM8dD7ZnjofbM8VB75nioOfMVD7VnjofaM8dD7ZnjoeYeugrMzZnjofbM8VB75nioPXM81H5vwUPNmW94qD1zPNSeOR5qzxwPtWcuMDdnjofaM8dD7ZnjoeYeuuGh9szxUHPmOx5qzxwPtWeOh5rvLTseas9cYG7OHA+1Z46H2jPHQ+2Z46H2zPFQa+brgIfaM8dDrT10HfBQe+Z4qD1zgbk5czzUnjkear+34KH2zPFQe+Z4qDnzEQ+1Z46H2jPHQ+2Z46H2zAXm5szxUHMPHfFQe+Z4qD1zPNSeOR5qzrzgoeZ7S8FD7ZnjofbM8VB75gJzc+Z4qD1zPNSeOR5qzxwPtWeOh5p76ISH2jPHQ+2Z46H2zPFQe+YCc+u9ZcJD7ZnjofbM8VB75nioPXM81Jy54KH2zPFQe+Z4qD1zPNTcQ0Vgbs4cD7VnjofaM8dD7ZnjofZ7Cx5qznzGQ+2Z46H2zPFQe+Z4qD1zgbk5czzUnjkeas8cDzX30BkPtWeOh5ozX/BQe+Z4qD1zPNR8b1nwUHvmAnNz5nioPXM81J45HmrPHA+1Z46HmjNf8VB75niouYeueKg9czzUnrnA3Jw5HmrPHA+131vwUHvmeKg9czzUnPmGh9ozx0PtmeOh9szxUHvmAnNz5niouYdueKg9czzUnjkeas8cDzVnvuOh5nvLjofaM8dD7ZnjofbMBebmzPFQe+Z4qD1zPNSeOR5qzxwPtfbQbcBD7ZnjofbM8VB75nioPXOBufHesg14qD1zPNSeOR5qzxwPtWeOh5ozH/FQe+Z4qD1zPNSeOR5q7qGjwNycOR5qzxwPtWeOh9ozx0Pt9xY81Jx5wUPtmeOh9szxUHvmeKg9c4G5OXM81J45HmrPHA8199CCh9ozx0PNmU94qD1zPNSeOR5qvrdMeKg9c4G5OXM81J45HmrPHA+1Z46H2jPHQ82ZCx5qzxwPNfdQwUPtmeOh9swF5ubM8VB75nio/d6Ch9ozx0PtmeOh5sxnPNSeOR5qzxwPtWeOh9ozF5ibM8dDzT10xkPtmeOh9szxUHvmeKg58wUPNd9bFjzUnjkeas8cD7VnLjA3Z46H2jPHQ+2Z46H2zPFQe+Z4qLmHrnioPXM81J45HmrPHA+1Zy4wt95bVjzUnjkeas8cD7VnjofaM8dDzZlveKg9czzUnjkeas8cDzX30E1gbs4cD7VnjofaM8dD7ZnjofZ7Cx5qznzHQ+2Z46H2zPFQe+Z4qD1zgbk5czzUnjkeas8cDzX30B0PtWeOh1oz3wc81J45HmrPHA+13lv2AQ+1Zy4wN2eOh9ozx0PtmeOh9szxUHvmeKg58xEPtWeOh5p76IiH2jPHQ+2ZC8zNmeOh9szxUPu9BQ+1Z46H2jPHQ82ZFzzUnjkeas8cD7VnjofaMxeYmzPHQ809tOCh9szxUHvmeKg9czzUnPmEh5rvLRMeas8cD7VnjofaMxeYmzPHQ+2Z46H2zPFQe+Z4qD1zPNTcQwUPtWeOh9ozx0PtmeOh9swF5tZ7i+Ch9nOOh9ozx0PtmeOh9szxUHPmMx5qvrfMeKj9nOOh9szxUHvmAnNz5nioPXM81H5vwUPtmeOh9szxUHPmCx76AuZ3fG//c/3CHA/VZ77sw/jx6mUfPzH/+uKtiHy8eCtL+RIQ0ho8IAw3eEBCQLEDwp2DB4RoBw8IKw8eEAofPCB8P3ZAK+VA8IBoEoIHRJMQPCCahOABCQHFDogmIXhANAnBA6JJCB4QTULwgGgSYge00SQED4gmIXhANAnBA6JJCB6QEFDsgGgSggdEkxA8IJqE4AHRJAQPiCYhdkA7TULwgGgSggdEkxA8IJqE4AEJAcUOiCbB/MkAO+WAPXN83545Cm/+V+o7Vm7NfBwGTNsBOvbsAB0jdoCO5VrvLm/QBej20LFRB+joqMPvdHzUATpC6gAdI7WHPmKkDtAxUgfoGKkDdIzUfk8fBej20DFSB+gYqQN0jNQBOkbqsL1gpPbQC0bqAB0jdYCOkTpAx0gdoAvQ7aFjpA7QMVIH6BipvZEWjNQBOkZqD33CSB2gY6QO0DFS++1lwkgdoAvQ7aFjpA7QMVIH6BipA3SM1AE6RmoPXTBSB+gYqb2RCkbqAB0jdYAuQLeHjpE6QMdIHbYXjNQBOkbqAB0jtYc+Y6QO0DFSB+gYqQN0jNQBugDdHjpGam+kM0bqAB0jdYCOkTpAx0jtoS8Yqf32smCkDtAxUgfoGKkDdAG6PXSM1AE6RuoAHSN1gI6ROkDHSO2NdMVIHaBjpA7QMVIH6BipA3QBuvn2smKkDtAxUgfoGKkDdIzUATpGag99w0gdoGOkDtAxUgfoGKm9kW4CdHvoGKkDdIzUATpG6gAdI3XYXjBSe+g7RuoAHSN1gI6ROkDHSB2gC9DtoWOkDtAxUgfoGKm9ke4YqQN0jNQc+jhgpA7QMVIH6Bip+fYyDhipA3QBuj10jNQBOkbqAB0jdYCOkTpAx0jtoY8YqQN0jNTeSEeM1AE6RuoAXYBuDx0jdYCOkTpsLxipA3SM1AE6RmoPvWCkDtAxUgfoGKkDdIzUAboA3R46RmpvpAUjdYCOkTpAx0gdoGOk9tAnjNR+e5kwUgfoGKkDdIzUAboA3R46RuoAHSN1gI6ROkDHSB2gY6T2RioYqQN0jNQBOkbqAB0jdYAuQDffXgQjdYCOkTpAx0gdoGOkDtAxUnvoM0bqAB0jdYCOkTpAx0jtjXQWoNtDx0gdoGOkDtAxUgfoGKnD9oKR2kNfMFIH6BipA3SM1AE6RuoAXYBuDx0jdYCOkTpAx0jtjXTBSB2gY6T20FeM1AE6RuoAHSO1315WjNQBugDdHjpG6gAdI3WAjpE6QMdIHaBjpPbQN4zUATpGam+kG0bqAB0jdYAuQLeHjpE6QMdIHbYXjNQBOkbqAB0jtYe+Y6QO0DFSB+gYqQN0jNQBugDdHjpGam+kO0bqAB0jdYCOkTpAx0jNoZcBIzXfXsqAkTpAx0gdoGOkDtAF6PbQMVIH6BipA3SM1AE6RuoAHSO1N9IRI3WAjpE6QMdIHaBjpA7QBejm28uIkTpAx0gdoGOkDtAxUgfoGKk99IKROkDHSB2gY6QO0DFSeyMtAnR76BipA3SM1AE6RuoAHSN12F4wUnvoE0bqAB0jdYCOkTpAx0gdoAvQ7aFjpA7QMVIH6BipvZFOGKkDdIzUHrpgpA7QMVIH6Bip/fYiGKkDdAG6PXSM1AE6RuoAHSN1gI6ROkDHSO2hzxipA3SM1N5IZ4zUATpG6gBdgG4PHSN1gI6ROmwvGKkDdIzUATpGag99wUgdoGOkDtAxUgfoGKkDdAG6PXSM1N5IF4zUATpG6gAdI3WAjpHaQ18xUvvtZcVIHaBjpA7QMVIH6AJ0e+gYqQN0jNQBOkbqAB0jdYCOkdob6YaROkDHSB2gY6QO0DFSB+gCdPPtZcNIHaBjpA7QMVIH6BipA3SM1B76jpE6QMdIHaBjpA7QMVJ7I90F6PbQMVIH6BipA3SM1AE6RuqwvWCk5tCnASN1gI6ROkDHSB2gY6QO0AXo9tAxUgfoGKkDdIzU3EinASN1gI6R2kMfMVIH6BipA3SM1H57GTFSB+gCdHvoGKkDdIzUATpG6gAdI3WAjpHaQy8YqQN0jNTeSAtG6gAdI3WALkC3h46ROkDHSB22F4zUATpG6gAdI7WHPmGkDtAxUgfoGKkDdIzUAboA3R46RmpvpBNG6gAdI3WAjpE6QMdI7aELRmq/vQhG6gAdI3WAjpE6QBeg20PHSB2gY6QO0DFSB+gYqQN0jNTeSGeM1AE6RuoAHSN1gI6ROkAXoJtvLzNG6gAdI3WAjpE6QMdIHaBjpPbQF4zUATpG6gAdI3WAjpHaG+kiQLeHjpE6QMdIHaBjpA7QMVKH7QUjtYe+YqQO0DFSB+gYqQN0jNQBugDdHjpG6gAdI3WAjpHaG+mKkTpAx0jtoW8YqQN0jNQBOkZqv71sGKkDdAG6PXSM1AE6RuoAHSN1gI6ROkDHSO2h7xipA3SM1N5Id4zUATpG6gBdgG4PHSN1gI6ROmwvGKnDpGOkDtAxUnPoMmCkDtAxUgfoGKn59iIDRuow6QJ0e+gYqQN0jNQBOkbqAB0jddheMFJ76CNG6gAdI3WAjpG+APod39v/XL9Cx0j1oS/7MH68etnHT9C/vngrIh8v3spSviYkJBQ8IVw3ekKIcfSEsOjoCaHc0RPCz4MnVJD56Alh/tEToiaInhCdQvSEhISCJ0SnED0hOoXoCdEpRE+ITiF6QnQKwROa6BSiJ0SnED0hOoXoCdEpRE9ISCh4QnQK0ROiU4ieEJ1C9IToFKInRKcQPCGhU4ieEJ1C9IToFKInRKcQPSEhoeAJ0SlET4hOIXpCdAr2TxAQagIH6Ji/PfQZmbf/Y/YZP3eAjnI7QMeiHaAL0O2h47oO2wv66gAdI3WAjpE6/E7HSO2hLxipA3SM1AE6RuoAHSN1gC5At4eOkdrv6QtG6gAdI3WAjpE6QMdI7aGvGKn99rJipA7QMVIH6BipA3QBuj10jNQBOkbqAB0jdYCOkTpAx0jtjXTDSB2gY6QO0DFSB+gYqQN0Abr59rJhpA7QMVIH6BipA3SM1AE6RmoPfcdIHaBjpA7QMVIH6BipvZHuAnR76BipA3SM1AE6RuoAHSN12F4wUnPo84CROkDHSB2gY6QO0DFSB+gCdHvoGKkDdIzUATpGam6k84CROkDHSO2hjxipA3SM1AE6Rmq/vYwYqQN0Abo9dIzUATpG6gAdI3WAjpE6QMdI7aEXjNQBOkZqb6QFI3WAjpE6QBeg20PHSB2gY6QO2wtG6gAdI3WAjpHaQ58wUgfoGKkDdIzUATpG6gBdgG4PHSO1N9IJI3WAjpE6QMdIHaBjpPbQBSO1314EI3WAjpE6QMdIHaAL0O2hY6QO0DFSB+gYqQN0jNQBOkZqb6QzRuoAHSN1gI6ROkDHSB2gC9DNt5cZI3WAjpE6QMdIHaBjpA7QMVJ76AtG6gAdI3WAjpE6QMdI7Y10EaDbQ8dIHaBjpA7QMVIH6Bipw/aCkdpDXzFSB+gYqQN0jNQBOkbqAF2Abg8dI3WAjpE6QMdI7Y10xUgdoGOk9tA3jNQBOkbqAB0jtd9eNozUAboA3R46RuoAHSN1gI6ROkDHSB2gY6T20HeM1AE6RmpvpDtG6gAdI3WALkC3h46ROkDHSB22F4zUATpG6gAdIzWHvgwYqQN0jNQBOkbqAB0jdYAuQLeHjpGaG+kyYKQO0DFSB+gYqQN0jNQe+oiR2m8vI0bqAB0jdYCOkTpAF6DbQ8dIHaBjpA7QMVIH6BipA3SM1N5IC0bqAB0jdYCOkTpAx0gdoAvQzbeXgpE6QMdIHaBjpA7QMVIH6BipPfQJI3WAjpE6QMdIHaBjpPZGOgnQ7aFjpA7QMVIH6BipA3SM1GF7wUjtoQtG6gAdI3WAjpE6QMdIHaAL0O2hY6QO0DFSB+gYqb2RCkbqAB0jtYc+Y6QO0DFSB+gYqf32MmOkDtAF6PbQMVIH6BipA3SM1AE6RuoAHSO1h75gpA7QMVJ7I10wUgfoGKkDdAG6PXSM1AE6RuqwvWCkDtAxUgfoGKk99BUjdYCOkTpAx0gdoGOkDtAF6PbQMVJ7I10xUgfoGKkDdIzUATpGag99w0jtt5cNI3WAjpE6QMdIHaAL0O2hY6QO0DFSB+gYqQN0jNQBOkZqb6Q7RuoAHSN1gI6ROkDHSB2gC9DNt5cdI3WAjpE6QMdIHaBjpA7QMVJz6OuAkTpAx0gdoGOkDtAxUnMjXQcBuj10jNQBOkbqAB0jdYCOkTpsLxipPfQRI3WAjpE6QMdIHaBjpA7QBej20DFSB+gYqQN0jNTeSEeM1AE6RmoPvWCkDtAxUgfoGKn99lIwUgfoAnR76BipA3SM1AE6RuoAHSN1gI6R2kOfMFIH6BipvZFOGKkDdIzUAboA3R46RuoAHSN12F4wUgfoGKkDdIzUHrpgpA7QMVIH6BipA3SM1AG6AN0eOkZqb6SCkTpAx0gdoGOkDtAxUnvoM0Zqv73MGKkDdIzUATpG6gBdgG4PHSN1gI6ROkDHSB2gY6QO0DFSeyNdMFIH6BipA3SM1AE6RuoAXYBuvr0sGKkDdIzUATpG6gAdI3WAjpHaQ18xUgfoGKkDdIzUATpGam+kqwDdHjpG6gAdI3WAjpE6QMdIHbYXjNQe+oaROkDHSB2gY6QO0DFSB+gCdHvoGKkDdIzUATpGam+kG0bqAB0jtYe+Y6QO0DFSB+gYqf32smOkDtAF6PbQMVIH6BipA3SM1AE6RuoAHSM1h74NGKkDdIzU3Ei3ASN1gI6ROkAXoNtDx0gdoGOkDtsLRuoAHSN1gI6R2kMfMVIH6BipA3SM1AE6RuoAXYBuDx0jtTfSESN1gI6ROkDHSB2gY6T20AtGar+9FIzUATpG6gAdI3WALkC3h46ROkDHSB2gY6QO0DFSB+gYqb2RThipA3SM1AE6RuoAHSN1gC5AN99eJozUATpG6gAdI3WAjpE6QMdI7aELRuoAHSN1gI6ROkDHSO2NVATo9tAxUgfoGKkDdIzUATpG6rC9YKT2kz5jpA7QMVIH6BipA3SM1AG6AN18e5kxUodJx0gdoGOkDtAxUgfoGKk99AUjtd9eFozUATpG6gAdI3WALkDXh37H9/Y/16/QMVJ96Ms+jB+vXvbxE/SvL96KyMeLt7KUrwmhr9ETwnWjJ4QYR08Iiw6e0IpyR08IP4+eEDIfPSHMP3pCQkLBE6JTiJ4QnUL0hOgUoidEpxA9ITqF4AltdArRE6JTiJ4QnUL0hOgUoickJBQ8ITqF6AnRKURPiE4hekJ0CtETolMIntBOpxA9ITqF6AnRKURPiE4hekJCQsETolOInhCdQvSE6BSiJ0SnED0hOgXzJwjsAzWBA3TM3wE6Mm/+x+z7gJ87QBeg20PHoh2gI8YO0HFdh+0FfXWAjpHaQx8xUvvf6SNG6gAdI3WAjpE6QBeg20PHSB2gY6QO0DFShz0dI3WAjpHaQy8YqQN0jNQBOkZqv70UjNQBugDdHjpG6gAdI3WAjpE6QMdIHaBjpPbQJ4zUATpGam+kE0bqAB0jdYAuQLeHjpE6QMdIHbYXjNQBOkbqAB0jtYcuGKkDdIzUATpG6gAdI3WALkC3h46R2hupYKQO0DFSB+gYqQN0jNQe+oyR2m8vM0bqAB0jdYCOkTpAF6DbQ8dIHaBjpA7QMVIH6BipA3SM1N5IF4zUATpG6gAdI3WAjpE6QBegm28vC0bqAB0jdYCOkTpAx0gdoGOk9tBXjNQBOkbqAB0jdYCOkdob6SpAt4eOkTpAx0gdoGOkDtAxUoftBSO1h75hpA7QMVIH6BipA3SM1AG6AN0eOkbqAB0jdYCOkdob6YaROkDHSO2h7xipA3SM1AE6Rmq/vewYqQN0Abo9dIzUATpG6gAdI3WAjpE6QMdIraGXYcBIHaBjpNZG+gYdI3WAjpE6QBeg20PHSB2gY6QO2wtG6gAdI3WAjpHaQx8xUgfoGKkDdIzUATpG6gBdgG4PHSO1N9IRI3WAjpE6QMdIHaBjpPbQC0Zqv70UjNQBOkbqAB0jdYAuQLeHjpE6QMdIHaBjpA7QMVIH6BipvZFOGKkDdIzUATpG6gAdI3WALkA3314mjNQBOkbqAB0jdYCOkTpAx0jtoQtG6gAdI3WAjpE6QMdI7Y1UBOj20DFSB+gYqQN0jNQBOkbqsL1gpPbQZ4zUATpG6gAdI3WAjpE6QBeg20PHSB2gY6QO0DFSeyOdMVIH6BipPfQFI3WAjpE6QMdI7beXBSN1gC5At4eOkTpAx0gdoGOkDtAxUgfoGKk99BUjdYCOkdob6YqROkDHSB2gC9DtoWOkDtAxUoftBSN1gI6ROkDHSO2hbxipA3SM1AE6RuoAHSN1gC5At4eOkdob6YaROkDHSB2gY6QO0DFSe+g7Rmq/vewYqQN0jNQBOkbqAF2Abg8dI3WAjpE6QMdIHaBjpA7QMVJzIx0HjNQBOkbqAB0jdYCOkTpAF6Bbby/jgJE6QMdIHaBjpA7QMVIH6BipPfQRI3WAjpE6QMdIHaBjpPZGOgrQ7aFjpA7QMVIH6BipA3SM1GF7wUjtoReM1AE6RuoAHSN1gI6ROkAXoNtDx0gdoGOkDtAxUnsjLRipA3SM1B76hJE6QMdIHaBjpPbby4SROkAXoNtDx0gdoGOkDtAxUgfoGKkDdIzUHrpgpA7QMVJ7IxWM1AE6RuoAXYBuDx0jdYCOkTpsLxipA3SM1AE6RmoPfcZIHaBjpA7QMVIH6BipA3QBuj10jNTeSGeM1AE6RuoAHSN1gI6R2kNfMFL77WXBSB2gY6QO0DFSB+gCdHvoGKkDdIzUATpG6gAdI3WAjpHaG+mKkTpAx0gdoGOkDtAxUgfoAnTz7WXFSB2gY6QO0DFSB+gYqQN0jNQe+oaROkDHSB2gY6QO0DFSeyPdBOj20DFSB+gYqQN0jNQBOkbqsL1gpPbQd4zUATpG6gAdI3WAjpE6QBeg20PHSB2gY6QO0DFSeyPdMVIH6BipOfQyYKQO0DFSB+gYqfn2UgaM1AG6AN0eOkbqAB0jdYCOkTpAx0gdoGOk9tBHjNQBOkZqb6QjRuoAHSN1gC5At4eOkTpAx0gdtheM1AE6RuoAHSO1h14wUgfoGKkDdIzUATpG6gBdgG4PHSO1N9KCkTpAx0gdoGOkDtAxUnvoE0Zqv71MGKkDdIzUATpG6gBdgG4PHSN1gI6ROkDHSB2gY6QO0DFSeyMVjNQBOkbqAB0jdYCOkTpAF6Cbby+CkTpAx0gdoGOkDtAxUgfoGKk99BkjdYCOkTpAx0gdoGOk9kY6C9DtoWOkDtAxUgfoGKkDdIzUYXvBSO2hLxipA3SM1AE6RuoAHSN1gC5At4eOkTpAx0gdoGOk9ka6YKQO0DFSe+grRuoAHSN1gI6R2m8vK0bqAF2Abg8dI3WAjpE6QMdIHaBjpA7QMVJ76BtG6gAdI7U30g0jdYCOkTpAF6DbQ8dIHaBjpA7bC0bqAB0jdYCOkdpD3zFSB+gYqQN0jNQBOkbqAF2Abg8dI7U30h0jdYCOkTpAx0gdoGOk5tCnASM1316mASN1mHSM1AE6RuoAXYBuDx0jdYCOkTpsLxipw6RjpA7QMVJ76CNG6gAdI3WAjpHaby8jRuoAXYBuDx0jdYCOkb4A+h3f2/9cv0LHSPWhL/swfrx62cdP0L++eCsiHy/eylK+JoS+Rk8I1w2eUEGMoyeERUdPCOWOnhB+Hj0hIaHgCWH+0ROiJoieEJ1C9IToFKInRKcQPKGJTiF6QnQK0ROiU4ieEJ1C9ISEhIInRKcQPSE6hegJ0SlET4hOIXpCdArBExI6hegJ0SlET4hOIXpCdArRExISCp4QnUL0hOgUoidEpxA9ITqF6AnRKQRPaKZTiJ4QnYL9EwRmagIH6Ji/A3QBuvkfs8/4uQN0lNsBOhbtAB0xdoCO69pvLwv66gAdI3WAjpHa/05fMFIH6AJ0e+gYqQN0jNQBOkbqAB0jdYCOkdrv6StG6gAdI3WAjpE6QMdIHaAL0M23lxUjdYCOkTpAx0gdoGOkDtAxUnvoG0bqAB0jdYCOkTpAx0jtjXQToNtDx0gdoGOkDtAxUgfoGKnD9oKR2kPfMVIH6BipA3SM1AE6RuoAXYBuDx0jdYCOkTpAx0jtjXTHSB2gY6Tm0GXASB2gY6QO0DFS8+1FBozUAboA3R46RuoAHSN1gI6ROkDHSB2gY6T20EeM1AE6RmpvpCNG6gAdI3WALkC3h46ROkDHSB22F4zUATpG6gAdI7WHXjBSB+gYqQN0jNQBOkbqAF2Abg8dI7U30oKROkDHSB2gY6QO0DFSe+gTRmq/vUwYqQN0jNQBOkbqAF2Abg8dI3WAjpE6QMdIHaBjpA7QMVJ7IxWM1AE6RuoAHSN1gI6ROkAXoJtvL4KROkDHSB2gY6QO0DFSB+gYqT30GSN1gI6ROkDHSB2gY6T2RjoL0O2hY6QO0DFSB+gYqQN0jNRhe8FI7aEvGKkDdIzUATpG6gAdI3WALkC3h46ROkDHSB2gY6T2RrpgpA7QMVJ76CtG6gAdI3WAjpHaby8rRuoAXYBuDx0jdYCOkTpAx0gdoGOkDtAxUnvoG0bqAB0jtTfSDSN1gI6ROkAXoNtDx0gdoGOkDtsLRuoAHSN1gI6R2kPfMVIH6BipA3SM1AE6RuoAXYBuDx0jtTfSHSN1gI6ROkDHSB2gY6Tm0OcBIzXfXuYBI3WAjpE6QMdIHaAL0O2hY6QO0DFSB+gYqQN0jNQBOkZqb6QjRuoAHSN1gI6ROkDHSB2gC9DNt5cRI3WAjpE6QMdIHaBjpA7QMVJ76AUjdYCOkTpAx0gdoGOk9kZaBOj20DFSB+gYqQN0jNQBOkbqsL1gpPbQJ4zUATpG6gAdI3WAjpE6QBeg20PHSB2gY6QO0DFSeyOdMFIH6BipPXTBSB2gY6QO0DFS++1FMFIH6AJ0e+gYqQN0jNQBOkbqAB0jdYCOkdpDnzFSB+gYqb2RzhipA3SM1AG6AN0eOkbqAB0jddheMFIH6BipA3SM1B76gpE6QMdIHaBjpA7QMVIH6AJ0e+gYqb2RLhipA3SM1AE6RuoAHSO1h75ipPbby4qROkDHSB2gY6QO0AXo9tAxUgfoGKkDdIzUATpG6gAdI7U30g0jdYCOkTpAx0gdoGOkDtAF6Obby4aROkDHSB2gY6QO0DFSB+gYqT30HSN1gI6ROkDHSB2gY6T2RroL0O2hY6QO0DFSB+gYqQN0jNRhe8FIzaEvA0bqAB0jdYCOkTpAx0gdoAvQ7aFjpA7QMVIH6BipuZEuA0bqAB0jtYc+YqQO0DFSB+gYqf32MmKkDtAF6PbQMVIH6BipA3SM1AE6RuoAHSO1h14wUgfoGKm9kRaM1AE6RuoAXYBuDx0jdYCOkTpsLxipA3SM1AE6RmoPfcJIHaBjpA7QMVIH6BipA3QBuj10jNTeSCeM1AE6RuoAHSN1gI6R2kMXjNR+exGM1AE6RuoAHSN1gC5At4eOkTpAx0gdoGOkDtAxUgfoGKm9kc4YqQN0jNQBOkbqAB0jdYAuQDffXmaM1AE6RuoAHSN1gI6ROkDHSO2hLxipA3SM1AE6RuoAHSO1N9JFgG4PHSN1gI6ROkDHSB2gY6QO2wtGag99xUgdoGOkDtAxUgfoGKkDdAG6PXSM1AE6RuoAHSO1N9IVI3WAjpHaQ98wUgfoGKkDdIzUfnvZMFIH6AJ0e+gYqQN0jNQBOkbqAB0jdYCOkdpD3zFSB+gYqb2R7hipA3SM1AG6AN0eOkbqAB0jddheMFIH6BipA3SM1Bz6OmCkDtAxUgfoGKkDdIzUAboA3R46RmpupOuAkTpAx0gdoGOkDtAxUnvoI0Zqv72MGKkDdIzUATpG6gBdgG4PHSN1gI6ROkDHSB2gY6QO0DFSeyMtGKkDdIzUATpG6gAdI3WALkA3314KRuoAHSN1gI6ROkDHSB2gY6T20CeM1AE6RuoAHSN1gI6R2hvpJEC3h46ROkDHSB2gY6QO0DFSh+0FI7WHLhipA3SM1AE6RuoAHSN1gC5At4eOkTpAx0gdoGOk9kYqGKkDdIzUHvqMkTpAx0gdoGOk9tvLjJE6TLoA3R46RuoAHSN1gI6ROkDHSB22F4zUftIXjNQBOkbqAB0jdYCOkTpAF6Cbby8LRuoAHSN1gI6ROkDHSF8A/Y7v7X+uX6GnNdJpLzfoUsYK9FVuzN962eO12/IOcU1rmD+CuB+Du2/DI8STUxyH22vfflXciY9nLx73abyd4S4PZ7h+xJPWRUPEU4bhOOahTI/xnIBeD9D7/uW31ZpWcIMkKcuR5LL/VZJprTlGkuN88+sybvL1V6YQj2c8ZbvxKFPZvr/Q3hhMB47HE7xlmVbbO8wybRvQYJbzeHvxOD9q3S/ulmn7iNyxp21EWox9OSR0/rxR/Th2OpmMsW+0SE/Ffhz2ODykc5q77PtNc+Zh3r/PXeZdboexyPD44vd80tZIb2SOfB5n/Lyf3pftaOP2h7pnL6cX8XaDvsvwqZ8+QTIdV+Y07ev3F9s0lOOaH6bpyyq9pe2S+owzbaHUZ5xCnC3Fee8Tp3Hdv8aZtoPqM860NVSjcR5r8FTGyjtwZSk3oynLVHux3nt7W9qOi5l62UylLdCYqX+ZKbV3rre07Rwz9aqZ2tNWfxlmal6PmaqNSe2jbDsdJIOivCTtFKHMlPZM0cYyU9ozJcwUM6W8eNNLM1PaM0U5zkz9eXHlQ/Y7jTeD8tSgUGMzKE8NCt00g/LnxYp/dLINtNNMlf5UUWUzVT+fKrW/rtkGem8G0HUAKckZQNcBFAaQAfz5AGr9yds2UL8zgK4DSFff7wCu05HiuvytrdLVMyhPDQpdPYOivadT6zNTyjM1UuozU9ozRaXPTCkb2khLz0xpzxTFe1MzVVY5ZmqrNUk/+RO+yp9bbaMwKAzKPy9W+zOGbaTzZqa0Z4oam5nSnikab2bqfaa0/jRmGynHmSntmaIcZ6b+vPj7P47YCo03g/LUoFBjMyhPDQrdNIPy58WafxhTaKeZKv2pEqaKqfrxVOl9OKDQezOArgNISc4Aug4gjToD+IsBVPvcS6F+ZwBdB5CuvuMBdHks6DZR6zNT2jPFOwDM1PtMqb1PPfFmATOlPVO8VdDvTGn+VfIkDAqD8syg0NIzKMq950TxzkxpzxRdOjOlPVPU48zUf9dtvCcab2ZKeaYkbeO9DLeaRZZ1rM3UtN9+9ijlftzbfHogkxwHIvcBfGt2zn70NpTbj94ekp/m5SOitAXyCyOa7yXbvJZKRKUsx2GXdfgU0cmBrNutkxvXvZwEmra9bTTQ6hWatjrt9QoVAu0r0LRVZK+Bpu0Bew00bQnXa6BpG7BeA01bP3WqLTPdT19X6ExT1NkVSlPU2RVKU9RZoEKgfQVKU9TZPZSmqLMrlKaos0BpijoLlKaor0AXmqK+lqKFpqizK5SmqLNAaYo6C1QItK97KE1RZ1coTVFnVyhNUWdXKE1RZ1coTVFfV+hKU9RZoDRFnQVKU9TXPXSlKersChUC7esKpSnq7AqlKersCqUp6uwKpSnqLFCaor4C3WiK+rqHbjRFnV2hNEWdBUpT1NmvXCHQvq5QmqLOrlCaos6uUJqizq5QmqLOrlCaor4C3WmKOguUpqizQGmKOguUpqivLXcXAu3rCqUp6ixQmqLOAqUp6uweSlPU2RVKU9TVFboPNEVdXaH7QFPUWaA0RZ0FSlPUWaBCoH0tRTRFnV2hNEWdXaE0RZ1doTRFnQVKU9TXr9yRpqivK3SkKeosUJqizgKlKeosUCHQvgKlKeosUJqizgKlKeosUJqizooFmqK+rtBCU9RZoDRFff3KLTRFnV2hNEWdBSoE2legNEWd3UNpijq7QmmKOrtCaYo6u0JpivoKdKIp6utX7kRT1NkVSlPU2RVKU9TZFSoE2tcVSlPU2RVKU9RZoDRFnQVKU9RZoDRFfQUqNEV9bblCU9TZFUpT1FmgNEWd/coVAu3rCqUp6ixQmqLOAqUp6ixQmqLOAqUp6ivQmaaoL22ZaYo6u0JpijoLlKaos0CFQPsKlKaos6WIpqizK5SmqLNAaYo6+5VLU9TXFbrQFPV1hS40RZ1doTRFnQVKU9TZr1wh0L6uUJqizq5QmqLOrlCaos4CpSnq7FcuTVFfV+hKU9TXFbrSFHV2hdIUdRYoTVFnv3KFQPu6QmmKOguUpqizQGmKOguUpqizQGmK+gp0oynqLFCaor48dKMp6uwKpSnq7AoVAu3rCqUp6ixQmqLOAqUp6ixQmqLOAqUp6ivQnaaos0Bpivry0J2mqLMrlKaos0CFQPv6lUtT1NkVSlPUWaA0RZ39yqUp6uwKpSnq6QqdhoGmqKcr9C1QmqLOAqUp6ixQmqLOAhUC7StQmqLOtlyaos6uUJqizgKlKersVy5NUV9X6EhT1NcVOtIUdXaF0hR1doXSFHV2hQqB9hUoTVFnv3Jpijq7QmmKOguUpqizQGmK+rqHFpqivq7QQlPUWaA0RZ39yqUp6uwKFQLtK1Caos4CpSnqLFCaos4CpSnqLFCaor60ZaIp6usKnWiKOrtCaYo6u0JpijoLVAi0r0Bpijq7h9IUdXaF0hR1doXSFHV2hdIU9XWFCk1RX1eo0BR1doXSFHV2hdIUdXaFCoH2dYXSFHUWKE1RZ79yaYo6u0JpijoLlKaor0BnmqLOAqUp6ixQmqK+ttyZpqizK1QItK9AaYo6C5SmqLN7KE1RZ1coTVFngdIU9RXoQlPUWaA0RZ0FSlPU15a70BR1doUKgfZ1hdIUdXaF0hR1doXSFHV2hdIUdXaF0hT1dYWuNEWdBUpT1FmgNEV93UNXmqLOrlAh0L6uUJqizq5QmqLOAqUp6uxXLk1RZ1coTVFfV+hGU9TXFbrRFHV2hdIUdXaF0hR1FqgQaF+B0hR1dg+lKersCqUp6ixQmqLOfuXSFPV1he40RX1doTtNUWdXKE1RZ1coTVFnV6gQaF+B0hR1FihNUWeB0hR1FihNUWdbLk1RV1foONAUdRYoTVFngdIUdXUPHQeaos6uUCHQvgKlKeosUJqizgKlKepsKaIp6uwKpSnqK9CRpqivX7kjTVFnVyhNUWeB0hR1FqgQaF+B0hR1FihNUWdbLk1RZ1coTVFnVyhNUV9XaKEp6usKLTRFnV2hNEWdXaE0RZ1doUKgfV2hNEWdXaE0RZ0FSlPUWaA0RZ0FSlPUV6ATTVFfW+5EU9TZFUpT1NkVSlPU2RUqBNrXFUpT1NkVSlPU2RVKU9TZFUpT1NkVSlPU1xUqNEWdBUpT1NevXKEp6uwKpSnqLFAh0L5+5dIUdXaF0hR1doXSFHV2hdIUdRYoTVFfgc40RX3dQ2eaos6uUJqizgKlKeosUCHQvu6hNEWdXaE0RZ1doTRFnV2hNEWdXaE0RX1doQtNUV9X6EJT1NkVSlPU2RVKU+Qe6LYdge7TSURCRJEiWk8ios3xjkjKchz2dHbnop8JHxGNS/iI6FDCR0QrEj2ilZ4jfEQ0F+EjoosIHxHtQviIhIiiR0S7ED4i2oXwEdEuhI+IdiF8RLQL0SPaaBfCR0S7ED4i2oXwEdEuhI9IiCh6RLQL4SOiXQgfEe1C+IhoF8JHRLsQPaKddiF8RLQL7hEt43HYy8kHhnfahfAR0S6Ej0iIKHpEtAvuER38imxyEhHtQviIaBfCL920C+Ejol0IHlEZaBfCR0S7ED4i2oXwEdEuhI9IiCh6RLQL4SOiXQgfEe1C+IhoF8JHRLsQPaKRdiF8RLQL4SOiXQgfEe1C+IiEiKJHRLsQPiLahfAR0S6Ej4h2IXxEtAvRIyq0C+Ejol0IHxHtQvDPdJdCuxA+IiGi6BHRLoSPiHYh+F9GlEK7ED4i2oXwSzftQvSIJtqF8BHRLoSPiHYhfES0C+EjEiKKHhHtQviIaBfCR0S7ED4i2oXwEdEuRI9IaBfCR0S7ED4i2oXwEdEuhI9IiCh6RLQL4SOiXQgfEe1C+IhoF8JHRLsQPaKZdiF8RLQL4SOiXYj+geGZdiF8REJE0SOiXQgfEe1C9I/dz7QL4SOiXQi/dNMuRI9ooV0IHxHtQviIaBfCR0S7ED4iIaLoEdEuhI+IdiF8RLQL4SOiXQgfEe1C9IhW2oXwEdEuhI+IdiF8RLQL4SMSIooeEe1C+IhoF8JHRLsQPiLahfAR0S5Ej2ijXQgfEe1C9E+jbrQL4SOiXQgfkRBR9IhoF6J/pnujXQgfEe1C+KWbdiF8RLQL0SPaaRfCR0S7ED4i2oXwEdEuhI9IiCh6RLQL4SOiXQgfEe1C+IhoF8JHRLsQPKJpoF0IHxHtQviIaBfCR0S7ED4iIaLoEdEuhI+IdiF8RLQL4SOiXQgfEe1C8I86TiPtQviIaBfCR0S7ED4i2oXgHxieRiGi6BHRLkRfukfahfAR0S6Ej4h2IXxEtAvRIyq0C+Ejol0IHxHtQviIaBfCRyREFD0i2oXwEdEuhI+IdiF8RLQL4SOiXYge0US7ED4i2oXwEdEuhI+IdiF8REJE0SOiXQgfEe1C9M/RTbQL4SOiXQgfEe1C9IiEdiH6p1GFdiF8RLQL0ZduoV0IH5EQUfSIaBfCR0S7ED4i2oXwEdEuhI+IdiF6RDPtQviIaBfCR0S7ED4i2oXwEQkRRY+IdiF8RLQL4SOiXQgfEe1C+IhoF6JHtNAuhI+IdiF8RLQL0T+ktdAuhI9IiCh6RLQL4SOiXYj+UceFdiF8RLQL4Zdu2oXoEa20C+Ejol0IHxHtQviIaBfCRyREFD0i2oXwEdEuhI+IdiF8RLQL4SOiXYge0Ua7ED4i2oXwEdEuhI+IdiF8REJE0SOiXQgfEe1C+IhoF6J/AmijXQgfEe1C9Ih22oXwEdEuRP8c3U67ED4i2oXoS/cuRBQ9ItqF8BHRLoSPiHYhfES0C+Ejol0IHpEMtAvhI6JdCB8R7UL4iGgXwkckRBQ9ItqF8BHRLoSPiHYhfES0C+Ejol2IHtFIuxA+ItqF4B8vkZF2IXxEtAvhIxIiih4R7ULwD2nJSLsQPiLahfBLN+1C+IhoF6JHVGgXwkdEuxA+ItqF8BHRLoSPSIgoekS0C+Ejol0IHxHtQviIaBfCR0S7ED2iiXYhfES0C+Ejol0IHxHtQviIhIiCf3Zhol0IHxHtQviIaBfCR0S7EP0TQBPtQvSIhHYh+tIttAvhI6JdCB8R7UL4iISIokdEuxA+ItqF8BHRLoSPiHYhfES0C9EjmmkXwkdEuxA+ItqF8BHRLoSPSIgoekS0C+Ejol2I/sb4TLsQPiLahfAR0S5Ej2ihXYj+8ZKFdiF8RLQL0ZfuhXYhfERCRNEjol0IHxHtQviIaBfCR0S7ED4i2oXoEa20C+Ejol0IHxHtQviIaBfCRyREFD0i2oXwEdEuhI+IdiH6u64r7UL4iGgXoke00S6Ej4h2IfpnFzbahfAR0S5EX7o3IaLoEdEuhI+IdiF8RLQL4SOiXQgfEe1C9Ih22oXwEdEuhI+IdiF8RLQL4SMSIooeEe1C+IhoF8JHRLsQ/S29nXYhfES0C8EjmgfahfAR0S4Ef2N8HmgXwkdEuxB86Z4HIaLoEdEuhI+IdiF8RLQL4SOiXQgfEe1C9IhG2oXwEdEuhI+IdiF8RLQL4SMSIooeEe1C+IhoF6K/XzTSLoSPiHYhfES0C9EjKrQL0d91LbQL4SOiXYi+dBfahfARCRFFj4h2IXxEtAvhI6JdCB8R7UL4iGgXokc00S6Ej4h2IXxEtAvhI6JdCB+REFHwNyMm2oXwEdEuhI+IdiF8RLQL0d/Sm2gXokcktAvRl26hXQgfEe1C+IhoF8JHJEQUPSLahfAR0S6Ej4h2IXxEtAvhI6JdiB7RTLsQPiLahehN90y7ED4i2oXwEQkRRY+IdiH6+0Uz7UL4iGgXwi/dtAvhI6JdiB7RQrsQPiLahfAR0S6Ej4h2IXxEQkTRI6JdCB8R7UL4iGgXoteoC+1C+IhoF6JHtNIuhI+IdiH6mxEr7UL4iGgXoi/dqxBR9IhoF8JHRLsQPiLahfAR0S6Ej4h2IXpEG+1C+IhoF8JHRLsQvaPbaBfCRyREFD0i2oXwEdEuRG+6N9qF8BHRLoRfumkXoke00y6Ej4h2IXxEtAvhI6JdCB+REFH0iGgXwkdEuxC9ANppF8JHRLsQPiLaheARLQPtQvAadRloF8JHRLsQfOleBtqF8BEJEUWPiHYhfES0C+Ejol0IHxHtQviIaBeitwsj7UL4iGgXwkdEuxA+ItqF6B3dKEQUPSLahehL90i7ED4i2oXwEdEuhI+IdiF6RIV2IXxEtAvR1bXQLoSPiHYhfERCRNEjol2IXgAV2oXwEdEuhF+6aRfCR0S7ED2iiXYhfES0C+Ejol2I7kUT7UL4iISIokdEuxA+ItqF6O3CRLsQPiLahfBLN+1C9IiEdiF8RLQL4SOiXYi+dAvtQviIhIiiR0S7ED4i2oXo6iq0C+Ejol0Iv3TTLkSPaKZdCB8R7UL0jW6mXQgfEe1C+IiEiKJHRLsQ3Ytm2oXwEdEuhF+6aRfCR0S7EH1dWGgXwkdEuxA+ItqF8BHRLkRfuhchougR0S5EX7oX2oXw9yLahfAR0S6Ej4h2IXpEK+1C9I1upV0IHxHtQvhfdLQL4SMSIooeEe1C+IhoF8KvC7QL4SOiXdCPaJuPYnRbhkpE+7TJx6t3Ge6/6E6Pepq2g9+0P7x4PXvxUG6nOA3T9Pji9+ypLdJmv9GH5M2eoiVv9jQ4/WY/ztvtxeNDikf2VEN5sxey7zf7/ci+jNP3Ly5LOXqVZaq8eNyn24vHXbavU0VNxlT9eKrKMByoh1J58bwe87Hvj6f3PoCUgAyg6wBScTKArgNIgcsA/mIA5TjDYdn/agBpkRlAzwHcqbIZwJ8P4L0wKePDO6M3td0pyZkq/amifmeq9KeKYp+p0p8qYaqYqh9PVTkOo0xl+/7Fb9FNR4qPudxGkPcXGEHnEeQdBkbwxSM4j7cXj7OUv+pCeDuCaW1nWnnvgmltZ1p5o4NpffW0Hn/09ibn8hfTug68K8K0tjOtvNvCtL5P6/3PG5fa+8J6H6NZB96YYQBdB5D3cBjAXwyg1sdo1kEYQAbQcwB5s4cB/HPQ63REvi5/9/7NOvD+DVOlP1W8z8JU/Xyq1MrodeCtEwbQdQB5N4QB9BzAkTc4GMBfDKDaexYj71kwgK4DyHsW/Q5gWeUYwK1Wwvn87fk68p4FA+g6gMIAMoA/H0C19yxG3rNgAF0HkLc3GMD3AfzBu7aV5/qtI29vMFU/nirNxY63NxhA1wHk7Q0G0HMAC29vMIC/GEA1syi8vcEAug4gb28wgD8fwO+farQW3rNgqvSnSpgqpkp9qnh3gan6+VQpPv5qLby/wAg6jyBvRjCCLx5BvY8lF965YFrbmVbe5mBam5nWifdEmNZXT6vax/Mn3kBhWtuZVt5tYVr/HLTmcxIm3m1hqvSnSpgqpurHU6UoIrwxwwC6DiBvyzCArgPImzIM4C8GUM9XeZ+FAXQdQN46ecEAHiP19j+3ygCuRz7rttxJv8cjvFcQOh7K8dDx0Abrx7NPx4Hs8/wpnnfolKUO0AXo9tDpz56Dfvwx1SgPDxU5hb7J7Zf/tlXykXmX4yjkvuePy0c8tEuh48navczTePt7iVmmuRLPNOzjYZFL7dVl2Y4jWce99upxvP/lhqyVV2/7bU728SHOvXzkmbXKaDXPfT/enhyG7VOgX1+87MPtsJd9rNQkW7n/mihL+VI6SNbSgVH56ajMWQsQRuXHo5K1jGFUfjwqWYshRuXHo5K1zmJUfjwqwqgwKs+NStbqkFH58ahkrTEZlR+PCpUqo/LkqNDWMipPjgptLaPy3KgstLWMypOjQlvLqDw5KrS1jMqTo0Jby6g8OSrCqDAqz40KbS2j8uSo0NYyKk+OCm0to/LkqNDWMipPjgptLaPy3KistLWMypOjQlvLqDw5KrS1jMqTo0Jby6g8OSrCqDAqz40KbS2j8uSo0NYyKk+OCm0to/LkqNDWMipPjgptLaPy3KhstLWMypOjQlvLqDw5KrS1jMqTo0Jb2/GorEVuP3otj+Hc0hfST5w+nWrm9KlJu07/wL1O40n6NJ+Z06fMzJw+/WTi9Hcqx8zp0yIm3vl3isHM6dP1ZU5fSD/xfZ+uL3P6dH2Z06fry5w+XV/m9On68qa/DXR9mdOn68vr+9tA15c5fbq+zOkL6SdOn64vc/p0fZl3frq+zOnT9WVOn64vcfojXV/m9On6MqdP15c5fbq+zOkL6SdOn64vcdc30vVlTp+uL3P6dH2Z06frS5x+oetLvPMXur7M6dP1ZU6fri9z+kL6idOn68ucPl1f5vTp+jKnT9eXOX26vsRd30TXlzl9ur7M6dP1ZU6fri9z+kL6eXf+ia4vc/p0fZnTp+vLnD5dX+b06foSpy90fZnTp+vLnD5dX+b06foSd30ipJ84fbq+zOnT9WVOn64vc/p0fZl3frq+xOnPdH2Z06fry5w+XV/m9On6MqcvpJ84fbq+zOnT9WVOn64vcdc30/VlTp+uL3H6C11f5vTp+jKnT9eXeOdf6Poypy+knzh9ur7M6dP1ZU6fri9z+nR9mdOn60uc/krXlzl9ur7EXd9K15c5fbq+zOkL6SdOn64vc/p0fZl3frq+zOnT9WVOn64vcfobXV/m9On6MqdP15c5fbq+zOkL6SdOn64vcde30fVlTp+uL3P6dH2Z06frS5z+TteXeOff6foyp0/Xlzl9ur7M6QvpJ06fri9z+nR9mdOn68ucPl1f5vTp+vJ2fftA15c5fbq+zOnT9WVOn64vc/pC+ml3/n2g68ucPl1f5vTp+jKnT9eXOX26vsTpj3R9mdOn68ucPl1f5vTp+hJ3faOQfuL06foyp0/Xlzl9ur7M6dP1Zd756foSp1/o+jKnT9eXOX26vszp0/VlTl9IP3H6dH2Z06fry5w+XV/irq/Q9WVOn64vcfoTXV/m9On6MqdP15d455/o+jKnL6SfOH26vszp0/VlTp+uL3P6dH2Z06frS5y+0PVlTp+uL3HXJ3R9mdOn68ucvpB+4vTp+jKnT9eXeeen68ucPl1f5vTp+hKnP9P1ZU6fri9z+nR9mdOn68ucvpB+4vTp+hJ3fTNdX+b06foyp0/Xlzl9ur7E6S90fYl3/oWuL3P6dH2Z06fry5y+kH7i9On6MqdP15c5fbq+zOnT9WVOn64vcde30vVlTp+uL3P6dH2Z06fry5y+kH7enX+l68ucPl1f5vTp+jKnT9eXOX26vsTpb3R9mdOn68ucPl1f5vTp+hJ3fZuQfuL06foyp0/Xlzl9ur7M6dP1Zd756foSp7/T9WVOn64vc/p0fZnTp+vLnL6QfuL06foyp0/Xlzl9ur7EXd9O15c5fbq+tOnLMND1ZU6fri9z+nR9aXf+t/Tp+jKnL6SfOH26vszp0/VlTp+uL3P6dH2Z06frS5z+SNeXOX26vsRd30jXlzl9ur7M6QvpJ06fri9z+nR9mXd+ur7M6dP1ZU6fri9x+oWuL3P6dH2Z06fry5w+XV/m9IX0E6dP15e46yt0fZnTp+vLnD5dX+b06foSpz/R9SXe+Se6vszp0/VlTp+uL3P6QvqJ06fry5w+XV/m9On6MqdP15c5fbq+xF2f0PVlTp+uL3P6dH2Z06fry5y+kH7enV/o+jKnT9eXOX26vszp0/VlTp+uL3H6M11f5vTp+jKnT9eXOX26vsRd3yyknzh9ur7M6dP1ZU6fri9z+nR9mXd+ur7E6S90fZnTp+vLnD5dX+b06foypy+knzh9ur7M6dP1ZU6fri9x17fQ9WVOn64vcforXV/m9On6MqdP15d451/p+jKnL6SfOH26vszp0/VlTp+uL3P6dH2Z06frS5z+RteXOX26vsRd30bXlzl9ur7M6QvpJ06fri9z+nR9mXd+ur7M6dP1ZU6fri9x+jtdX+b06foyp0/Xlzl9ur7M6QvpJ06fri9x17fT9WVOn64vc/p0fZnTp+vLm/7bTyD9tDv/OND1ZU6fri9z+nR9mdMX0k+cPl1f5vTp+jKnT9eXOX26vszp0/Ul7vpGur7M6dP1ZU6fri9z+nR9mdMX0s+78490fZnTp+vLnD5dX+b06foyp0/Xlzj9QteXOX26vszp0/VlTp+uL3HXV4T0E6dP15c5fbq+zOnT9WVOn64v885P15c4/YmuL3P6dH2Z06fry5w+XV/m9IX0E6dP15c5fbq+zOnT9SXu+ia6vszp0/UlTl/o+jKnT9eXOX26vsQ7v9D1ZU5fSD9x+nR9mdOn68ucPl1f5vTp+jKnT9eXOP2Zri9z+nR9ibu+ma4vc/p0fZnTF9JPnD5dX+b06foy7/x0fZnTp+vLnD5dX+L0F7q+zOnT9WVOn64vc/p0fZnTF9JPnD5dX+Kub6Hry5w+XV/m9On6MqdP15c4/ZWuL/HOv9L1ZU6fri9z+nR9mdMX0k+cPl1f5vTp+jKnT9eXOX26vszp0/Ul7vo2ur7M6dP1ZU6fri9z+nR9mdMX0s+78290fZmvfbq+zOnT9WVOn64vc/p0fYnT3+n6Eu/8O11f5mufri9z+nR9mdMX0k+cPl1f5vTp+jLv/HR9mdOn68ucPl1f3vTLQNfXc/r3HN/+5/o1fbq+ttIfhzIc8ctQif9tq7/97Ldf81Pl1fu0ycerdxk+DcsJkmk7opz2hxevp/zKenvxME2PL34fQ0pHxjDAGNJ+MoYBxlAYQ8bw9WM4zrfjmMaHgTrGkD6YMQwwhhTTjKHFGO7HGJZx+v7FZSk32GWZai8ehoP1UCovntdjVPf9q65T03MtcC28Xwu8acG10Pa1IMtxLSz7X10LvIXDtcC18OdaGHlDi2sh3LUwr8e1UBvvcZ/G4wxl+yLEI+/ZMeAtD7iiBIy8cci1wLXwfi3w7iXXAtfC+7UgXAtcC01fC3pCzPu4XAtcC+/XAm8mcy00fS3cPy1Rxk2+lkO8Q8yAdz3gvO3LgHc94LyXy4A3PeDlOIwyle37F79N0fHnbNPjiHxcDYV3c7kauBpuVwNv/XI15Lka5vH24nGW8je9T+F9Yi4cLpxfXDi8qcyFw4XziwtHuHC4cPJcOMvxmdX5c6n14wuHt6u5cLhwfnHh8N42F060C2edjulbl79tv3hvmwHvesB5b5sBb3rAFf2Zt8G5FrgW/lwLE2+Ccy1wLbxfC7wFzrXQ9rWg1vhMvKvNtcC18H4t8EY114LBtVBWOfhttXcCfvIIpNpjXyZhwBnwhgdc8c/7J94j5lrgWni/Fnjbl2uBa+H9WuAdYq6Ftq8FtUddTLyZzLXAtfB+LfBmMtdC09dC5aEBwjvEDHjXA87bvgx41wPOe7kMeNMDrvmgC+HdXK4Grobb1SBcDVwNaa4GvQ+LCu8Tc+Fw4fziwuFNZS4cLpxfXDi8A82Fk+jCUfv8tvB2NRcOF84vLhze2+bCCXfh+Hzt28zb4FwLXAvv1wLvmHMttH0tqH3+b+bNda4FroX3a4G31rkWol0Lmk/Rm4UBZ8B7HnDe1WbAmx5wvffbZt6o5lrgWni/FnjvmWuBa+H9WuDtZK6Ftq8FtXeIZ94h5lrgWvhzLSy8Q9zYtTBtD2XI/mm63xPlfc7eEuXdupYTLSeJ8p5Tb4kKiXaWKO8q9JYo3XhvidLw9pYoPaV7otP9rzwmmT69+j0j+rPwGa30OvEzoqmJnxHdS/yMaFPiZyRkFD4jGo/4GdFhxM+IViJ+RvQM8TOiZwif0UbPED8jeob4GdEzxM+IniF+RkJG4TOiZ4ifET1D/IzoGeJnRM8QPyN6hvAZ7fQM8TOiZ4ifET1D/IzoGeJnJGQUPiN6hvgZ0TPEz4ieIX5G9AzxM6JniJ7RNNAzxM+IniF+RvQM8TOiZ4ifkZBR+IzoGeJnRM8QPyN6hvgZ0TPEz4ieIXxGIz1D/IzoGeJnRM8QPyN6hvgZCRmFz4ieIX5G9AzxM6JniJ8RPUP8jOgZwmdU6BniZ0TPED8jeob4GdEzxM9IyCh8RvQM8TOiZ3DPSKbpOO5tqrx6kfLx4mW5f0vC9A/5rz/5/p19ZRm3T69+T58GI3P6dCOZ06d1SZz+RJ+TOX2aoszp00FlTp92K3P6QvqJ06eRy5w+XV/H6a/z8f2p2zhXXr3Px6v3eSsns0IzyKw8Oyv0iMzKx6xM+432LtVXj/Nw4H7738tyMlu0lMzWi2ZL6ECZrSfvcUJjyqw8Oyv0q8zKq+5ZtLfM1qtmS5gtZuvJexxNMrPy7KzQOzMrH7NSpttR72XeT2aF3plZefb3Cr0zs/LsrNAjMysv8qaZHpnZetVs0TszW0/e42Z6Z2bl2VmhR2ZWXnXPEmaL2XrRbNE7M1vP3uPonZmVZ2eF3plZ+ZiV2nsUM70zs/Ls7xV6Z2blyVlZ6JGZlRd500KPzGy9arbonZmtZ+9x9M7MyrOzIswKs/KiexY9MrP1qtmid2a2nr3H0TszK8/OCr0zs/IxK7X3KBZ6Z2blyd8rK70zs/LsrNAjMysv8qaVHpnZetVs0TszW8/e44RZYVaenBV6ZGblVfcsemRm61WzRe/MbD17j6N3ZlaenRV6Z2blY1Zq71Fs9M7MypO/VzZ6Z2bl2VmhR2ZWXuRNGz0ys/Wq2RJmi9l68h5H78ysPDsr9MjMyqvuWfTIzNarZovemdl69h5H78ysPDkrO70zs/IxK7X3KHZ6Z2bl2d8r9M7MyrOzQo/MrLzIm3ZhtpitF80WvTOz9ew9jt6ZWXl2VuiRmZVX3bPokZmtV80WvTOz9dw9TgZ6Z2bl2Vmhd2ZWPmal8h6FDPTOzMqzv1fonZmVZ2dFmBVm5SXeJAM9MrP1qtmid2a2nr3H0TszK8/OCj0ys/KqexY9MrP1otka6Z2ZrSfvcSO9M7Py7KzQOzMrH7NSe49ipHdmVp79vSLMCrPy5KzQIzMrr/ImemRm61WzRe/MbD17j6N3ZlaenRV6ZGblRfesQo/MbL1qtuidma0n73GF3plZeXZW6J2ZlY9Zqb1HUYRZYVaenBV6545nZS9y+8n7OtVmZV9vrx6HYar98HGchmMZHqdxOxkuimeG62XDRfPMcL1suKiqGa6XDRfdNsP1quGaKLcZrpcNF+02w/Wy4aIO73e4ZFhuRy1jmU7Sp+DOnL6QfuL0KaEzp09LnDl9atzM6dOzZk6fIjRx+kJTmTl9qsTM6dP1ZU6frq/j9MdpuaVfhrHy6nHdlls447pPQ+3147Adr3/7/04+0ijCdDFdL5suukqm63XTRRfKdKlMV5lPpouulen67XRVP78hdLlM1+umi66Y6XrZdM100UzX66aLrpvpet100aUzXbfp2vcbknEbltqHuMe3A19vr38bk+Fkuujqma7fTte8TMd0zfvZdAnTxXS9bLro6pmu100XXT3T9brpoqtnul43XXT1TNfrpouunul62XQtdPVM1+umi66e6fqgvZX7My62aZCTaaF7Z1qenxa6dKblNi0y3aflrUs6mRZhWvqdljKWY1qkVKdlHQ/c2zqPJ9NC1820PD8tdNdMy/PTQhfNtDw/LXTLTMvz00JXzLQ8PS0r3S/T8vy00OUyLc9PC10u0/L8tNDlMi3PT4swLUzLx7Rscm/+38al8vplH25Mln28H8sp7q0cP3srS3l88fsc0hIzhxHmkP6ZOYwwhzTbzGGEOaQzZw4jzCFtPHMYYA43en7mMMIc8g4CcxhhDnlvgjmMMIe868EcRphDYQ6ZwwBzyPspzGGEOeT9FOYwwhzyfgpzGGEOeT+FOYwwh7yfwhwGmMOd91OYwwhzyPspzGGEOeT9FOYwwhzyfgpzGGEOhTlkDgPMIe+nMIcR5pD3U5jDCHPI+ynMYYQ55P0U5jDCHPJ+CnPoP4fzwPspzGGEOeT9FOYwwhzyfgpzGGEOeT+FOYwwh8IcMocB5pD3U5jDCHPI+ynMYYQ55P0U5jDCHPJ+CnMYYQ55P4U5DDCHI++nMIcR5pD3U5jDCHPI+ynMYYQ55P0U5jDCHApzyBwGmEPeT2EOI8wh76cwhxHmkPdTmMMIc8j7KcxhhDnk/RTmMMAcFt5PYQ4jzCHvpzCHEeYw7fspstyOZH5r8z+l/04ma8O/ruV2JOu6ygkZSUpmW4bbYW9LGU/IZG1B62Sy9nJ1MlmbojqZrN1FnUxWm66SmbL6XZ1MVuOok8m6A9fJZN2B62QEMhdk2IGvyLADX5FhB74iww58RYYd+IKMsANfkWEHviLDDnxFhh34ioxA5oIMO/AVGXbgKzLswFdksu7A41iOQxnHqZy8SylZt+An2MxZ9+Bn2GTdhJ9hk3UXfoZN1m34GTYCm0s2WTfiZ9hk3YmfYZN1K36GDXvxNRv24ks2C3vxNRv24ms27MXXbNiLr9kIbC7ZsBdfs2EvvmbDXnzNhr34mg178SWblb34mg178TUb9uJrNuzF12wENpds2Iuv2bAXX7NhL75mw158zYa9+JLNxl58zYa9+JoNe/E1G/biazYCm0s27MXXbNiLr9mwF1+zYS++ZsNefMlmZy++ZsNefM2GvfiaDXvxNRuBzSUb9uJrNuzF12zYi6/ZsBdfs2EvvmKzDOzF12zYi6/ZsBdfs2EvvmYjsLlkw158zYa9+JoNe/E1G/biazbsxZdsRvbiazbsxdds2Iuv2bAXX7MR2FyyYS++ZsNefM2GvfiaDXvxNRv24ks2ab+T8Rk27MXXbNiLr9mwF1+zEdhcsmEvvmbDXnzNhr34mg178TUb9uJLNmm/y+4ZNuzF12zYi6/ZsBdfsxHYXLJhL75mw158zYa9+JoNe/E1G/biSzZpv9/uGTbsxdds2Iuv2bAXX7MR2FyyYS++ZsNefM2GvfiaDXvxNRv24ks2fN/dN2zYi6/ZsBdfs2EvvmYjsLlkw158zYa9+JoNe/E1G/biazbsxZds+L67b9iwF1+zYS++ZsNefM1GYHPJhr34mg178TUb9uJrNuzF12zYiy/Z8H1337BhL75mw158zYa9+JqNwOaSDXvxNRv24ms27MXXbNiLr9mwF1+y4fvuvmHDXnzNhr34mg178TUbgc0lG/biazbsxdds2Iuv2bAXX7NhL75kw/fdfcOGvfiaDXvxNRv24ms2AptLNuzF12zYi6/ZsBdfs2EvvmbDXnzFZuX77r5hw158zYa9+JoNe/E1G4HNJRv24ms27MXXbNiLr9mwF1+zYS++ZMP33X3Dhr34mg178TUb9uJrNgKbSzbsxdds2Iuv2bAXX7NhL75mw158yYbvu/uGDXvxNRv24ms27MXXbAQ2l2zYi6/ZsBdfs2EvvmbDXnzNhr34kg3fd/cNG/biazbsxdds2Iuv2QhsLtmwF1+zYS++ZsNefM2GvfiaDXvxJRu+7+4bNuzF12zYi6/ZsBdfsxHYXLJhL75mw158zYa9+JoNe/E1G/biSzZ83903bNiLr9mwF1+zYS++ZiOwuWTDXnzNhr34mg178TUb9uJrNuzFl2z4vrtv2LAXX7NhL75mw158zUZgc8mGvfiaDXvxNRv24ms27MXXbNiLL9nwfXffsGEvvmbDXnzNhr34mo3A5pINe/E1G/biazbsxdds2Iuv2bAXX7Lh++6+YcNefM2GvfiaDXvxNRuBzSUb9uJrNuzF12zYi6/ZsBdfs2EvvmTD9919w4a9+JoNe/E1G/biazYCm0s27MXXbNiLr9mwF1+zYS++ZsNefMVm4/vuvmHDXnzNhr34mg178TUb6YfNPGy3g56rP3teb0e9jI9c9g8uHe3EP+KylPHGZZNPXL6+dlsH+Xjxtq7z/dXz9EHReHteFjkobnuN4jRv24FxGe7Hv0xnGEeZl9thj7J9evn72a5Zzvbt//G///d//y//5d//7//tv/y3/+M//c9//2//9X/88x8P//z/xotnFO/DbbKmYVnuhzv8+VU0Xjy9t/JfXTzXtvZfjb/6r8qv/qvpV/+V/Oq/mn/1Xy2/+q/WX/1Xv5qN6VezIb+aDfnVbMivZkN+NRvyq9mQX82G/Go25FezIb+aDfnVbMy/mo35V7Mx/2o25l/Nxvyr2Zh/NRvzr2Zj/tVszL+ajflXs7H8ajaWX83G8qvZWH41G8uvZmP51Wwsv5qN5VezsfxqNpZfzcb6q9lYfzUb669mY/3VbKy/mo31V7Ox/mo21l/Nxvqr2Vh/NRvbr2Zj+9VsbL+aje1Xs7H9aja2X83G9qvZ2H41G9uvZmP71Wycf95hGg7JmoZ9ffiv5P2/Gn/1X5Vf/VfTr/4r+dV/Nf/qvzqdjWk8SoiplP3Tf3WiwfNy+zfe7tjl4dVn0izboePTQ6bzR6arwvG8NU2349nGrXI887LORz+w3WureX4/oC3aAe2xDqicv73ieUBjtAMq0Q5oinZAEu2A5mgHtEQ7oGC/qctg/5t6lduNb14f3gV4O6CztwzG6XjLYB2/f/F2vBmxrQ83yWk/rZWn9WiV5/sPlnL24u2+Un166R+COwT/juA4QPAvCY4Q/EuCBYJ/SXCC4F8SFAj+JcEZgn9JcIHgXxJcIfiXBHGSvyWIk/wlwYKT/C1BnORvCeIkf0sQJ/lbggLBvySIk/wtQZzkbwniJH9LECf5W4I4yV8SnHCSvyWIk/wtQZzkbwniJH9LUCD4lwRxkr8l6OEk453g9j2UcTs+wTruj39uffqjR7n/dfa8lscf/edc10TnuiU61z3PuYrH7ux1rmOicy2JznVKdK6S6FznROeaaG+SRHuTJNqbJNHeNCfam+ZEe9OcaG+aE+1Nc6K9aU60N82J9qY50d40J9qb5kR705Job1oS7U1Lor1pSbQ3LYn2piXR3rQk2puWRHvTkmhvWhLtTWuivWlNtDetifamNdHetCbam9ZEe9OaaG9aE+1Na6K9aU20N22J9qYt0d60JdqbtkR705Zob9oS7U1bor1pS7Q3bYn2pi3R3rQn2pv2RHvTnmhv2hPtTXuivWlPtDftPe1Nb2dzfInmMA5VMqscZB6/AnQ7O5Ll+A7NpTz8ueMm7xh7WskcMfa07Tli7GmRdMM4DT3tqI4Ye1p/HTH2tFk7YuxpaXfEKGDUwNiTajhixGJUMGIxKhixGBWMWIwGxrEni3lb39YD4147kHFcy/HDx314+Onj+GrsPVlPQ9h7sqSGsPdkVQ1hF7B7YO/J2hrC3pPlNYS9JytsCHtPFtkQ9p6ssx3sBUt1wY6lumDHUl2wY6ku2CUv9jLMtyMZy59T+xZ7eYvp4+Vl3B6gbOvZq9fhePVa7p/tW96xJ7ZUT+yJLdUTe2JL9cSe2FI9sSe2VEfsU2JL9cSe2FI9sSe2VE/siS3VE7uA3QM7luqCHUt1wY6lumDPbKnTth3YRWrFb1mOYynLMt9fvZ99V+c0ltsPn8b58dXD2aun9TjyaZ8+vfpPTJmttp2YuvpOx45jymzNDcWU2bIbiimzlTcUkxBTCzFltv6GYsrcEjQUU+ZWoaGYaCGaiIkWooWYuvqG5I5jooVoIiZaiCZiooVoIiYhphZiooVoIiZaiCZiooVoIiZaiCZiooVoIaaFFqKJmGghmoiJFqKJmGghmohJiKmFmGghmoiJFqKJmGghmoiJFqKJmGghWohppYVoIiZaiCZiooVoIiZaiCZiEmJqISZaiCZiooVoIiZaiCZiooVoIiZaiBZi2mghmoiJFqKJmGghmoiJFqKJmISYWoiJFqKJmGghmoiJFqKJmGghmoiJFqKFmHZaiCZiooVoIiZaiCZiooVoIiYhphZiooVoIiZaiCZiooVoIiZaiCZiooVoICYZaCGaiIkWoomYaCGaiIkWoomYhJhaiIkWoomYaCGaiIkWoomYaCGaiIkWooWYRlqIJmKihWgiJlqIJmKihWgiJiGmFmKihWgiJlqIJmKihWgiJlqIJmKihWghpkIL0URMtBBNxEQL0URMtBBNxCTE1EJMtBBNxEQL0URMtBBNxEQL0URMtBAtxDTRQjQREy1EEzHRQjQREy1EEzEJMbUQEy1EEzHRQjQREy1EEzHRQjQREy1ECzEJLUQTMdFCvCimIvOBcKvFJPsR0zwM+9eYaCGaiIkWoomYhJhaiIkWoomYaCGaiIkWoomYaCGaiIkWooWYZlqIJmKihWgiJlqIJmKihWgiJiGmFmKihWgiJlqIJmKihWgiJlqIJmKihWghpoUWoomYaCGaiIkWoomYaCGaiEmIqYWYaCGaiIkWoomYaCGaiIkWoomYaCFaiGmlhWgiJlqIJmKihWgiJlqIJmISYmohJlqIJmKihWgiJlqIJmKihWgiJlqIFmLaaCGaiIkWoomYaCGaiIkWoomYhJhaiIkWoomYaCGaiIkWoomYaCGaiIkWooWYdlqIJmKihWgiJlqIJmKihWgiJiGmFmKihWgiJlqIJmKihWgiJlqIJmKihWggprf/GzG1EBMtRBMx0UI0ERMtRBMxCTG1EBMtRBMx0UI0ERMtRBMx0UI0ERMtRAsxjbQQTcREC9FETLQQTcREC9FETEJMLcREC9FETLQQTcREC9FETLQQTcREC9FCTIUWoomYaCGaiIkWoomYaCGaiEmIqYWYaCGaiIkWoomYaCGaiIkWoomYaCFaiGmihWgiJlqIJmKihWgiJlqIJmISYmohJlqIJmKihWgiJlqIJmKihWgiJlqIFmISWogmYqKFaCImWogmYqKFaCImIaYWYqKFaCImWogmYqKFaCImWogmYqKFaCGmmRaiiZhoIZqIiRaiiZhoIZqISYiphZhoIZqIiRaiiZhoIZqIiRaiiZhoIVqIaaGFaCImWogmYqKFaCImWogmYhJiaiEmWogmYqKFaCImWogmYsrcQizDeMS0Ph74aUxvP3I8oDzGdBHqNtxCXce99uoy7LdXl7J+evWfmDK3EO3EtGZuIRqKKXML0VBMmVuIhmLK3EI0FJMQUwsxZW4hGoopcwvRUEyZW4iGYqKFaCImWogWYtpoIZqIiRaiiZhoIULEJNN0e7VstbdUFikfL16We6TTchbOfn+zZng4jPMXL2W+AVzKVvvR47YcR/3P/5ZPr/8zXZQnTNfrpkuYLqbrZdNFVcV0vW66aNiYrtdNF8Ug0/W66aLPZLpeN13UsEzXy6Zrpz1mul43XZTeTNfrpouunul63XTR1TNdr5suYbqYrpdNF1090/W66aKrf9F0rSLHdMnnV/8BT43tBJ6G1wk85acL+GWgF3QCT2XmBJ42yQk8RYsTeAG8D3j03Ak85uoEHnN1Ao+5OoHHXH3Aj4nNdZrWW4c8TjKXCsrx7WCOqnfc1uF4/XIKfigH+FIeXvsHe2Jv9cSe2Fo9sSd2VhnW47hllLWC/W0F+Xj1Upb7azd5BymA1AGZ2Cl1QSZ2RF2QiZ1PF2Rih9MFmdjJVEGWxI6lCzKxNemCTOxBuiAxGyWQAkgdkJiNEkjMRglkZrNZZD9ALtUPNZdpvZEs0/7Q1m/bj0u3ktmDHLFntiY/7FNmx3LEntnIHLFn9jdH7JltzxG7gN0De2aTdMSe2TsdsWOpLtixVBfsWKoHdsFSXbBjqU9jl/F4ZIPI8An7H5SYpxpKbFINpYBSCyXWp4YSk1NDiZ2pocS41FBiUVooZ8xIDSW2o4YS21FDie2ooRRQaqHEdtRQYjtqKLEdNZTYjhpKbEcL5YLtqKHEdtRQYjtqKLEdNZQCSi2U2I4aSmxHDSW2o4YS21FDie1ooVyxHTWU2I4aSmxHDSW2o4ZSQKmFEttRQ4ntqKHEdtRQYjtqKLEdLZQbtqOGEttRQ4ntqKHEdtRQCii1UGI7aiixHTWU2I4aSmxHDSW2o4Vyx3bUUGI7aiixHTWU2I4aSgGlFkpsRw0ltqOGEttRQ4ntqKHEdpRQrgO2o4YS21FDie2oocR21FAKKLVQYjtqKLEdNZTYjhpKbEcNJbajhXLEdtRQYjtqKLEdNZTYjhpKAaUWSmxHDSW2o4YS21FDie2oocR2tFAWbEcNJbajhhLbUUOJ7aihFFBqocR21FBiO2oosR01lNiOGkpsRwvlhO2oocR21FBiO2oosR01lAJKLZRd2c4kB8ppXWqvXrYbyemNwwPI4R1NV/aii6YrG9FF05Vd6KLpyhZU0UhX278umq62eV00XW3numi62rZ10QhortCwDV+iYRu+RMM2fImGbfgSDdvwFZq+vnteFw3b8CUatuFLNGzDl2gENFdo2IYv0bANX6JhG75EwzZ8iYZt+ApNX99NrouGbfgSDdvwJRq24Us0AporNGzDl2jYhi/RsA1fomEbvkTDNnyFpq/vrtZFwzZ8iYZt+BIN2/AlGgHNFRq24Us0bMOXaNiGL9GwDV+iYRu+QtPXdxvromEbvkTDNnyJhm34Eo2A5goN2/AlGrbhSzRsw5do2IYv0bANX6Hp67tvddGwDV+iYRu+RMM2fIlGQHOFhm34Eg3b8CUatuFLNGzDl2jYhi/QbH19N6ouGrbhSzRsw5do2IYv0QhortCwDV+iYRu+RMM2fImGbfgSDdvwFZq+vjtTFw3b8CUatuFLNGzDl2gENFdo2IYv0bANX6JhG75EwzZ8iYZt+ApNX9+tqIuGbfgSDdvwJRq24Us0AporNGzDl2jYhi/RsA1fomEbvkTDNnyFpq/v3tNFwzZ8iYZt+BIN2/AlGgHNFRq24Us0bMOXaNiGL9GwDV+iYRu+QsN30V2jYRu+RMM2fImGbfgSjYDmCg3b8CUatuFLNGzDl2jYhi/RsA1foeG76K7RsA1fomEbvkTDNnyJRkBzhYZt+BIN2/AlGrbhSzRsw5do2Iav0PBddNdo2IYv0bANX6JhG75EI6C5QsM2fImGbfgSDdvwJRq24Us0bMNXaPguums0bMOXaNiGL9GwDV+iEdBcoWEbvkTDNnyJhm34Eg3b8CUatuErNHwX3TUatuFLNGzDl2jYhi/RCGiu0LANX6JhG75EwzZ8iYZt+BIN2/AVGr6L7hoN2/AlGrbhSzRsw5doBDRXaNiGL9GwDV+iYRu+RMM2fImGbfgCzZ74u+hkGsrHq2Wal09oTo5E1huScR4fjmQ7O+5l2D5evJSHn7zJO/S8e7Yj9LwbvCP0vG7gCF2Abg89r884Qs9rSo7Q8zqYI/S8ducIPa83+kFP/H2QjtAxUgfoGKkDdIzUAbp0BX27vXqSMn969Z+T7csEKyfbl4FVTrYv86mcbF/GUTnZvjb970+2s++YrJxsX5tt5WT72igrJ9vXJlc5Wcl0spk2qM6+T7Fyspk2qM6+87Byspk2qM6+l7Byspk2qM6+O7Byspk2qM6+369yspk2qM6+g69yspk2qM6+J69yspk2qM6+y65yspk2qM6+b65yspk2qM6+E65yspk2qM6+t61yspk2qM6+W61yspk2qM6+/6xyspk2qM6+o6xyspk2qM6+R6xyspk2qM6+66tyspk2qM6+j6tyspk2qM6+M6tyspk2qM6+16pyspk2qM6+e6pyspk2qM6+H6pyspk2qM6+w6lyspk2qM6+Z6lyspk2qM6+C6lysl1tUDLdT7b6N4Hjevu7vTLcf3LZyslrt4PHNu2V1+4H8X3//No/wAXgtsC72iRbAN7VNtsC8K426haAd7XVtwC8K7NoAHhf35vVAvCuDKsF4F1ZXgvAMU1j4AJwW+B9meZ2PF9pk7EGvGzHE5OmSR5evZ/97Hk8wpy34dOr/4DsyyAdQfZlho4g+zI+R5B9mZwfyL6+y80TZF/m5QiyL6NyBNmXKTmCFEDqgMRslEBiNkogMRslkJiNEkjMRgXkOPT1xXyuJHEbLZLIjRZJ7EaLpEBSiSR+o0USwdEiieFokURxtEjiOEok+/qqN1eSOI4WSRxHiySOo0VSIKlEEsfRIonjaJHEcbRI4jhaJHEcJZJ9fdmeK0kcR4skjqNFEsfRIimQVCKJ42iRxHG0SOI4WiRxHC2SOI4Syb6+DtOVJI6jRRLH0SKJ42iRFEgqkcRxtEjiOFokcRwtkjiOFkkcR4lkX19Y60oSx9EiieNokcRxtEgKJJVI4jhaJHEcLZI4jhZJHEeLJI6jRLKvr5R2JYnjaJHEcbRI4jhaJAWSSiRxHC2SOI4WSRxHiySOo0USx1Ei2deXvruSxHG0SOI4WiRxHC2SAkklkjiOFkkcR4skjqNFEsfRIonjKJFccRwtkjiOFkkcR4skjqNFUiCpRBLH0SKJ42iRxHG0SOI4WiRxHCWSG46jRRLH0SKJ42iRxHG0SAoklUjiOFokcRwtkjiOFkkcR4skjqNEcsdxtEjiOFokcRwtkjiOFkmBpBJJHEeLJI6jRRLH0SKJ42iRxHF0SI4DjqNFEsfRIonjaJHEcbRICiSVSOI4WiRxHC2SOI4WSRxHiySOo0RyxHG0SOI4WiRxHC2SOI4WSYGkEkkcR4skjqNFEsfRIonjaJHEcZRIFhxHiySOo0USx9EiieNokRRIKpHEcbRI4jhaJHEcLZI4jhZJHEeJ5ITjaJHEcbRI4jhaJHEcLZICSSWSOI4WSRxHiySOo0USx9EiieMokRQcR4skjqNFEsfRIonjaJEUSCqRxHG0SOI4WiRxHC2SOI4WSRxHieSM42iRxHG0SOI4WiRxHC2SAkklkjiOFkkcR4skjqNFEsfRIonjKJFccBwtkjiOFkkcR4skjqNFUiCpRBLH0SKJ42iRxHG0SOI4WiRxHCWSK46jRRLH0SKJ42iRxHG0SAoklUjiOFokcRwtkjiOFkkcR4skjqNEcsNxtEjiOFokcRwtkjiOFkmBpBJJHEeLJI6jRRLH0SKJ42iRxHGUSO44jhZJHEeLJI6jRRLH0SIpkFQiieNokcRxtEjiOFokcRwtkjiODsky4DhaJHEcLZI4jhZJHEeLpEBSiSSOo0USx9EiieNokcRxtEjiOEokRxxHiySOo0USx9EiieNokRRIKpHEcbRI4jhaJHEcLZI4jhZJHEeJZMFxtEjiOFokcRwtkjiOFkmBpBJJHEeLJI6jRRLH0SKJ42iRxHGUSE44jhZJHEeLJI6jRRLH0SIpkFQiieNokcRxtEjiOFokcRwtkjiOEknBcbRI4jhaJHEcLZI4jhZJgaQSSRxHiySOo0USx9EiieNokcRxniMpZd0/Xi3TXCqvHmU9fvY8Phz3dnaWy7B9vHgpy8Nr5T2jGXuKnxFeFj8jjC9+Rrhk/IyEjMJnhP/Gzwizjp8Rzh4/I9qA+BnRM4TPaKFniJ8RPUP8jOgZ4meUuGeYjgMZl2GqUC9lGD5e/fZG/+eM3kkKJJVIJnZ2ZZKJzVqZZGL/VSaZ2FKVSSZ2SV2Sa2LjUyaZ2MuUSSa2J2WSOI4WSYGkEkkcR4skjqNFEsfRIonjaJHEcZRIbjiOFkkcR4skjqNFEsfRIimQVCKJ42iRxHG0SOI4WiRxHC2SOI4SyR3H0SKJ42iRxHG0SOI4WiQFkkokcRwtkjiOFkkcR4skjqNFEsfRITkNOI4WSRxHiySOo0USx9EiKZBUIonjaJHEcbRI4jhaJHEcLZI4jhLJEcfRIonjaJHEcbRI4jhaJAWSSiRxHC2SOI4WSRxHiySOo0USx1EiWXAcLZI4jhZJHEeLJI6jRVIgqUQSx9EiieNokcRxtEjiOFokcRwlkhOOo0USx9EiieNokcRxtEgKJJVI4jhaJHEcLZI4jhZJHEeLJI6jRFJwHC2SOI4WSRxHiySOo0VSIKlEEsfRIonjaJHEcbRI4jhaJHEcJZIzjqNFEsfRIonjaJHEcbRISk8kt/kguQ/y6dXvZ9uVh1TPtitXqJ5tV/t89Wy72rmrZ9vVXlw726Wr3bV6tl3tl9Wz7WoHrJ5tV3ta9Wwl1dmm2qX6+l7y6tmm2qX6+n7v6tmm2qX6+p7s6tmm2qX6+r7p6tmm2qX6+t7m6tmm2qX6+v7j6tmm2qX6+h7h6tmm2qX6+j7e6tmm2qX6+l7b6tmm2qX6+n7Y6tmm2qX6+p7V6tmm2qX6+r7S6tmm2qX6+t7P6tmm2qX6+v7M6tmm2qX6+h7K6tmm2qX6+j7H6tmm2qX6+l7E6tlm2qWkr+8XrJ5tpl1K+vqevurZZtqlZJBUZ5tpl5K+vjeueraZdinp6/vXqmebapfq63vMqmebapfq6/vAqmebapfq63u1qmebapfq6/upqmebapfq63ueqmebapfq6/uSqmebapfq63uHqmebapfq6/t7qmebapfq63twqmebapfq6/tkqmfb1S61j/Nxtkvt1eO6fby4PDwBp2zl5LXbwWOb9spr9+12yPv++bV/iPf13TBNEO9qp2yCeFd77b7eDvutIBsqry7rVG7I1/3x1csZ81EO6GVcPr36nWRXO7MrSYGkEsmudn1Xkl15hCvJrhzFlWRX/uNKsi+3ciTZ13fNuJLsy4U8SeI4WiRxHC2SAkklkjiOFkkcR4skjqNFEsfRIonjKJHs67tmXEniOFokcRwtkjiOFkmBpBJJHEeLJI6jRRLH0SKJ42iRxHGUSPb1nUSuJHEcLZI4jhZJHEeLpEBSiSSOo0USx9EiieNokcRxtEjiOEok+/quMFeSOI4WSRxHiySOo0VSIKlEEsfRIonjaJHEcbRI4jhaJHEcJZJ9fYefK0kcR4skjqNFEsfRIimQVCKJ42iRxHG0SOI4WiRxHC2SOI4Syb6+W9OVJI6jRRLH0SKJ42iRFEgqkcRxtEjiOFokcRwtkjiOFkkcR4fk3Nd33rqSxHG0SOI4WiRxHC2SAkklkjiOFkkcR4skjqNFEsfRIonjKJHs67uoXUniOFokcRwtkjiOFkmBpBJJHEeLJI6jRRLH0SKJ42iRxHGUSPb1HfGuJHEcLZI4jhZJHEeLpEBSiSSOo0USx9EiieNokcRxtEjiOEokJxxHiySOo0USx9EiieNokRRIKpHEcbRI4jhaJHEcLZI4jhZJHEeJpOA4WiRxHC2SOI4WSRxHi6RAUokkjqNFEsfRIonjaJHEcbRI4jhKJGccR4skjqNFEsfRIonjaJEUSCqRxHG0SOI4WiRxHC2SOI4WSRxHieSC42iRxHG0SOI4WiRxHC2SAkklkjiOFkkcR4skjqNFEsfRIonjKJFccRwtkjiOFkkcR4skjqNFUiCpRBLH0SKJ42iRxHG0SOI4WiRxHCWSG46jRRLH0SKJ42iRxHG0SAoklUjiOFokcRwtkjiOFkkcR4skjqNEcsdxtEjiOFokcRwtkjiOFkmBpBJJHEeLJI6jRRLH0SKJ42iRxHF0SC4DjqNFEsfRIonjaJHEcbRICiSVSOI4WiRxHC2SOI4WSRxHiySOo0RyxHG0SOI4WiRxHC2SOI4WSYGkEkkcR4skjqNFEsfRIonjaJHEcZRIFhxHiySOo0USx9EiieNokRRIKpHEcbRI4jhaJHEcLZI4jhZJHEeJ5ITjaJHEcbRI4jhaJHEcLZICSSWSOI4WSRxHiySOo0USx9EiieMokRQcR4skjqNFEsfRIonjaJEUSCqRxHG0SOI4WiRxHC2SOI4WSRxHieSM42iRxHG0SOI4WiRxHC2SAkklkjiOFkkcR4skjqNFEsfRIonjKJFccBwtkjiOFkkcR4skjqNFUiCpRBLH0SKJ42iRxHG0SOI4WiRxHCWSK46jRRLH0SKJ42iRxHG0SAoklUjiOFokcRwtkjiOFkkcR4skjqNEcsNxtEjiOFokcRwtkjiOFkmBpBJJHEeLJI6jRRLH0SKJ42iRxHGUSO44jhZJHEeLJI6jRRLH0SIpkFQiieNokcRxtEjiOFokcRwtkjiODsl1wHG0SOI4WiRxHC2SOI4WSYGkEkkcR4skjqNFEsfRIonjaJHEcZRIjjiOFkkcR4skjqNFEsfRIimQVCKJ42iRxHG0SOI4WiRxHC2SOI4SyYLjaJHEcbRI4jhaJHEcLZICSSWSPTmOjMerZdyXT69+P9uePKR+tj25Qv1se9rn62fb085dPdupp724frY97a71s+1pv6yfbU87YP1sJdXZptqluvrO8/rZptqluvru8PrZptqluvoO7vrZptqluvou6/rZptqluvpO6PrZptqluvpu5frZptqluvqO4vrZptqluvqu3/rZptqluvrO3PrZptqluvru2frZptqluvoO1/rZptqluvou1PrZptqluvpO0frZptqluvpuzvrZptqluvqOy/rZptqluvquyPrZptqluvrOxfrZptqluvruwvrZptqluvoOwPrZptqluvouvfrZptqluvpOuvrZptqluvput/rZptqluvqOtPrZptqluvqusfrZptqluvrOrvrZptqluvruK5Fxup3tOg4nZ9vVLlU92652qerZdrVL1c62q+9iqp9tV7tU9Wy72qWqZ9vVLlU9W0l1tl3tUtWzTbVLdfU9OPWzTbVLdfV9MrWz3br6zpf62WbapbauvjulfraZdqltkFRnm2mX2rr6Lo/62WbapbauvhOjfrapdqmuvluifrapdqmuvqOhfrapdqmuvuugfrapdqmuvjOgfrapdqmunr1fP9tUu1RXz7Cvn22qXaqrZ8HXzzbVLtXVM9Xr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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "random",
        "notify_created_note_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_config",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5276036973553878575": {
            "error_kind": "string",
            "string": "Function get_config can only be called statically"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+1dB5gUx7Gevb0D7uC4gyMIgQQI5bjhopVQRDlnW+HCnhICCVAAhFhAgCSEQAJly3K2ZdmWHOQkOdvP2X5+zjk855zDc3rd0tZu3X81s7O31ce2oL+v7mane/6qrq6ujtOTCF4IFzYEwbvqX7hOGEoW/tcZmgP3GoR744V7zcK9FuHeJOHeNEPz4d5sId0c4d5c4d5ewr39Cvd4qCv8n1/4n6oupPdjWNlUZ3t7riuTS2fTvalMT193R6q9o6+zO92d7ujuGMh0Z7O57vburp6+nq5UT7o9m0sPdvRkBwtg/6zTk4vrweK61gOXvVo9/MuRHv4l6CGhrIekoj3UQ1m5lDuhh5USxNXC7i4CWuWMHSXlTAlqWjlpuuC6+Hfhx3/qgqFe0UZ8F+79R6gZSYdKHGHNyBRqRvrfit7mP3VuChc9bLVyaubZFi7meaSY3I7shbUtWznHBaWKyEPCoV408lKUM+lQYAse1gSPWPikXmWtSyoamyMdWhkTyjqsS+o6A+18/6eQb63uG+FqlndSUYfcuVhc2/WvD0qNF4adtFuUdqkDzQaSO9j6ZJnCq9YQG5JuCk9bzjEjlzONN6xsk4MXKgnJahX978J1Q8j1mMI1PTfW/B5nqNFQU7J035UOxquVVbrLpZwT9Gwq41LO5pHLmcUbkk2NZ7bz/Kii8H8Cu98MNjXR/G4x1GpoUsGmLNUFozOMc9XT15ZzoqLfGsPknFxwuG2F/1MK/6cW/k8rdKj2L6Sfbn7vZmiGod0NzTQ0y9AehvY0NNvQHNsoG9rL0DxDexvax9C+hvYztL+hAwwdaOggQwcbOsTQoYYOM5QyZCdNMoayhtoNdRjqNNRlqNtQj6GXGDrc0BGGjjR0VLFXUPhvhZ8TVDb0SFUX0m1JNy3j0UmHAh+d1Med73i4kKouvFBQrLuhhJsaTWOb4sjYjkk6FPgYB8Z2bI0bm833sZ4b21RHxnZc0qHAxzkwtuNr3Nhsvo93YGwuZJ1fqBjafd0Tkn5WsmmOKtmJSYcCn+igki2o8Upm873Ak0pmncEJDirZSZ5Mppw8cjnb8YY08G1jA9wp7Hoauz4ZBr6nmN+nGjrN0OnCZEpS2QYUW+/0KYp18wxlh4dlcwYrg1PZ9Wns+nQomzPN77MMnW3onORQPE27tP7jJAf18lzFsrZ5bwxGZ2Z9siN/EqjKmel2h53KJJhuadLlPKOX8w1dYOhCQxcZutjQJYZeauhlhi41dJmhyw1dYajXUJ+hfkMDhnKGBg1daegqQ1cbusbQtYYWGrrO0CJDiw1db+gGQ0sMLTW0zNCNhm4ydLOhWwwtN7TC0EqcdDkvWZoBpHvnC/cuEO5dKNy7SLh3sXDvEuHeS4V7LxPuXSrcu0y4d7lw7wrhXq9wr0+41y/cGxDu5YR7g8K9K4V7Vwn3rhbuXSPcu1a4t1C4d51wb5Fwb7Fw73rh3g3CvSXCvaXCvWXCvRuFezcJ924W7t0i3Fsu3Fsh3FuZLDlJCgcU/s8v/E9VF4Y4zWobjvMUsHKDL4Tz9bAGLtDD6rlQDyt9kRpWLn2xGlZ/+hI1rO70S9WwUumXaWHlUulLtbD6U+nLtLC6U+nLtbBM3b5CCStnsHqVsPoNVp8SVrfB6lfCsr5wQAcrZ7FyOlj9FmtQB6vbYl2pg/V823GVClbueayrVbD6n8e6RgWr+3msa1WwXmhrF2pg5V7Auk4Dq/8FrEUaWN0vYC3WwCr0Ta5XwBooYN2ggNVXwFqigNVVwFpaPVZxD/Oy6rHShHVj1Vjdg4R1U/VYfYR1c/VY1F9N31I1VlcRa3nVWB1FrBVVY6WLWCuTbiZFcLtoLYwdCOtWvTw/vw1Se6LKThCem9SfuFulXNZaW4ILIW13/5ynWDa2nFc50ONtHuhR08bPc6TH1Y58j7ac+ZHLmcEbVjZcRLD2RIsFq5Pybtl8cugiwhrze62hdYZuT4YvIqSqC2m7G+98B2X/v/VuFzWrlc/meY2DfP+o3o3N1yuX+xrF9na9oi9StJu0L2Wxm2JZbEi6qcO1VC8kH7ue+dINMX3sRvP7DkN3GrrLoY+1u50vcOBrflzjPtbmeaODfP/Ek3q9UbEublL0sYp2k/alLGYolsXdSTd1uJbqheRjNzFfendMH7vZ/L7H0BZDWx36WPs2yYUOfM1Pa9zH2jxvdpDvn3lSrzcr1sV7FX2sot2kfSmL3RXL4r6kmzpcS/VC8rH3Ml96X0wfu8383m7ofkMPOPSx9m29ixz4mp/XuI+1ed7mIN+/8KReb1Osiw8q+lhFu0n7UhYzFcvioaSbOlxL9ULysQ8yX/pQTB/7sPn9iKFHDb3coY+1b0Nf7MDX/LLGfazN88MO8v0rT+r1w4p18TFFH6toN2lfymKWYlm8IummDtdSvZB87GPMl74ipo993Px+paFXGXq1Qx9rT5u4xIGv+XWN+1ib58cd5Ps3ntTrxxXr4msUfayi3aR9KYs9FMvitUk3dbiW6oXkY1/DfOlrY/rY15nfrzf0BkNvdOhj7Wk+L3Xga35b4z7W5vl1DvL9O0/q9esU6+ITij5W0W7SvpTFnopl8aakmzpcS/VC8rFPMF/6ppg+9knz+82G3mLorQ59rD0t7WUOfM3va9zH2jw/6SDff/CkXj+pWBefUvSxinaT9qUsZiuWxdNJN3W4luqF5GOfYr706Zg+9m3m99sNvcPQOx362DnJ0vv9HLdanf6xxn2szfPbHOT7T57U67cp1sVnFH2sot2kfSmLOYpl8a6kmzpcS/VC8rHPMF/6rpg+9t3m93sMvdfQ+xz6WHva72UOfM2fa9zH2jy/20G+/+JJvX63Yl18VtHHKtpN2peymKtYFs8l3dThWqoXko99lvnS52L62Peb3x8w9EFDH3LoY+1p6pc78DV/rXEfa/P8fgf5/psn9fr9inXxw4o+VtFu0r6UxV6KZfGRpJs6XEv1QvKxH2a+9CMxfexHze+PGfq4of9y6GPt1yqucOBr/l7jPtbm+aMO8v1/ntTrjyrWxU8o+lhFu0n7UhbzFMvik0k3dbiW6oXkYz/BfOknY/rYT5nfnzb0GUOfdehj7deAeh34mn/UuI+1ef6Ug3z/05N6/SnFuvg5RR+raDdpX8pib8Wy+HzSTR2upXoh+djPMV/6+Zg+9gvm938b+qKh/3HoY+3X1voc+Jp/1biPtXn+goN8/9uTev0Fxbr4JUUfq2g3aV/KYh/Fsvhy0k0drqV6IfnYLzFf+uWYPvYr5vdXDX3N0Ncd+lj7Nct+B77mPzXuY22ev+Ig30GDH/X6K4p18RuKPlbRbtK+lMW+imXxzaSbOlxL9ULysd9gvvSbMX3st8zvbxv6jqHvOvSx9mvBAw58TaKhtn2szfO3HOS7zpN6/S3Fuvg9RR+raDdpX8piP8Wy+H7STR2upXoh+djvMV/6/Zg+9gfm9w8N/a+hHzn0sfZr7DkHviZZ4z7W5vkHDvJd70m9/oFiXfyxoo9VtJu0L2Wxv2JZ/CTppg7XUr2QfOyPmS/9SUwf+1Pz+2eGfm7oFw597AHJ0vf6OG61Om2ocR9r8/xTB/ke40m9/qliXfyloo9VtJu0L2VxgGJZ/Crppg7XUr2QfOwvmS/9VUwf+2vz+zeGfmvodw597IHJ0vdPOW61Oh1b4z7W5vnXDvI9zpN6/WvFuvh7RR+raDdpX8riQMWy+EPSTR2upXoh+djfM1/6h5g+9o/m958M/dnQXxz62IOSpe9Jc9xqddpY4z7W5vmPDvLd5Em9/qNiXfyroo9VtJu0L2VxkGJZ/C3ppg7XUr2QfOxfmS/9W0wf+3fz+/8M/cPQPx362IMN9tUOfM34GvexNs9/d5DvCZ7U679r7vFR9LGKdpP2pSwOViyLfyfd1OFaqheSj/0X86X/julj/5N84UfCUF29Ox97iOFzjQNf01zjPtbm+T8O8j3Rk3r9H821EcX9Vop2k/alLA5RLIv6ejd1uJbqheRjrQ2SL62vj+djG8zFGENjDY1z6GMPNXyvdeBrWmrcx9o8Wx1r47Z6Uq8bFOtio6KPVbSbtC9lcaiij22qd1OHa6leSD62kfnVppg+dry5mGCo2dBEhz72MMN3oQMfO6nGfazN83gHPnayJ/V6vGZdVPSxinaT9qUsDlP0sa31bupwLdULyce2ML/aGtPHTjIXkw21GZri0MemDN/rHPjYthr3sTbPkxz42Cme1OtJinVxqqKPVbSbtC9lkVL0sdPq3dThWqoXko+dyvzqtJg+drq52M3QDEO7O/SxacN3kQMfO7XGfazN83QHPnaaJ/V6umJdnKnoYxXtJu1LWaQVfeysejd1uJbqheRjZzK/Oiumj93DXOxpaLahOQ59bMbwXezAx06vcR9r87yHAx+7myf1eg/FujhX0ccq2k3al7LIKPrYverd1OFaqheSj53L/OpeMX3sPHOxt6F9DO3r0MdmDd/rHfjYGTXuY22e5znwsbt7Uq/nKdbF/RR9rKLdpH0pi6yij92/3k0drqV6IfnY/Zhf3T+mjz3AXBxo6CBDBzv0se2G7w0OfOzMGvexNs8HOPCxs3x5f1OxLh6i6GMV7SbtS1m0K/rYQ+vd1OFaqheSjz2E+dVDY/rYw8xFylDaUMahj+0wfJc48LF71LiPtXk+zIGP3dOXtWzFuphV9LGKdpP2pSw6FH1se72bOlxL9ULysVnmV9tj+tgOc9FpqMtQt0Mf22n4LnXgY2fXuI+1ee5w4GPn+FKvFetij6KPVbSbtC9l0anoY19S76YO11K9kHxsD/OrL4npYw83F0cYOtLQUQ59bJfhu8yBj51b4z7W5vlwBz52L0/q9eGKdfFoRR+raDdpX8qiS9HHzq93U4drqV5IPvZo5lfnx/Sxx5iLYw0dZ+h4hz622/C90YGPnVfjPtbm+RgHPnZvT+r1MYp18QRFH6toN2lfyqJb0ceeWO+mDtdSvZB87AnMr54Y08cuMBcnGTrZ0CkOfWyP4XuTAx+7T437WJvnBQ587L6e1OsFinXxVEUfq2g3aV/KokfRx55W76YO11K9kHzsqcyvnhbTx55uLs4wdKahsxz62JcYvjc78LH71biPtXk+3YGP3d+Ten26Yl08W9HHKtpN2peyeImijz2n3k0drqV6IfnYs5lfPSemjz3XXJxn6HxDFzj0sYcbvrc48LEH1LiPtXk+14GPPdCTen2uYl28UNHHKtpN2peyOFzRx15U76YO11K9kHzshcyvXhTTx15sLi4x9FJDL3PoY48wfJc78LEH1biPtXm+2IGPPdiTen2xYl28VNHHKtpN2peyOELRx15W76YO11K9kHzspcyvXhbTx15uLq4w1Guoz6GPPdLwXeHAxx5S4z7W5vlyBz72UE/q9eWKdbFf0ccq2k3al7I4UtHHDtS7qcO1VC8kH9vP/OpATB+bMxeDhq40dJVDH3uU4bvSgY89rMZ9rM1zzoGPTXlSr3OKdfFqRR+raDdpX8riKEUfe029mzpcS/VC8rFXM796TUwfe625WGjoOkOLmI+lUKdczq2Bnj6vrXdj20nlPE9UtO02RazFivqzdjMuKLUlPGi315pyc3mvr3co8PX1+rg3KDo6V/m+gXkUJdznjc1W0rrAvbFNTLpxMtpytiXdVIolzG71TxpQ7DUlCkaRYELXF2g0vJJmAXDDXlqoQMtsnlwUwBIHnmmJctPsKt91DvNd9bZvxzpMVRfS1jBvdDB8vEm5eSenYHHzBVxtXSxzpIubHeni5ghdVP3arSNdZHbsdEp/Gfmc2UC2obb9gG34bnTgSxXLO62pQ9seGzix9xlUqINyNsUxXfhvLZ3wDtYtUT3GVHUhfaMjh8iFrlDmdDk+VuZbHDiG9hqZ26ukI1P13ov62nQw7Q1u7HI5a6hHWj7ldK5ZPisYVjqbNXVjoCs9ODCY7ejqyfSlO7OdnYPtg12d3e0Dgx3tvQNduXR7bzbTk+tKDaa7c7mujmx/V+dgz0B/5yB32umBbLZ9oKevP92R6eztS3UPZHtTg+1d2UyqdyDbNTCQ7e7s7M1mBzq7B7t7ujOZ3sFsd6qjq6sn1ZnJ9mRclc+KQvmM5khzoqOR5sqCYd3qiwN3Jd9KB856laOGa5XDUY3Vxa0OdHGbI13c5nBU48ouOmt8VOPKBrpqfFQz0dGoRrG80127RjUY0isdjWpW+ziqWe14VLPagWPo3glHNfn62nQw3Y56zXnPRjVrFEc1XYqjGlfls4aNasIahVqejnIpp6sGZq2PDcxaxw3MWgcNTI+jBqZBWU5NB7ZOEUtz2kyzsepx5AzXxWisqtXp7fV6jcKQabMaaqxclc/tL6IpuPUFw9ogbfZIVRfSYZseNHfxVH0uvmJP2EXBkw6TnuiwWqyNNV4etsJsdNBJuMNRh+kOh9O1Gxzp4k5HurjT4XStK7s4osana13ZwJEeTNdudDBdq1je6SN3TddieN5/a+mEd/zucjma3ujIId7lcDRtZb7LgWM4ypPp2o2KnaJN9bXpYI5yNMLaNArTtZrlc7fidO2RiiNgV+Vz9w4YAbt63WFzwbDu8cWBu5JvswNnvcVRw7XF4ajG6uIeB7rY6kgXWx2OalzZxfwaH9W4soFjPNha72JUo1je6WN2jWowpDc7GtXc6+Oo5l7Ho5p7HTiGY3fCUc199bXpYI511Gu+z7NRzTbFUc0xiqMaV+WzbQdsQtGcjnIpp6sGZruPDcx2xw3MdgcNzHGebELRdGD3K2JpTptpNlbHOXKG94/CJpQHFDehHNlQm42Vq/J5QCgf7T0CiptO0lMVz5F6UNGvW5serXOkHnTUiD5U71Dgh+r1cR9WdMyu8v1wfUnBSrijeo7UVE/OkdLc2cYrxSP1Ds+Relhx6Mq9Ogn9Ytha+GihAr283sE5UrYAHnHgmR5xvFCjle86h/muVsbHanyxyxrmYw6GWK9wNNx8hcPFrpc70sXjjnTxuMPFLld2cWKNL3a5soEFHmzhe8yBL1Us7/SCXYtdGJ7331o64R2sV7qci3zMkUN8pcO5SCvzKx04hpM8Wex6TLFT9Kr62nQwJzman3rVKCx2aZbPqxUXuxYozh+6Kp9X74AtfFMdjTRfUzCs1/riwF3J9xoHzvp1jhqu1zkc1VhdvNaBLl7vSBevdziqcWUXp9T4qMaVDZxa46OaqY5GNYrlnT5116gGQ/o1jkY1b/BxVPMGx6OaNzhwDKfthKOaN9bXpoM5zVGv+Y2ejWqeUBzVnKo4qnFVPk/sgC18mtNRLuV01cC8yccG5k2OG5g3OWhgTvdkC5+mA3tSEUtz2kyzsTrdkTN8chS28L1ZcQvfgobabKxclc+bX0RTcG8pGNZbpc0eqepCOmzTg+YunmqxFDeOODm3iHSovUfUlQ6rxXqqxsvDVpinHHQSnnbUYXra4XTtWx3p4m2OdPE2h9O1ruzirBqfrnVlA2d7MF37lIPpWsXyTp+9a7oWw/P+W0snvOP3dpej6accOcS3OxxNW5nf7sAxnOPJdO1Tip2id9TXpoM5x9EI6x2jMF2rWT7vVJyuPVtxBOyqfN65A0bArl53eKZgWO/yxYG7ku8ZB8763Y4arnc7HNVYXbzLgS7e40gX73E4qnFlF+fV+KjGlQ2c78HWehejGsXyTp+/a1SDIf2Mo1HNe30c1bzX8ajmvQ4cwwU74ajmffW16WAucNRrfp9no5pnFUc15yuOalyVz7M7YBOK5nSUSzldNTDP+djAPOe4gXnOQQNzoSebUDQd2PsVsTSnzTQbqwsdOcP3j8ImlA8obkI5u6E2GytX5fMBhzMgxxsmC5L6PuiDjmfBNHzPB4W9FqnqgmY7lP6gok/7UI2Xhz1T8EMO2sIPK+8x0d7fZGdhNGVsK+AFunbtZAZqSkFW7TL/iKKtW1WO1tlzH3HU8f5ovUOBP1qvj/sxRcfnKt8f28kr2ccdjWa1HaymLf1XjTcmY01Za8poy/i/PLHz+qS7OklBuw59Qq2sMv1WtslBaeBmf1v8fxeurX7ouoFd5wvX9NwnzcWnDH3a0GfqS+v+Y4JSZ1kK85XKMREMb2xd2IoSltOZuE868rHFoO2ANDO/f+BHA5NQzPMBnuS5TjHPBwZ+VMaDlOuJKzkPDkbHhlLVhfQhivp05Si1y+bQwA85D/NEzpQncqY9kTPjiZxZT+Rs90TODk/k7PREzi5P5Oz2RM4eT+R8iSdyHu6JnEd4IueRnsh5lCdyHu2JnPM9kfMYT+Q81hM5j/NEzuM9kfMET+Q80RM5F3gi50meyHmyJ3Ke4omcp3oi52meyHm6J3Ke4YmcZ3oi51meyHm2IzlreS3vnFHKc6q6kD5XUX//rPPDHs8L/JDzfE/kvMATOS/0RM6LPJHzYk/kvMQTOV/qiZwv80TOSz2R8zJP5LzcEzmv8ETOXk/k7PNEzn5P5BzwRM6cJ3IOeiLnlZ7IeZUncl7tiZzXeCLntZ7IudATOa/zRM5Fnsi52BM5r/dEzhs8kXOJJ3Iu9UTOZZ7IeaMnct7kiZw3eyLnLZ7IudwTOVd4IudKT+S81RM5V3ki522eyLnaEznznsi5xhM513oi5zpP5LzdEznXeyLnBk/k3OiJnHd4Iuednsh5lydybvJEzrs9kXOzJ3Le44mcWzyRc6snct7riZz3eSLnNk/k3O6JnPd7IucDnsj5oCdyPuSJnA97Iucjnsj5qCdyvtwTOR/zRM5XeCLn457I+UpP5HyVJ3K+2hM5X+OJnK/1RM7XeSLn6z2R8w2eyPlGT+R8whM53+SJnE96IuebPZHzLZ7I+VZP5HzKEzmf9kTOt3ki59s9kfMdnsj5Tk/kfMYTOd/liZzv9kTO93gi53s9kfN9nsj5rCdyPueJnO/3RM4PeCLnBz2R80OeyPlhT+T8iCdyftQTOT/miZwf90TO//JEzk94IucnPZHzU57I+WlP5PyMJ3J+1hM5P+eJnJ/3RM4veCLnf3si5xc9kfN/PJHzS57I+WVP5PyKJ3J+1RM5v+aJnF/3RM5veCLnNz2R81ueyPltT+T8jidyftcTOb/niZzf90TOH3gi5w89kfN/PZHzR57I+WNP5PyJJ3L+1BM5f+aJnD/3RM5feCLnLz2R81eeyPlrT+T8jSdy/tYTOX/niZy/90TOP3gi5x89kfNPnsj5Z0/k/Isncv7VEzn/5omcf/dEzv/zRM5/eCLnPz2R81+eyPlvT+T8jydyWkAf5Ex4ImedJ3ImPZGz3hM5GzyRc4wnco71RM5xnsjZ6ImcTZ7IOd4TOSd4ImezJ3JO9ETOFk/kbPVEzkmeyDnZEznbPJFziidyTvVEzmmeyDndEzl380TOGZ7Iubsncs70RM5Znsi5hydy7umJnLM9kXOOJ3LO9UTOvTyRc54ncu7tiZz7eCLnvp7IuZ8ncu7viZwHeCLngZ7IeZAnch7siZyHeCLnoZ7IeZgncqY8kTPtiZwZT+TMeiJnuydydngiZ6cncnZ5Ime3J3L2eCLnSzyR83BP5DzCEzmP9ETOozyR82hP5JzviZzHeCLnsZ7IeZwnch7viZwneCLniZ7IucATOU/yRM6TPZHzFE/kPNUTOU/zRM7TPZHzDE/kPNMTOc/yRM6zPZHzHE/kPNcTOc/zRM7zPZHzAk/kvNATOS/yRM6LPZHzEk/kfKkncr7MEzkv9UTOyzyR83JP5LzCEzl7PZGzzxM5+z2Rc8ATOXOeyDnoiZxXeiLnVZ7IebUncl7jiZzXeiLnQk/kvM4TORd5IudiT+S83hM5b/BEziWeyLnUEzmXeSLnjZ7IeZMnct7siZy3eCLnck/kXOGJnCs9kfNWT+Rc5Ymct3ki52pP5Mx7IucaT+Rc64mc6zyR83ZP5FzviZwbPJFzoydy3uGJnHd6Iuddnsi5yRM57/ZEzs2eyHmPJ3Ju8UTOrZ7Iea8nct7niZzbPJFzuydy3u+JnA94IueDnsj5kCdyPuyJnI94Iuejnsj5ck/kfMwTOV/hiZyPeyLnKz2R81WeyPlqT+R8jSdyvtYTOV/niZyv90TON3gi5xs9kfMJT+R8kydyPumJnG/2RM63eCLnWz2R8ylP5HzaEznf5omcb/dEznd4Iuc7PZHzGU/kfJcncr7bEznf44mc7/VEzvd5Iueznsj5nCdyvt8TOT/giZwf9ETOD3ki54c9kfMjnsj5UU/k/Jgncn7cEzn/yxM5P+GJnJ/0RM5PeSLnpz2R8zOeyPlZT+T8nCdyft4TOb/giZz/7YmcX/REzv/xRM4veSLnlz2R8yueyPlVT+T8midyft0TOb/hiZzf9ETOb3ki57c9kfM7nsj5XU/k/J4ncn7fEzl/4ImcP/REzv/1RM4feSLnjz2R8yeeyPlTT+T8mSdy/twTOX/hiZy/9ETOX3ki5689kfM3nsj5W0/k/J0ncv7eEzn/4Imcf/REzj95IuefPZHzL57I+VdP5PybJ3L+3RM5/88TOf/hiZz/9ETOf3ki5789kfM/nsgZ1PkhZ8ITOes8kTPpiZz1nsjZ4ImcYzyRc6wnco7zRM5GT+Rs8kTO8Z7IOcETOZs9kXOiJ3K2eCJnqydyTvJEzsmeyNnmiZxTPJFzqidyTvNEzumeyLmbJ3LO8ETO3T2Rc6Yncs7yRM49PJFzT0/knO2JnHM8kXOuJ3Lu5Ymc8zyRc29P5NzHEzn39UTO/TyRc39P5DzAEzkP9ETOgzyR82BP5DzEEzkP9UTOwzyRM+WJnGlP5Mx4ImfWEznbPZGzwxM5Oz2Rs8sTObs9kbPHEzlf4omch3si5xGeyHmkJ3Ie5YmcR3si53xP5DzGEzmP9UTO4zyR83hP5DzBEzlP9ETOBZ7IeZIncp7siZyneCLnqZ7IeZoncp7uiZxneCLnmZ7IeZYncp7tiZzneCLnuZ7IeZ4ncp7viZwXeCLnhZ7IeZEncl7siZyXeCLnSz2R82WeyHmpJ3Je5omcl3si5xWeyNnriZx9nsjZ74mcA57ImfNEzkFP5LzSEzmv8kTOqz2R8xpP5LzWEzkXeiLndZ7IucgTORd7Iuf1nsh5gydyLvFEzqWeyLnMEzlv9ETOmzyR82ZP5LzFEzmXeyLnCk/kXOmJnLd6IucqT+S8zRM5V3siZ94TOdd4IudaT+Rc54mct3si53pP5NzgiZwbPZHzDk/kvNMTOe/yRM5Nnsh5tydybvZEzns8kXOLJ3Ju9UTOez2R8z5P5NzmiZzbPZHzfk/kfMATOR/0RM6HPJHzYU/kfMQTOR/1RM6XeyLnY57I+QpP5HzcEzlf6Ymcr/JEzld7IudrPJHztZ7I+TpP5Hy9J3K+wRM53+iJnE94IuebPJHzSU/kfLMncr7FEznf6omcT3ki59OeyPk2T+R8uydyvsMTOd/piZzPeCLnuzyR892eyPkeT+R8rydyvs8TOZ/1RM7nPJHz/Z7I+QFP5PygJ3J+yBM5P+yJnB/xRM6PeiLnxzyR8+OeyPlfnsj5CU/k/KQncn7KEzk/7Ymcn/FEzs96IufnPJHz857I+QVP5PxvT+T8oidy/o8ncn7JEzm/7ImcX/FEzq86krMO5MymOtvbc12ZXDqb7k1levq6O1LtHX2d3enudEd3x0CmO5vNdbd3d/X09XSletLt2Vx6sKMnO1jA3k8xz18bpTynqgvpr9fp6e9fnpRzvaL+vuFJnhsU8/xNT/I8RjHP3/Ikz2MV8/xtT/I8TjHP3/Ekz42Kef6uJ3luUszz9zzJ83jFPH/fkzxPUMzzDzzJc7Ninn/oSZ4nKub5fz3Jc4tinn/kSZ5bFfP8Y0/yPEkxzz/xJM+TFfP8U0/y3KaY5595kucpinn+uSd5nqqY5194kudpinn+pSd5nq6Y5195kufdFPP8a0/yPEMxz7/xJM+7K+b5t57keaZinn/nSZ5nKeb5957keQ/FPP/BkzzvqZjnP3qS59mKef6TJ3meo5jnP3uS57mKef6LJ3neSzHPf/Ukz/MU8/w3T/K8t2Ke/+5JnvdRzPP/eZLnfRXz/A/FPCeDF/b4fLmQ4f0NHWDoQEMHGTrY0CGGDjV0mOVnKG0oY3ViqN1Qh6FOQ12Gug31GHqJocMNHWHoSENHGTq6oINjDB1r6DhDxxs6wdCJhhYYOsnQyYZOMXSqodMMnW7oDENnGjrL0NmGzjF0rqHzDJ1v6AJDFxq6yNDFhi4x9FJDLzN0qaHLDF1u6ApDvYb6DPUbGjCUMzRo6EpDVxm62tA1hq41tNDQdYYWGVps6HpDNxhaYmipoWWGbjR0k6GbDd1iaLmhFYZWGrrV0CpDtxlabShvaI2htYbWGbrd0HpDGwxtNHSHoTsN3WVok6G7DW02dI+hLYa2GrrX0H2Gthnabuh+Qw8YetDQQ4YeNvSIoUcNvdzQY4ZeYehxQ6809CpDrzb0GkOvNfQ6Q6839AZDbzT0hKE3GXrS0JsNvcXQWw09ZehpQ28z9HZD7zD0TkPPGHqXoXcbeo+h9xp6n6FnDT1n6P2GPmDog4Y+ZOjDhj5i6KOGPmbo44b+y9AnDH3S0KcMfdrQZwx91tDnDH3e0BcM/behLxr6H0NfMvRlQ18x9FVDXzP0dUPfMPRNQ98y9G1D3zH0XUPfM/R9Qz8w9END/2voR4Z+bOgnhn5q6GeGfm7oF4Z+aehXhn5t6DeGfmvod4Z+b+gPhv5o6E+G/mzoL4b+auhvhv5u6P8M/cPQPw39y9C/Df3HkK1sCUN1hpKG6g01GBpjaKyhcYYaDTUZGm9ogqFmQxMNtRhqNTTJ0GRDbYamGJpqaJqh6YZ2MzTD0O6GZhqaZWgPQ3samm1ojqG5hvYyNM/Q3ob2MbSvof0M7W/oAEMHGjrI0MGGDjF0qKHDDKUMpQ1lDGUNtRvqMNRpqMtQt6EeQy8xdLihIwwdaegoQ0cbmm/oGEPHGjrO0PGGTjB0oqEFhk4ydLKhUwydaug0Q6cbOsPQmYbOMnS2oXMMnWvoPEPnG7rA0IWGLjJ0saFLDL3U0MsMXWroMkOXG7rCUK+hPkP9hgYM5QwNGrrS0FWGrjZ0jaFrDS00dJ2hRYYWG7re0A2GlhhaamiZoRsN3WToZkO3GFpuaIWhlYZuNbTK0G2GVhvKG1pjaK2hdYZuN7Te0AZDGw3dYehOQ3cZ2mTobkObDd1jaIuhrYbuNXSfoW2Gthu639ADhh409JChhw09YuhRQy839JihVxh63NArDb3K0KsNvcbQaw29ztDrDb3B0BsNPWHoTYaeNPRmQ28x9FZDTxl62tDbDL3d0DsMvdPQM4beZejdht5j6L2G3mfoWUPPGXq/oQ8Y+qChDxn6sKGPGPqooY8Z+rih/zL0CUOfNPQpQ5829BlDnzX0OUOfN/QFQ/9t6IuG/sfQlwx92dBXDH3V0NcMfd3QNwx909C3DH3b0HcMfdfQ9wx939APDP3Q0P8a+pGhHxv6iaGfGvqZoZ8b+oWhXxr6laFfG/qNod8a+p2h3xv6g6E/GvqToT8b+ouhvxr6m6G/G/o/Q/8w9E9D/zL0b0P/MWQ7FglDdYaShuoNNRgaY2isoXGGGg01GRpvaIKhZkMTDbUYajU0ydBkQ22GphiaamiaoemGdjM0w9DuhmYammVoD0N7GpptaI6huYb2MjTP0N6G9jG0r6H9DO1v6ABDBxo6yNDBhg4xdKihwwylDKUNZQxlDbUb6jDUaajLULehHkMvMXS4oSMMHWnoKENH236LoWMMHWvoOEPHGzrB0ImGFhg6ydDJhk4xdKqh0wydbugMQ2caOsvQ2YbOMXSuofMMnW/oAkMXGrrIkP3WvP2Ou/1Guv3+uP22t/1utv0m9RWG7LeU7XeK7TeA7fd17bdr7Xdh7TdX7fdM7bdC7Xc47Tcu7fcj7bcZ7XcP7TcF7ff67Lfw7Hfm7Dfc7PfR7LfH7He97Dez7Peo7Lee7HeU7DeK7Pd/7Ld17Hdr7Ddh8obst0zsd0LsNzjs9y3styPsdxnsNw/s9wTsWf32HHx7xrw9v92ejW7PHbdnetvzsu1Z1PacZ3uGsj2f2J79a8/VtWfW2vNg7Vmr9hxTe0aoPX/Tnm1pz420ZzK+0pA9S9Ce02fPwLPny9mz2+y5aPbMMXuelz0ry55DZc94sucn2bOJ7Lk/9kwde16NPQvGnrNizzCx54PYszfsuRb2zAh7HoM968CeI2Df0bfvv9t3y+172/ad6A8Zsu/y2vdk7Tuo9v1O++6kfS/RvvNn36ez76rZ98DsO1b2/SX7bpB978a+02LfF7HvYtj3HOw7BLbfave+233ldp+13cNs9+Hafal2n6bdt2j38dl9bXaf1/cN2X1Adl+M3Sdi903YfQR2Xd2uM9t1V7sOadfl7DqVXbex6xh2Xt/Oc9t5XzsPaucF7TyZnTey8yh2XsGOs+24047D7LjE9tPrXmjyA7vP2Ib9g1IouIMgWYi3+3LtPlW7b9PuY7T7+uw+N7vvy+6DsvuC7D4Zu2/E7qOw+wrsOrtdd7brsHZd0q7T2XUru45j1zXsPL+d97bzwHZe1M4T2nmzOYbmGtrLkB1323GoHZfZccp+wfBwGLtuLvyf+qNjZtzw6TecwNO1RMS1EtaGNbe9+ejuk3mc7WPYsPL4I7Pbvv6m1TyuqxD3+BN7PjPzR3WX8LieiLhjIuKOi4g7MSLupIi4syLizomIuzAi7uKIuEsj4i6PiLsyIu7qiLiFEXGLIuJuioi7JSJuVUTc6oi4OyPiNkXEbYuIuz8i7qGIuEci4l4dEffaiLgnIuKejIh7KiLubRFx742IezYi7gMRcR+KiPtkRNynI+K+EBH3xYi4rxTi3vfxlf941Tc+dC2P+3Yh7tnuj5/y9Te0TONx3ynEfe6cR798weSbyb0977NteHrOC/8bC7/rCv/tY9bnzy/8TlUX0o0MVxu/O9WTawyGBmX5s40M0wF+hvDr3eA//56FDS/PD8UPgG9z4XeC6ZKeobg6FvdYIW5cUGpz7fXKwnUj4Lkody6Ttt7aBPnrWN5sOC7vgnemn/CPL+AHQ7DT2e7ObKa7M5MZyKV6Bzq7BnuyXalsX0e2p78vncp2ZLoHunqzqVQum+tvTw109nQM5Hp7OrKDfb09nYR9goidzfUZqI7ezu6+9GBv52Cqr72rO9s72NU10DvQY+aYO1ID6f7OdH8mPdjd3dvR0dvf0ZNOD+Z6Oga7i9gnOtHLC3XFhgVu8Iu+6iQn+NkOwj85L+m+MlnxBmGfwmRXfH+wiH+qG/yi7k9zg1+0ndPzVet+WCDsM/Iu7CbdRfhnOsF/oY2z4Sw38hf1c7Yb+dsJ/xyGn3Cgn3Pd4Bdt/zw3+EXbP9+N/gcJ/4ICfsCw093ZTKYra9cduwdS6faB/ky3abn62lP9qd7+TK6nPd0z2J5pz/YP9PeZNcre9GBqsLe/Z7D7BXDCvtCJ7Nmi7VzkRPfZYpt4saCbMg+ny6ET9iWVY5cLxbbqpeHYIy5awn6ZgJ3pzfanegZTvR3dvV05s5CdMp2crlxfd26wM9PbZzo0mYF0Op1rN38yuYH2nr6BznRfp1n97ugz7Io6uTTvwl7Sxb7ZZcr4nb2mU9vZWfT1lyvj9/V1dvUafRL+Fcr42f7O3GC2q+hrepXxezvaBwc7sr2E36eM35FO5ToyXUXb7FfG7+lLdXR2dxftZ0AZ3/THswM9vX2En9PWT18u1T+Q7qGx3mABn3jYQLyvVOZdCD0J4BcEQ8eyAfBvAlm1xwsJ4Mfl4fqhcSPp7qr8cFlbhTjuYzAuKdwjPhLW5YpYVyhi9Spi9Sli9StiDShiUb12W9fai+3oVU7ws92Ef7UT/FRxXvAaF/jpUt/rWoYf6MlfxF/I8BMO8K9zo/8i/iI3+imOmRYX8F1gX+9GN8U+2A1u8ItjjiVu8It91KVu8Iu+YZkb/B7Cv9ENfrGPepMb/GIf72Y3+MU+6i1u8AcIf7kT/HRRPysYvp7vzBR920on+Nki/q1u8Iv+bZUT/PYi/m1u8ItzNqvd4Bf9c94NftE/r3GDX+z7rHWC31EcI69zgt9ZtJ/b3eAX5yjWu8EvzhdvcINftP+NbvCL9n+HG/yi/d/pBr/YP7nLDX6xf7LJDX6xf3K3G/xi+7jZDX6x/3CPG/xi/2GLG/yi/9zqBr/oP+91gt9V7D/c5wa/6D+3ucEv+s/tbvCL/vN+N/hF//mAG/yi/3zQDX7Rvz3kBr/o3x52g1/0b4+4wS/6n0cL+MHIsbN4w+6ntvuoprW9gCftP1Psy6Vob1d9KStD5vPtdQO7rzhOG4gzn8/5N4GsLubzOT+SB/XD5/Nt3BhB1lYhDstwjMBnjMCnVYjDvl81WPcpYt2hiLVVEUszj/coYm1SxNqiiHWnItYKRSxN3WvWoW01irVOEUvTJjR1r2lfGxSxNOu2pk2sV8TS9NEPKGLVavtIfWq3fatUZ7PAmwLFjWW8eZ8KQxJ+c7ltX3VWWwkX01GYEJTWrJcuX9R/xuJluaVBxAM2HJ+X79ea8hIQNy5GHoKgvGJTMRSLHXguWzNg8mcTApa0mQaNmeu8PkQGjkFlhR3h+YXfqapCOhsnH5z/aA0iJCchDSJIP2Pd6CeTAHwuz1hBP2jDWHaJoFSRGxgWTz+W5ZGn59f0PL/3zcL/1mB4PaKN+wkhLincI/1a2b8MeeNlg3bqphza03HtlPg3BS7rTclOJbuQGrPGYHg5a244ilOukm9rFOIIizYAcjvl6cexPPL0/Jqe5/d+VvjfGgy3abTTRiE//B630x8WrhtD8jO/8DtVVejqktoprAdcT5obqOPWA+LfFLi0u1I9kMpJ8iekuyZB1lYhDid9mgQ+TQKfViEOO6LVYG1VxFqviLVREWtbjWJtUsTaooh1pyLWCkWszYpYmnZfi/qKagcrxbJB01a3K2LdpYilaauaeVyniFWrdfthRayVili0eIj9TMIPglJfCdv7+YXfqarCC2M3zo/ywe9x/k0gq648pb6SpFepT0v6Ge9GP0V5xgvyjBf0Q2U5QYgjLJpr4WMGnn48yyNPz6/peX6PCrMVMG3AMcMEIT/8Hh8zHJwYmjdeNminLsuB8yO5+T3OvylwWW9SkXYh1f/GYHg5K+onFadcubxUls1CHGFNLPzmdsrTT2B55On5NT3P780HO+U2jXbaLOSH3+N2+hKwU142aKdOyiE9GNtOiX9T4LLelOxUsovxgh4bg+HlrKifVJxy5fJSWU4U4giLDt3jdsrTN7M88vT8mp7n984AO+U2jS9NTRTyw+9xO6VD9BpD8jO/8DtVVehol8pSD78r3SzkE+sZ17WeXWdj1zPi3xQMtwsX9awF5AmzA9JdqyBrqxCHNtIq8GkV+LQKcTiuqQZroyLWCkWs9YpYmxWx1ilibVLEukcRS9MmNihirVXE2qaEJfnnauS6T0kuG7YrYmnW7YcVsTR9oWZ93KKIpVmOjyhiadqEpu616nagnEdNm9iqiFWrfkJTrp2hz7SrTdtxutesj3coYmnm8cEalUuzP6GZR1wf4GPLROF/YzC87imOs3MJ4Ef54Pc4/yaQVVee0jhb0muLoFfS3SRB1lYhDsfZkwQ+kwQ+rUIcthnVYG1UxFqhiKWZx02KWFsUsbYrYmnq/mFFrF3lWBnWI4pYmjaxQRFrqyKWpv/apoilqXtNW9XUfa36L01b1bSvexSxNMtR074065Cmfd2niLVOEUszj7Xal9PMo2Z/olbLsVb7cg8qYtVqP0ezj7mrP/HiqEOafkJTLi37stc4r1qNXPfn9bA0da/ZB6C2Fve7Eb4NbufQMrH32OIcmpM9WGXm0KS9dY3BcDtU1E86TjlzeaksJwtxhFV4rXnInjCefhLLI0/Pr+l5fu/YglJaAdMG3BM2WcgPv0f6tXvCjij8aAzJz/zC71R1oRvnQ4kH5831pGh3sT6uwPk3BS7trlQPpHKS/Avprk2QtTUYbjtoD20CnzaBzy6s2sI6VwkryodRvA2NwnPa/pbzo3zwe5x/U+DUL6Sj9Cr5S9LPFDf6Ke5RniLIM0XQD5XlVCGOsOjLubw94umnsDzy9Pyanuf3BqE9msrSYh2YKuSH3+Pt0RV1Q/PGywbt1E05xH/ng/g3BS7rTclOJbuQ6n9jMLycFfWTilOuXF4qy2lCHGFNL/zmdsrTT2V55On5NT3P7y0DO+U2jXY6TcgPv8ftdFHhR0sQXj/j1GeOK/lt1CF/DuuDk/JO51Jx6wPxbwpc1s9SfZgaU6+kn2lO9DMwGMd+uLxUltOFOMLarfCb1weefhrLI0/Pr+l5fm891Aded7A+TBfyw+/x+rAa/DYvG7RTJ+WQSg3GtVPi3xS49JMlO5XsQmr/GoPh5awoTy5OuXJ5qSx3E+IIa0bhN7dTnn46yyNPz6/peX5vG9gpt2l8V283IT/8HrfTzTDexfzML/xOVRVyaaks9fB7U42CrvXwMz2NQnnp4fd1E/7ubvA7CX+mE/zuYvnOcoLfUdTPHm7wBwh/Tzf2U5R/thP8bJbw5zjBzxXln+sEv72Iv5cT/L5i/Z3nBL+naP97u9FPsXz3cYI/2EH4+7rRT1H+/dzIX/T/BzB8zbkIwj/ICX4qS/o4MCiFpJAn4k99kf1Z+kTIf8LCOOLVBFiu+n1S3rj8OO47kMnDdRCGdWCFWI1CnIsyPSAi35x/c4SsmA8b8AyckerEhg2KWGsUse5TwpL6ttXIdauiXNOV5JL6v9VgzVDESiph2YAfA6xGrt2V5LLXM2sUa5Yi1h6KWHsqYs1WxJqjiDVXCcsG/EhTNXLtpSjXvYpyzVOSy17vrYil1XbY630UsfZVxNpPCcsGnDutFSxaQ3Y739Xe43a+K9vrdr6rfcDtfFdH1u18V3uX2/mu9n7qq1N7SDy4bfH2TW9c0R77XVDi3wSy6spTGt/tCfKgfnD/zmxB1lYhDuvobIHPbIFPqxCHe3mrwXpAEWudItZmRaxNilgbFLFWKGLdo4i1URFrW41iadrqnYpYWrqX2u1asVXN+rhdEatW6+P9iliadahWdX+XIpamn9BsazV9tKbuNfVVq/al2TfRLEdN3e8MfuJhJSx7jWPYauRarSjXDCW5NLFsWJXXk2t3Rbm0dG/DWkUsTZvAufRqsJJKWDZo2YQNaxSxblPE0rQvTbm0bLWWfeEERbk0bVWzHDX9aq3qS9NWcW61Vuq2pv96RBFLs/91hyKW5pyCZp9cc6ygOfdI/Xuax57F4hKF/27XAFIjXgOY5UaeyDWAWYJepf2wivIMxClnLi+V5RwhjrDmFn7zvf08/WyWR56eX9Pz/N5rCwXXCpg24N7+OUJ++D3Sr93b/4rk0LzxskE7dVMO8b8BS/ybAqf1Jh1lF3sKepTsgp5tFeKwTz9H4DNH4COVPe59qwZrqyLW+rwe1kZFrG01irVJEWuLItadilgrFLHuVcTSrEOa5fiAItY6RaztiliadVvTvjTrkKZf3Rl0f48ilqaPJl8ovUel2P9ISe85KeIX3zmYG6ELzh/34lC89J+wMI54NQGWct7SUXmLGrvNZfLMYddhWHMrxJLejXNRpnOC8Hxz/m7fBezIuH0XsKPT7buA7YNk8/OYPhOgu32clGV37LNUiH8TyOqqTu0D8qB+cDy0ryBrqxCHe/f2FfjsK/BpFeKw3a4G6wFFrHWKWJsVsTYpYm1QxFqhiHWvItZ9iliauq9VW92uiLVREUvTvjR9zlZFrJ1B9/coYmnmcVuNYmnW7TsVsbR0b69xX26t2Gqt9gE0sXa127vabV/ajl3t9q52e1e7/eLUfa3a6v2KWJr60vQ5mrq/SxFLsw5pttu16qNrtT+hmUfNvq9mOWrqfmfwEw8rYSWC4ftzqsGao4ilNU9ur+cqYdmAe4+rkWuColyrleSyYa0i1holLHu9V6CH9WLXvb3GdyeqwZqhiLW7EpYNmvraW0kuTVu1QbMO1ard12oeX+y+UFMuG17s+tpZ2u28Epa91tzzoKUvez1TUa7bFOXSamtt0LIJbX3VYtthwyOKWJpjvjsUsTTXdDTnATTnJzT35+D7bXxvWKLwXzov3vKZX/idqi4MJIAf5YPf4/ybQFZledJRet1H0Kt03r2iPP0JwOfy7Cfoh8ryACGOsOicTP5+G0+/H8sjT8+v6fkh8Q0v/G8FTBvw/TbprHR+j/Q7xtA/6ofmjZcN2qmbcsjEfr+N+DcFTutNOsoupPov2QU9K5UXtvtxy0vC2qSItU0Ra70i1lZFrAcUsTYqYt1Xo3JtUMRaoYj1sCLWSkWsRxSxNPW1RRFLsz5uV8TStHtNX6hZjncoYmn6HE2buEcRS1P362pUrnsVsTRtQrNvotlua5ZjrfovTfvSrI+16qM1sTTt605FLNI9jVf4+CZR+N8IzyUC1bFeewL4UT74Pc6/CWTVlac01pP0up+g10q+L0ay0jWP43xG+zteNmxVxFqviLVREWtbjWJtUsTaooh1pyLWCkUsrW8j2bBOEUuzPm5XxNK0L019bVbE0rQvzTqk6Vc1bULTr9Zq3dasj5p16AFFLM36uDPY1z2KWJp9AGprWwpxvL/NzyPhcZxPVJ+fP0/pmoXnEoX/jSBfItDsY/fEPq+D+DcJOnHR5z8wpl5JdwcJsrYKcbh35SCBz0ECn1YhDtumarAeUMRap4i1WRFrkyLWBkWsFYpY9ypi3aeIpan7WrXV7YpYGxWxNO1L0+dsVcTaGXR/jyKWZh631SiWZt2+UxFLS/f2Gs/rqBVbrdU+gCZWrbbbmrrX7ANo+mjN/kSt2uqudnvHtWm7+uSVYe3qk+84+9rVL9xx9lWL/UIbNPVVq7Z6vyKWpr40fY6m7u9SxNKsQ5ptR6366Fpt0zTzqNn31SxHTd3vDH7iYSWsRDB8j1M1cq1SlGuOklz2eoIilub6kKa+ZirKtVZJLhvWKGHZ670CPSwtm7AB322uBd1r1m3t+qhVh+z1XCUsGzTr485gX3jeUDVYMxSxdlfCskFTX3sryaXpC23Q9NG1ave1mscXe1urKZcNu/om/rcdNuSVsDT7EzZo6ctea/bJb1OUS6uttUGzfdTUVy22HTY8ooilOadwhyKW5rqV5jyT5vzXBkUsPG9oAotLFP7TPl/u6yyf+YXfqapCOvZ5Q8S/KRjeVunJU9rnOy0YrtcJgl5Jd9MFWVuFOBwbTxf4TBf4tApxuOZbDdZWRaz1ilgbFbG21SjWJkWsLYpYdypirVDEulcRS7MOaZbjA4pY6xSxtitiadZtTfvSlEuzHDXl0vQTmjahWY73KGJp+nv85jn2CeYXfqeqCh0d1DfhfRnqUzUGct9Eh3e6OwH8gkDu1xH/JpBVV55Sv04qN64f7NftJsjaKsRhGe4m8NlN4NMqxGHdrAbrbkUsTbm2KmHZ67GBDpZ2HlcoYt2jiLVNEetORSxNfW1XxHpIEeteRayNiliaut+kiLVBEUszjw8rYq1UxKJ5Puxb2DC/8N80h9nuzmymuzOTGcilegc6uwZ7sl2pbF9Htqe/L53KdmS6B7p6s6lULpvrb08NdPZ0DOR6ezqyg329PV1u+w4dPY2B3L7q4KfThD/DDX6G8Hd3g58l/Jlu8NsJf44b/A7Cn+sGv5Pw93KD3+327IN00f4PcoPfS/gHu8EfIPxD3ODnCP9QN/iDhH+YE/xMivBTbvCL/i3tBr/o3zJu8Iv+LesGv+jf2t3gF/1bhxv8on/rdINfbN+73OAX/We3G/yi/+xxg1/0ny9xg99H+Ie7wS/65yPc4Bf985Fu8Iv++Sgn+Nmifz7aDX7RP893g1/0z8e4wS/652Pd4Bf923Fu8Iv+7Xg3+EX/c4Ib/KL/OdENftH/LHCD30/4J7nBL/q3k93gF/3bKW7wi/7tVCf47UX/c5ob/KL/Od0NftH/nOEGv9g/PNMNfrF/eJYb/KL/PNsNftF/nuMGv9g/PNcNftE/n+cGv+ifz3eDX/TPF7jBL/rnC93gF/3zRW7wi/75Yjf4Rf98iRP8jmL/86Vu8Iv+/2Vu8Iv+/1I3+EX/f5kb/KL/v9wNftH/X+EGv+j/e93gF/1/nxv8ov/vD0qhhJ3N9Zmlio7ezu6+9GBv52Cqr72rO9s72NU10DvQ057r6kgNpPs70/2Z9GB3d29HR29/R086PZjr6RjsLso+IGJXE0rrCjkXekkPFv3CIMNPqMnfXcS/0gl+qlivrnJiNyX5r3ai/4Gi378mULaddCplv6u5qbCRgc53vpblowHKZGHhN30z1Ibr8qU017J4nv5zTS/8t/y2FPg1M10FjI8NlOd6Fzo1ax0J4BcE8j4h4t8EsurKU9onVA/yoH5wn1CDIGsrxNmA68YNAp8GgY+E9Ygi1gpFrHsVsTYqYm1RxNqgiLVJEUszj3cqYtWqfa1TxLpPEWu7IpamfWnqa7MilqZ9adahrYpYmjah6VdpP2FjMLwt1GubO9upreV9dwoUlwuG5ovHDbL0J+RL6TAk4TfP0zibn7YSLqZDeXi/Kcfww/oMNpAex7B4zT4O4Te6wc+S7scFQ3WKeWoM0RXFS/8JC+OIV1MwXO8u+odS3rj8WF/GMXm4DsKwxlWI1SjEuSjTMRH55vybI2SV8oHjG8kfSf1vSt8YIRdP3yLwpmdJh00sTlGHmSgd8rpI/CcwOQdyfTdeedriKwMISdAD6W03SLcgX9ID2uC4EKwAfu8G95IMjwe3Y8Yd2w5QniptB7hucxA3Ur9nA/oG1LkNtqx/DXMLSSFPaENhcwtJFs/T/2Fsid/vC9fjGc8JETybQW6e3oYF+aHpJ7K8JYU0E0BGSv/Xgly2/M4qlJ+kO5KnEZ5/Mdky5alSW+bliLIRJtkOlm1YuSTHlWQ5t60kM/JrjsgH/e4X+JHsrZDWBirjSey+4hxX7G+ZEf8mkFW5HSr2YSaBPKgf8i1Wh+ML1wsX9w4c13v90hsX5upAlS3smsO3Ahyl4Wl5aGUiBSHpsNhtOCs//DkMpMqWYHi1bgVeHD8p3EPX2yrIRmZOujmgYObWbbUWrpsD2YxtaAyG61bRFPrjmibxbwpcusOSabaAPGG6J/04qip9iWB4tUgKPEleKstJQhxhTS785i6Sp+f1hafn1/Q8v7dnwZ5ag+HV+/T8UBmkqs/vkX6tne5WwG0R8jMR8iaVW4uA2yo8jzrk9fja/NC4BiFvFDcmIm5cRFyjkC+Ka2LPXQfPjRcwrQw3jivhhemG2xV1XyTfFOZbw7BOBCz+/CTAmlwG60zA4s9PBqy2MlhnAxZ/vg2wppTBuh6w+PNTAGtqGawbAIs/PxWwppXBWgJY/Hk8Mm56GaylgMWfnw5Yu5XBWgZY/Hk8UnVGGawbAYs/j8e87V4G6ybA4s/jkaozy2DdDFj8eTzmbVYZrFsAiz8/C7D2KIN1NWDx5+nZZgEL+wF7svs7oh9A/JtAVlf9gD2D4Xrl+sFl2NmCrK1CHPqt2QKf2QIfCatNEWuKItZURaxpiljTFbF2U8SaoYi1uyLWTEUs9Fvl2uvz8y/8j2qv6TluuzxdkqWR2miOEdYf4GM2fn+PGPnh91A3e4TwC5OP64bGm1H9jxZ4TpK5tQyfKJkpndRnXpQfGsen2LF/y6eDsR/Op8onQVyjkC/sM/NyxT4z1xvvMzdAfm4p3Hc7HZdKcfsL0xXOS0j/gyDedK005e6aT90o8cH8TFTkw7FOyA/lM/pTfKlcnHxw/q6n+EgXbRG6mOKEd3vs6c4poIs2R7ogWyw3bsMlRWlsJrUlfHr0ytwys0h37PLzeq8cy5Jyt4riNEO6SfB7cohY8yHdFPhN3T+Ug2PxgHJETb9K/CU3QtcNwn0bpGEtTsNKxSad2CZNw06L4NNWJZ82gY/bk3FSjk+uKa3yS1MJPE/EP+qEwbhugHiN1gmAUt6iylk6ATAKK+6pdYTl9rSjUplGnXzI+Vd68iFfLeZ+bmahb2i7da+DpQ7JV7jdPZbtjGuPxH+0dprH3ekiddXp2VaIswG/dCHtOhkj8JGwtipi3a+ItUURa4Mi1gpFLM08apajZh7XK2Jp5vEeRax7FbE2K2JtVMTaroi1SRFL0yY066NmHdK0CU193amItU0RS1P3dyhiaer+PkUsTX1p+sJ1ilia+qpVX6ipL02fszP0mTRtQrPd1tK9vcbT2GvF7jV1f5cilqbda+ZR009o9gE09fWwIlact7GlcT2ll95gkealdpY3WDog3YJ8SQ/oc+K+wdIB95KB/AaLxf41nI6Ab7/Y4HY+NptJAD/MYwD8m0BW5fIvzllJ28OkeU/S3e6CrK1CHH6pWto6trvAp1WIw3a7Gqx7FLHuVcTarIi1URFruyLWJkUsTZvYooi1QhFL0yY09XWnIpamvu5QxNLU1/2KWJq2ukERa2cox/sUsTT1pdkOrVPE0tRXrbZDmvrS9Pea9qXpczTro6ZNaPaZtHRvr3EOplbsXlP3dyliadq9Zh41/USt9r8eVsSiORjpVSJ8hUEaw86I4MOfnxEDSxoPU3rp1aOouR7p1SOae3D0Ck4mqjyk15dGMtdDektDOpzr4b5tZghWAL/TcC9srgf3Ld1TmMgi/TrajyZuNcf9inzPaCvkr9JXbfnzLRF82qrk0ybwcavLyk/RaIW4QRaHrzhwI+anoGBIwm+eX1svLqjghA1eHrkQzAYhbQLiKO0rG0ty9BXkcLvvcPTK5MR8KR0GqUwov1YXuSrLBPe/crml16XjvMYtvYbfKjw/KYLPPlXy2Ufg0yw8lwj5T3zwHvKRZI6abx8pH45Fddjt3H3l9o965vaPe3P5Cd14ih4/XZuvA2GQ6gbpwtaNJ2LUDbfrTaOnQ3zljeuQ120Mkg5JF3F12BIM1yHW7RYhH1K95xgjqfeSDLXWTrRBHC/jKRDHy3gqxPEyxvWqq1lcAuKuYXFjII6f2I4nIS5kcU0Qdx2L42WNoVx79rUK2jNuN3HaM+kIFcJ1+0pZNhvH73P+TSCrrjyldVDpFWHp5E7S3VRB1laIs+G2fCkdxiWFe3URWJsUsbYpYq1XxNqqiPWAItZGRaz7alSuDYpYKxSxHlbEWqmI9Ygilqa+tihiadbH7YpYmnav6Qs1y/EORSzNctT0X5r6ulcRa50ilqa+NOuQZn9CU1+bFbF2+dUd51e1dG+vcR20VuxeU/d3KWJp2r1mHjX9xJ2KWLXaX71VEYv6q/QcH+PzNUvH5xgUvyq6uxv84jkJUWu5nD+O6Sle+k9YGIf7tqe6yVvkvu0oO+Bz43GOCJ1RIdaOPM+E6xrPM5FklfIxRVEncb6AIs0tVVq2UUe2Oq5jxT0FUyL0xPlX8/5IBtLROmFdMLzsdgvBCuB3Bu6F7SloCYaXaWOInMQX76Gt8OcbIvg0VcmnKSaf1ir5tMbk01Yln7aYfHaVz1A+O7J8yA/zM4to3dauudzcJPPkR+rzs5pwzwSlfyv7Gu6KpvA8JiH/3E/QUYRuv8BV+ToZ6nJQyE9CwJLWmChPlX4phr+jh1+KIcywL8WMYfE8/camkiw3zpQxEwyTv6tI+8ooPdXZMUEp3zwNykDpNzEZ6CtCiFkfkq9xIZivYrZ4T5OMGQiYUr6aIF8oQyPIQOnvY/m6hZ21ztPQb24ni/NDZRsv8ApC7qFPGx8SF8W33LP2mn9FCOPQVlBf/PkwnaKtUPpHI2xljCADzy+WK8qAaZpCZHhckIEfW9m/+Prlha/6BBDw42QN8BuLEotgjIATFkgN9plXNck4PB0FND/eFI8TeDSFyMifteqh4h3ILcwty4UoqA7AGkKY1QVycPu1TzfthrS/gvteDFKbQvm1z62cWcLFdBT4O9m7+lUj61chltRfsuHKfCmep38f8yN3zZQx60Iw6TMyUW2atDeJ0ktjxqg+N7dHHKdLvLku0e9OrVDWcvMNjSCrNBaNK+uJoyxrQ4WyNgm8edtjnOvVN+WWnLF4WfEU7UAQI4BrbHcwDbYX40JEnQDpWuA3HquM7n0y/B4vyCcFlFmSJRmUD1RFSVefZlV0c0gVDQK5ipLZ4/CLP8uHX2QSNwrpiOdNkB+envOk9DczPlIX50bIN6X/H6GL0yrIRPI0wvO6zW5XN+nwlmB4oLjlwdC887gVLP3x+VI6DFLTSnmyukhVMFzj5YiyESZvMnjZhpXLd1m54Ic9Ob+bgvB80O+kwA91SfE2UBmvAIz5hd+pqkJHbwL4BUEgTvMT/6ZguG5dTPOvAHlQP5Ibjviw5y3smsNfDHCUhqfl4WImUhCSTir26cJzGEiVDSDzf9io+mfgtnjVx+8RcxmSwj3sbdUL8kt8xlTJZ0xMPj7nB3dT24AfgFwo5BV3U9uAH2tcxOLwA5CLg+H5orjrIzBviMBcEhG3NCJumRBnZbp1QklGbF6kqk5Np1R2YfU6DOtEwOLPrwCslWWw8KOS/PmVgHVrGayzAYs/fytgrSqDhR+V5M+vAqzbymDdAFj8+dsAa3UZLPyoJH9+NWDly2DhRyX583nAWlMGaxlg8efXANbaMlj4UUn+/FrAWlcGCz8qyZ9fB1i3l8HCj0ry528HrPVlsPCjkvz59YC1oQwWflSSP78BsDaWwcIPvfHnNwLWHWWw8MNo/Pk7AOvOCCx7jW878efvBKy7ymDNACz+PD3bLGAlCv+pO7mJ3dfrvqVjv+VC/JtAVl15St3JTcFwvXL94FsudwuytgpxvC3icZzP3QIfCesWRawVilgrFbFuVcRapYh1myLWakWsvCLWGkWstYpY6xSxblfEWq+ItUERa6Mi1h2KWNiWRfXr7TXtkIrq19Nz3J/hdFcSnuHpOUbYuCEZyOOBu2Lkh99D3dwVwi9MPq4bWriudpxir+cA1kjHKfZ6LmBVM045Iz8Ua6TjFHu9F8g10nGKvT4QsEY6TrHXBwFWNeOU5fmhWPx59O3lximXAhZ/vpJxir0+OBiKNdJxir0+BLBGOk6x14cC1kjHKfb6MMAa6TjFXqcAa6TjFHudBqxqxikZwIoap2wqg5UFLP78JsC6uwxWO2Dx5+8GrM1lsDoAiz+/GbDuKYPVCVj8+XsAa0sZrC7A4s9vAaytZbC6AYs/vxWw7i2D1QNY/Pl7Aeu+MlgvASz+/H2AtS0Cy4bj8kOx+PPbAGt7GbkOB7n489sB6/4yWEcAFn/+fsB6oAzWkYDFn38AsB4sg3UUYPHnHwSsh8pgHQ1Y/PmHAOvhMljzAYs//zBgPVIG6xjA4s8/AliPRmDZcGF+KBZ//lHAenkZrJMAiz//csB6LIjO47HBUCz+/GOA9YoyWMcBFn/+FYD1eASWDVflh2Lx5x8HrFeWket4kIs//0rAelUZrBMAiz//KsB6dRmsEwGLP/9qwHpNGawFgMWffw1gvbYM1kmAxZ9/LWC9rgzWyYDFn38dYL2+DNYpgMWffz1gvSECy4Yr80Ox+PNvAKw3lpHrVJCLP/9GwHqiDNZpgMWffwKw3lQG63TA4s+/CbCeLIN1BmDx558ErDeXwToTsPjzbwast5TBOguw+PNvAay3lsE6G7D4828FrKfKYJ0DWPz5pwDr6TJY5wIWf/5pwHpbGazzAIs//zbAensZrPMBiz//dsB6RxmsCwCLP/8OwHpnGawLAYs//07AeqYM1kWAxZ9/BrDeVQbrYsDiz78LsN5dBusSwOLPvxuw3lMG66WAxZ9/D2C9twzWywCLP/9ewHpfGaxLAYs//z7AerYM1mWAxZ+nZ5sFrEThP61zPcfu660rtacTwI/ywe9x/k0gq648pXWu54LheuX6wXWu9wuytgpxOOf4foHP+wU+EtZKRaxbFbFWKWLdpoi1WhErr4i1RhFrrSLWOkWs2xWx1itibVDE2qiIdYci1p2KWJsUse5WxNqsiHWPItYWRaytilj3KmLdp4i1TRFruyLW/YpYDyhiPaiI9ZAi1sOKWI8oYj2qiPVyRazHFLFeoYj1uCLWKxWxXqWI9WpFrNcoYr1WEet1ilivV8R6gyLWGxWxnlDEepMi1pOKWG9WxHqLItZbFbGeUsR6WhHrbYpYb1fEeoci1jsVsZ5RxHqXIta7FbHeo4j1XkUsnHMst0/u8sJ11D45eo7PO+GrmUl4hqfnGGH78JKBvL/u2Rj54fdQN8+G8AuTj+vmisJ1tfv+7HUvYFWz768PsPjzle77mw5Y0r6/FuE53Ce6PIKPDVH7RJdH8Hm2Sj7PCnyk9xQX5YfGLQyG51X66gu++7iIxd0CcYuFfOF7iryO4HuK3AbxPUVuU/ieIrcRfE+Rlzl/T5HexyUdrS7cb4S8Ud2dX/idqjJIX1dEPfJyS4T8D4LhaxM2oH3wL/8kRolP3SjxwfzcosiHYx2ff+G/VH/x+I5K6y9/fnkIFh1tYAP/0uN1LJ6nv7dgyxZ7Kxy1Ie1RX8juLcgHoXmlZ6mOYPs2v/A7VV1IE/4qN/jZqPaR5wl9CtddJfbFeTUBlrbuovLG5Uc75O11nH7ErRViNQpxLsp0ZUS+pTZEklXKR1jd5HyiTkFeFSEXTx/VfyId8j6Mog4zUTqU+mAjOQWZ9DYT0pHfqQuG2+CtIVgB/J4J95JB9CnIvEwbQ+QkvuX8OH8e+2HLQS7pP/HBe8hHkpn48PMs+Km0T8HZDGR3/Mgc/h7Vbiyep69vK2G+vYApvecVVlcSjB8/C4PKHuULO2rpuhD53s3aPTzR8johz7tFyFzMczCcrw107gfK8Bz0Ix21kWI/kni1gLxYPpgXqUzQ7m4W9BCmWxt4P4X3Y3j6j1TYT+H2jf0ULhM9K4358TRGiU9UO9kk8Km2fyDxkWTGsZsNvJ5/Fuo52QO3ef4snYfQAOn/MLmE+YWIeo77h7BPg74P6znxC6vnaDeU/ssR9VzqM5+VD5eZMHk95zJjPaf034B67qhfI9Zz4iW1Y1jPK23HJD8u8RlfJZ/xAh/X7eV44LNSkQ/HwnOYwurrT6G+UrlK9RXbbZ7+/ay+/gLqK7f3qPLEtmOlwBfrTBDEm6OMejcZfZQNUW1H0UdFtB1RYwAbosa4UXPCPB1PEzVvmozgwe2J36c+K2/TroO0t0LalRFpw8Zz9ppOX3Y75u7KUV3gc78UKG61IDPF5Vn6C/KldBiS8JvnydrKthgnOktjw9UhmKhTG/D0d8pznYC7CnC5D0B90XlrWP8nFzJj6//YZhkP7cSGSwp4bseVXYNYvjxg+aJ+MEjlS3Lb8v1IBeXLyzAPcdxn4xl/vI0kDKv7WQWmtVqXRlJfPlJlfZH0iWsRXJ+EwfXZABhHM3vfE+yd0mB7YQPVH6qzpL964XkbsO9H6fcq8LT6mThL5h9V34JA9gtcD3jW6OpAlkXKM6U9Auwxz57Rs8f2NJXjGpCZ817riHec/hrn3yzIQ3I3CXH1Vcjake7qynS2D3QM9nV2d3TkEoBPsuI9nDtcJ6RvEdKTrm93ouvsAFW1ZL6Ev47p1YZ6FrcW4hpYHMlo69CkWUPlX+dI/jj65/xbhfQn5kvpKinLVoEPjtWqwVo5QqzJwdA6ILWFvG+DbSHvv/DzYF8a4pfj+Drybej3eT7RD14Evo63f4o21C71R9HXrXHEO66vI/7NQXjZNglx1fi6gY72dPtgT0ffwGA2N9A1mAiGtwlJ4R76OsluJwrpHfuKlOTr0J/Vs7g1EMd9Hcko+To37WI2FUf/nH+rkB59XdyybBX4oK+rBmvlCLHI1+XZ89hP5b4O+6mrhPxwX4fjssvAJ7n5pIM8R4g+lctrAx9Dr2J6Qv0iDr/H+838GZyzofSDrN/e3yzLR3k4XZBP2rvE83VVc3i6VUI6O4VE/agrc8vOvap3SW7g3Fz/ktyyZCCLh1nE7ONwKoB0NuCXy5bA7+vg90LAoSY47pfL6D/HkoqOY2PTu5ANeWaBC7sOeM0v/E9VGaShIza1bpbXMrGHFcS/KRhuci62dUhTm1w/2Dy6WZbIpOyHm3DJwIZr8sN1g3KQvUhLd1x/WBfiLFMuFPg0B3K9kv4TH7yHfCSZ6XeUqw1zjXcz17iquZQefU2cLVtxluL5PZ5+EOL4El0iAh+nW9Yxf3ELTCHxLhXlo/hxUhanWZ+tHLNnleRAu+XdtbB6Jn0uhNJHbSWzgZY0orYWSbbFbYlsRCrnqDrlYulf4tNcJZ9mgY/rutsMfMKW6h4KqZNhS3WHsXie/q1sqe5RKM8w3/V8vvKluFGqM5lK64zkp6LqTLlXN0iH0hLrRfmhcZK9o15tGMwPlWGhIIPUnrYKz1O6OP0ULp9eGaVj91OI/2j1U66LqVfSz3I3+klF2eZyQT+4NQDLjvtuXvel4Y+03MfbCRwuPlOo7FFbCqLqjrQE//z2PxgWue4HYd1KMhlTDIs+j+R62wf3l1geirbfTvleFZFv5G+JLwNJ220xPY55EB9fkaLn+YffJdtCe/wU65N+tFnGDILoPinqZEwgt5e47E3pPyH0I6Uy5suGn4J2lesStxrdKujh+a10Mdp7aRkf2/slfCsdyCX5H6lfhX34SvtVEh/EirtFkNJ/lZULfnC53GfR4myN57oleSTdhG3DoLphA/kZrDthdsnrxtmQf0r/HZb/s+Drobz+hW0HCnulkfuMqFcoUf46dq9V4C8ti1iaX/idqjKgL6tnPFYL8uDyzc+gvq0Jhuq0nE/MC3zXsDStwDcPfG05dswaikmyjQ+G1zOpTK4DHijnlRBP6X/D/OyvoK0O29L/p2aZd1Mg22FYPeGy8nq4Ij80ntL/gemrO2RswOWRZJXqKP8Ie6V19EyQldL/LaKORtmS1KfDrTxSHUW5E3A/rl0U8zaxlO9/R/ThuF1MnDhUBtxSWM4/YN9hfuF3qsqAZcnrqeQvsSzHQb7yhftJIa9Sma4W+OZZGvQPq4Gv5B/4K30kx1UMM8yOGwSZbcA6R+knMBmwzl0n5FmyA6mNjXqlg78yLaXHvFD6yUzWqHk/6g+4ncNIi/N+vO405IfmW/pMsNS3Qj0FIXqivktrUN4n821c0niJjuPHtZn9mJ+YNXFoXqPmJBwtR/YkgB/pht/j/EdrTqLSsl0uyE/zP1J6qY5Jcx527QTncLlPJr781fBVcE+ap8D5qLCxzUHgG6Q5MG53NJZDnjYM5mWeHJfzlOY60U9WMidXTgeS/cexT4lP1NrSzYp8pO2wUWPGMHvFe1FzN9wfo29yMUdyG5MzznhnNctDnP6t9MqptD0Z6259iO5wjoTSL2K+9yioV1F5tIGPS1EmaeyK8wCFqCFt9HIBH8c8x7E2utzrczwfNuB8AKU/kWHifECePR/H764R0udZGpJHqhNr4Lk1LA7LXMLm6ZMhOHnAwXyG9bUJQ9q6Zml+4XeqykB4tLWL93nXCfI0QPrzwI7XB0N1GqUzS7cLfPkx2djXvh34Sn1tko2PxXm550EGXJdGOXHMRekvYfX5IuhL8fadt6dXTJR583HB2ghZ1wiy5hkvHBdQ+ssixgXSnCeXVeqTU53cEX1y7rca8kP1k2dxceYT1wjp8ywN+Q9pa+EqiONtfpwjQOK0MWNC0qPNUvqFwpgq6nVdi78I+lucD+4HuJnlIaqdwrLiz1qeSybKuLwt4Tq7Oj80v5S+n82Z3wh1MGw+7OaQOigdcWHDicC7eCwJ470CdCitKUWt3SeEuDj92eti8lkewieIyUfKj2a/WZqvnwwyV7qWwZ8frT0ik4HPrQIfx/3m2GNq4t8UDK/3LsbUUcdCcr1Semm+ZGVEeul4R+noKT6m5j48AL58TL0a7kn1HOcRKx1jRe3zktY/y/m5Byv0c0vzpXie/reTSpiPgJ+rtX1lbVXyaRP4uPYZbZCf5RH5qdSm+POjdXRGG/AJ2yf35pD1h0qPoPlvZp9PjdA+o467GK1jUlzM0ewM+Xkx15GPK9WRD7A68kmoI9J+tKjjTkaq57h8XgzleasiH2luvpzdfC1kTS+u3VD61zO7+WYMu5F0E3ZUJuc7WvYWhRXVt5T2KUXNS0atofL0VI68r0u24Pb15Pj7gYl/E8iqK09pnJAPhuvuNkF3E4LS3FRvbmk60318rn/J8uuXYWEQYGswVMmrAZDSB/Abn7NC1UOa5QIPG/h5ctyQWuF5HIggfhyZyqUtFy9VwttC8hkE8Sohfz6sEoad54XnmBQHJGySK855Xtx4aIEyznleYQ4kKeShKeQ51D024FwmKc+U/i8Reb61TJ5PhDyHnZfLf2M6afPMuECeYI9aiJwSDJW9Unviz49W4z4F+IQ1unUtpWe4HsJe/LmaxfP021ij21DArPSMPjyHr1I9S3xc6xnPYr01Ij+VnjMunesdVU5XszRhm7PqBUwb8MVoSj+lUJaOz+YW3/EnXmjDPH/W3qYp2fB6ZsMzwIalia7RmlCrpK4kgpHXldHKTxSWVB8SIDNP73WHNp1LxfFBnL/3HdrvJYYqOW6HFp+L6tBiWnSGZEjVdmglmcLSVtqh5TNJ2KGtdIaYP89XwXmF0DWkzLA3E/nqK69MOLO3guVB6qiFzconQvDRUfLDXSTd4U4oSt9ZaBBsB/Lwwuq+VFZTQ+QLgnhlxZ8frdn8qcDHxW4/G/Atz3K2cRjIFdaJPRY6ANIHIKSVZfy4QQfrAJwAHQBpljhq1SjOaRXSjl2pgZI6nmG7HMrZNeqoXsC0IewDEL3QIXRzQk1HasetRnfEbpTx4CbprZsmIa6qQze7BtOpzs6u7GCmtzvX0YltF8mK9+KsVO8hpHc7o9cuHrrJO/421LO4VRDXwOL4ijceROemw9Q+EEf/nH+rkJ5PplRSlppYdHhc1BtfuOPJhqgPtlH6AdZ2xvkQynIhP1Ef6EjCb/Rl6KtsmF/4X66EB8uEAPQ2VpAF35CjtNcyvRw1a2hepEPqyHckI3gEwr1EEK475JEU8E7OD427NYZs0oQdx7g5RE6LIQ26Z0FeKp1MmSXI43Lli/Ms139ZAf2Xcitft+RL8Tz9PNZ/WQX9F2k3DvbDEoHcd0Cfwt/EkyaE0Q9Q+rXM3st9wIrnE2XkmHE/YEXpN0L/xdGONnFCi3iN1slwiFUflHatc/94Sn6orij9WYVBqS3nzS2VYZ4agvm+lhLm1goxTwvBfJJhbouw+2nBUH6V7ijlz+OpKzgOnV/4naouFD8WutgNfvHDkosEXfA8EX/Jl1XiMzmv0XozUspbVDnzj0BjXZKwFlWI1SjEuSjT6yLyzfk3R8gq5QP7FRKfaYJOKP31EXLx9FSHue3Ts6RD/nFtRR1mosr7esaT+NuJ0Eo/Fkp6mw7pqC2tC4brfnEIVgC/p8O9ZCB/LNT6zI8V/LzULk0IkZlkKNcu8efR/t34zK4+smfsE9uAfT6UEUMSfnO5nz8tuK2Ei+k4BtoxfkwwyueGYUhzn+XqvQ188p4WipcuW7wkd9aSq2/qXZY74abcomWC/Y6D/KHd4UnPiyEtn8/k6XBxdhH8Xgq/lwnyYECd8NAspAsL5erHfux6JPWDPx81rzi7Sj6zBT5RWPsJWFH+e7aQfmfx3/MgHY3tqvHf8+BemP9GWfj4iTbR8DqGfedvw3jITZ+kJ9scDPdplBfifb0j3gngFwRyv5T4NwvykNxNQlw187mZ7mw63W2WgnOp9lTvQCqqjvF7WCdvENIfIKQnXS8NnOha/LDIDUyvNtSzuOshroHFkYzSfK4bv9ETS/+cf6uQHudL4palhHXiCLFoPpf7Xqrbbut65f0vfDsz6kRLvm7B554xSP02yq+1pwti9Ntw3ZXL7XZcPno65LaKQdIh5bdSHXJbQx26qcujp0NeRzFIOqT8Wh3mKtAhtzWcw+a+ieSuNf0mII6vQ52QL6XDUE6H8yvQoTQPngyG62mhgIXjkH5BHsrnsmCo/Lz8bMB1Lf78MsC6uQwWbpbmz8d5c45jnQlYUfsXVpbBOhuwot6UubUM1vWAFXUa4qoyWDcAVtTJTLeVwVoCWGEn31paXQZrKWDx5/G0jXwZrGWAxZ/PA9aaMlg3AhZ/fg1grS2DdRNg8efXhjzH/ZsNzcI9qutuPzyXrviDrNJ4wcUct6R3qV9IulsnyNoqxPF2m8dxPusEPhLWdYpYKxSxblDEWqaIdbMi1nJFrJWKWLcqYq1SxLpNEWu1IlZeEWuNItZiRSyaR5bmQa8HPpXOg/Ln48yDSj50QlBaM3h+3vy43uuX3rgwF0BIsmviwX8vDeHfKjwfRGDxZ6LyEvUFC/LzYV+wwD0dlH5BgTE/vatReF5x3NFDbRjvy1KgOGwfeBzvt56QHxp3q5DnhMBHGpNQfq0uVsLp0IGAJa0tcJvYE/KwFPjjPbR1/jylk/jMrpLPbIFPFNaeAhall8YUUWsL0j4yx1/CKa4tSGM8aVwykrUF0ttMSIdrC9JYD7EC+D0T7pVbWyBZwl4AxrUFSr+kYNuNgqx65dGdjXpvwe0+9e7YawvEv1mQB08Kx/2Q80co62B3JtWfHcylOrJ9ff2pgag6VulJEvOE9G731HWLawt8HsyGeha3EuIaWBw/cRzXFtz4je5UHP1z/q1Cemy345alJhatLXDfS3XbbV2v3bUFviehknlx3l7iIQRch/uwax5H8uA9LPd9BFmbhecSIf+JD95DPpLMuI5iA9//vK619Ay3K77/mT97c74Uz9NPYvufN0Ts2cAxOtoqtw0bsJ7wU2HjtIeUfhPrK+P+Z+ndipvz4TITj7jvb1H6rdAmu2kX5f3PxCvqpDvURxCUyiTq3TjpHTy3eezqR3/Dg+RvcA8tn2PAvQd8zuAGiMuzOJzXW8PiEhDH50SXQhwff6+AuNtZ3HUQt57FcRvFIPlMfijL1yrwmdKXenBMyPUr7UPal13zOJIV76G98ecXhzyHfsTxnqe04zpd3FcsvbPF84R9XWmePk77wnmN1jy6lLeovRp8ngHnkSWsFRViNQpxLsr0hoh8Sz5BklXKB84LSvVsX0EnlH5lhFw8vXTY0GjPB0g61JoPIL0dBOmo31EXDLfBFSFYAfw+CO6FzQdIfvS6EDmJbzk/GvcdE95f/FCrzDPu+/6U/m/s/aaPsmuck+NY1wZD465lcbcUrh3vr+qS5jsC0N0tjDeOgZYL+YnbZvM9VKkR7qHisnFMXn43sTRhc89fZP3pG2fKmIlAHkNgn55sIu47jZT+KxF9ekpTH5KvRSGYv2S2+PUQWw8ETClf10O+UIbFIAOl/7Ywrx8Ew/0vtyEbFueHynaDwCsIuYdtzg0hcVF8yz1rr29k1xiHtoL6skTrU2E6RVuh9D+OsBXpXY6oPaUoA6a5PkSGnwsy2PZofCG+f/H1y0OWs+rZNbpnqSixCK4TcMICqcFmj6oD4tDvKPOTtr/yZ68PkZE/y8+4GsgtzC0LW++rA7CFIczqAjm4fS+qc1Dag09B2keI7Qavy9dC3BIWx30vBqlNofxWsm62aewL16PVJ4nT17Dhynwpnqf/N6t3+AW5xUwOCZN/PRorVtTcCKUvN14j/qRLqd8fxVva10jpV1Yoq7TWwPvQN4CsUYdklpP1xFGWdXGFskr7GLivNs7o6ptyS85YvCzHqweKEcB1I9zDNLjN9foQUSdAOpxGxiNGsH3A1/yWCPJJAWWWZEkG5QOeVzyxMH1sq+jmkCoaBNHbKaRtxrxr+SEYWkhLKFHmGNWFlc495Rh4bAiln8byja4p7kd/Kb20XZZPgeIUMK8GeOwTX+bjU7o21LM4xaH8gPTxPq6Dhnz8/Er6kbYAS8cztkJ6ritpqQWnQXkTxs/KXQf2Jx1ZFpW3qC1E/BzwpIBxdb4Uz9PvH2F/eUEG6bxZSr9GSJ9naXBKmOuXnpXsj79SYUM9i1O0v5xkf/lSlobZX1R+Jf1I24TXsDT4QXe+ZLAa4ri95IOhMnP/RzrnRx1Jy7iJkP8kK96LWto+PT+Uj6uPm9AyG/pLqStnrw8rXFNXn+tec/kN6w+fglgjyDPsI8qThuZrHdOP5NcPC4amXyvw5UtMC4HvWuDLP5KLU8428OnAE0DWPMPGafeoPPey5eOTCtdR3Uw8GvNUJvsxs8KfxzaQ99Wug7iwo9a4/nk+uW2iv6X0ZzM5j2c6toH7PD59bkM9i1O01cFK29w8i4vT5q4R0udZGmxXef3A4Y80lOI6Dxv+hH0Ulx9Vy9O/jJURfhSXt+34Qd+bK5Q9bh92BcsHHrebF3BXRcixhmFJ6QkPPwidE3SCmLwu5Bnm6hDMqxjm1goxrw7BvDaiPyO1v9K56uh3eXreJucL19LrVOsgLs/isN1dy/hj2muAP49bEwwNKHOYvNhml5MXfS7FrWU++6bCtfQBehdLplJZ7i/kJ25ZrojIP2Lx9hXtVapDawV9rZokYzZUiJkX2j2pr7QoX+K9NqTNtgHbbBvQN60Q5OJ9AWl8g8uAJNsdQn3dYWOAdC4ltYdcj9geSuO0qO9olBuD4hiAp1+YHxoX9a0QaXosbnvDjxidBkc6Rn1TJGq+wl7vBukp39zHc5vJsXie/qEIHy/pV9r2EWX7fFyKx4bysqJno7ZG7wh7jeq/SfpZVYV+0F7zLA6P3eb2gq8LatlrHdir5IOkssT6E7eeop7GhKTHPhClf3OMfhWXIepVgbjzC1IbtzaQefO6yXWCHwCl9G+vJX+eSqel+sH1ivUjSoc2VNpHxHkb3pfIQxyvH2sgTpqrjeN3bYiqO/Qs/wisNDYOOwK6HE+UURovS76e0n80wtdLbW+Ury9Xp/EVAO476NkdN1aXbZnrII6vjxrv5IX0cX09joWlrcDlfPfHI+wPl5Xjfl8sylZWCXmrdG1kR5b9aK6NhPVLUVdcJxxL8g1RcyrV9jdtwG/plutv4twkpf9hhf3NKDvMC+m96W+OwA5rrb8p+SA+T/jmCB+EfT7J/qL6Z+V8EH6+SvJBSUEu3hZLr4HaML/wP1VliFrTcfyd0o4E8CN98Hucf5OgR0V50lHlKs0BuP2cU6rduilpPe6a/HDdhPkd9OG0lmbD2QyHbBW3NdvA14f+A3NNUj+QP0s8sB/YMLmEWTd5KKZ0rBr3wdj/lY5Vs7gPQt3nOsH+h1TmUf3l1YyPlJ63TTx9UyGv0vgwL8gQNfe0RkifF2SOWp9H3tJ+A6ktpfStLD87fnyYSe/oNX9ss6LGjtwG88BHaouk12il1xD4GBDr63KWL6lu4TGD0uvfYTLaQOukWC+xTkh5oiP7sL82V7AxrIcBw5zE7lXaH4maU8oH5XlHvepMz48R0nM8rGP7x/AZYfM6qFNKf1CETtcEw/MVpdNydYLkiTNPVU6nuM2U+MTVKaXPROh0DXsmjk4pfUeETiUdRel0nZBe8iVRa5VxdYpboolPXJ1S+iMidMrXi+LolNIfvQN1yvO8Dp7jPgP7x+jvmkKea43AzIdg0n3+XNTRplJZSj4Ny/LkiLKU8pWPma81SvlaU2G+KP2ZjvK1PCRfyyvMV75MvnDdldKfHyNf0jyJDTj3T+kvitm325FzFaM5X4pzonkWtxzipD2bUTYxkvHNzTC+4emwrybtZ+dyoA1Q+itj2sDo7CmXbSBqPV/qR0eNqcrN6WA5S8ccSTaAc6rSkSxx+/f8yJwlE4em4/IkQv4TT7xXFyNvWLf4OILrlcYRtbA3l8uDfnMVzD3wdl7qp5wNeii3Nxf3Wq0FvtLe3LC5l9Uga55hx5l7ofT3sbmXtYVrqc+D+2fD+jxhbQy3h7A2ZmNM/0Jy1Vobk2dxcdqYNUL6PEsTtX8W+wpSOyLtn5XmG3ANT1qXsfbx2eby8of1g7i9jwmi+4NYPx6I6M/wvXXSeDMVgvkos/uHJw/Nfz4oBdqXZdO9ZrIO71dEjGOkcUnUmtPtQnruc0ieFpCBP4v5xrJ6DfgFnkes+/Qc7zfz9Nhv5nF5dl1uPLBWyCPqcExIesJrgPRvEuysVchnHvjlBfnitt95JuvqGP6XeEZ9+t0GtJOovo+9xjVyPn/N19eefz5fihsdX5zJ7Oi+Hq5NcnvAY/slXxx3jRw/PyQdt2Nt5aFCYWAf/YPMhnHfvdTvl9bUEfMjEf5K0luUHcbdiyDNOa+OeE5aJ+W85hf+p1KDVQXily/gjRVkCZu7/TTT41GzZFkTw+StLkSNBRoD2e/q8M6kEsAvCIaPNTj/JkGXLtZ08yAP6gfXdNc4kSc9yNd0uf3yNd08483l4HvW0N/xccKXoc8i+QDu5w5l8Tz9N1l/6WshmEEQ7e/K7RH76YShuK7mbCTfkoe4qHWgPItD309lFPZuU47F8/Q/ZL4h6t1Bksvt3vPBHb63Nl+4jvNpG8n+8uwerr1J6/V5AR/X638d0T+M2t+7skLZVwmyYz3HuvNl6Dtyniti8Kxmf+9uLJ6n/+so9ht27e8dnn6k+3u5vcTd3/vZgu+W3suO83lDac47qs3i9j2DxfP0jYVj2Gr5/BXSk2P7y+zoPcZUvnHOX4na2yl9lsba31MF+3Opx67uVLFPS2XIj5XnoZ7F8/QzCzbZxPJB/6v6JElXb3ow2zvY29E7MNDe34vHxNtAZWaPubL2MK2tpDPSk7bObCD8Bjf4xfeG61lek0KeiD/ZUh1Lnwj5HwTymIV4NQGWct7SUXnj8uN6TT3IQ9dhWPUVYjWGxM3XyXexTJMR+Ub+YemlOkD3x0Tg8/Tk17kNjwFdjHWji0xUuY1hPIn/SI7Bpt+zIB1+FovruyEEK4Dfs+BeMpCPwUa/1BwMzzc949inZOL6AeLfFDitD0U/0ADyhNVdfpzhwsW9A4WTVdHlYdFxdXI4zDYWXbFZhHtoDnXwHHX1pCYU5UwIGJIKCLMlGCoDf1ZyJckQvkFQMld0H+Ww6DoZIUsYRgIwmiMwdlWdXVVHCLuqTryqo90bz3R3d/Zk+lLtXQP9gwPt2XK9cW3+/X2dfe25vv7OdHtntj01UMloAHsbfNSdFPTXAOkvYaNuXIGqi8C0AU9SpfSXRozkpV6RlM84boDL0xIMtyscQYyWPXX1dvf19Pe097Z3pvpTXZ0jKU8p31z3N+WHpqee5ZggejTVAOmvYWWFuzXGsGcI65b8cEyUmZcP77Hjx9go/SImwwKY9eB6wCaR96YVm6D+BPALArlJJP5NgdMmOo3lQfKgfnAlzNEIpy8B+FyesYJ+qCzHCXGERTNB3Nfw9GNZHnl6fk3P83u3FmyrFTBtoNNRE0JcUrhH+n3+lDXouvGySYT8J1y8hyN4rhv0Ydx/8pXDNSH+g+uTP0v+A+vitrYS5u2Fa6l/geWHPjmqn8D5hfkrbK8o/Z3MV+DHQ7C94vlEGTm/eoGvDeivKP09MBPnqN6LH48kXlJ7lwhkfQRBvFkoqX1sFviQvsYH0TMtUX4iasaL6tyYkPSE1wDpH4poy8axZ5KCXNiXofSPRvRlGoV8SfWa7jcJ6RuFfLUEw/0fPSutSpDuHZ9Q2y+tSnAdNuTL62dsFfohG2iF9FxXkg8dC3zKDS1xFVeaReM+l/ffWgT+mE+pPowR8hlVH6T8oe0+VWHfjn9od2yIDHH7dpT+HUyGUyL6drwte6YtWlb0N3zsw9M/x9qy90D5oM+xQfKDSYjjZUk64n5wjIAr1We0Camu8PTY1ybbHxOSnvenePqPRNhEE3tG6l9in4HSfzzCR44PhueLj2NQDxOE9OOD4XpoCYb7gAmBzJvnh+sZP6BN6T8j5Efyu3xFwYZ6Fqfod8WvcXC9ot+N0qENqPNmIT3XJeWvFdJz/Ut1ZzzEcb7jQIZyYxv0yVJ/g/sOaXqV64DkbBTyq1d2/ekE8KP88Xucf1Mw3OZdjCXj2gjpp9mNflJRNtgs6IfkmehEnlSWbKVV4E2y0pvq3K/w9M1Mhzw9v6bn+b1fgb22sOcIvxXibMBxLI9LCvfqdhBWq4DF9UZlauvxD0AX+GUr6T/h4j2UkZcn2XyUjxgpH45F/RupPlmaX/idqipkM5SPiUI+iDe3K72609EV19cR/6bAaV1OR9kw1w+OdVsFWVuD4Ta8Kl9KV86+OR8Ja3uNYm1UxLpHEeteRSxNfW1SxNqiiHWnItYKRSzNPG5VxNKUa70ilmZ91CzHDYpYmnVomyKWZjlq2uoDilia9nWfItZDiliadl+rPkczjw8rYq1UxHpEEUtTX5p9E0370uznaPoJTbvXzKNmO7ROEWuzItbO0JerVbvX7JvsatMqw1qviFWr+tK0e82+nKYv1CxHTX3Vav/rVkWsWu1/3aGIpVm3NeuQpr402yHNOlSrutf0X5rzcrU6N6RpX5p931rtY9Zi22Gvcc1Ko+2Q1nr5HsVGQQ7N9V7Cn+wIn3Q1KUJXnD+u/VK89J+wMI54NQGWct7SUXmLWiPm6+FcB2FYkyrEahTiXJRpa0S+Of/mCFmlfDQr6qRBEQv3tkl7NqR1VUo/WUgv2UmLwJuepbJtY3GKZZuJKlvuI4j/SN7eJr1dAOnoaw51wfC6MSkEK4DfF8C9JMPjoSUYbmvjQuQkvngPbYU/3wxy0G/a88L3wC7Ov/B/x+1d6MzG9a0vlr0Lq/OldNW25Q8qYmnOnWv2h9crYmn2FTXzqLmGW6vrKbU693S3ItbOYBO71hp2nO419aU5V6eZR815hlpdK9Wce9K0+7sUsWp1Hl7TJnb1v14cPlqzrV2riLUz+MJaXcu6XRHrfkUszTqkqS/NNm3X+kBlWDvDur5mHarVPWG72o4XR9uxax/EjrOJXXMKOy6Pmu8K1Op4SFP3mvuca3W+ULOfs8tP7Lj+xC4/seN0X6t+gvpfhEfrntJaM51J0CzgJAr/3e4fyfYlgB/lmd/j/JtAVl15ovfxSGVAupssyNoKcTbk86V0GJcU7tVFYK1TxNqkiLVZEWujItYGRawViljbFbG2KmJp5nG9IpZmHu9RxLpXEet+RSxN+9Ksj5r2pekLNeXaooilafc7g03cpYilaV/bFLE086ip+zsUsTTt/j5FrF1+4sXhJzTz+JAilmZ/olZ1/7Ai1q46VBnWWkWsXXVox+lec+yuOUZ+JAYW/6bEgkL6qHdeCKutDNaJgMWfbwOsKWWwzgQs/jw92yxgJQr/aQ5tKruvOGcV+7NlxL8JZFWWpziHNjUYrleuH5xDmybI2irEtYXoNVDUaSPwVcRuJ+zp+tjFdzh3U8fOdlA58W8T8LPqp08rlZEl6Ttc/IzyOhbP0988rYS5e+Eav1sVBMPrVx27r2fPmVTc+kX8m0BWV/WrDuRB/WD9SgqytkKcDbflS+kwLinci8LapIi1TRFrvSLWVkWsBxSxNipi3Vejcm1QxFqhiLWuRuXaroilafeacmnqfrMilmY5aur+DkUszTw+rIi1UhHrEUUsTX1tUcSq1bqt2XZQf0L6fhx9F0H6RtJ44Cd9v80Gx9/mTBP+ODf4xbM9yn2ji/hHfacU/xMWxhGv0fqOqJQ36TuirZAedRCGNbZCLMffKy2WadQ3hjj/5ghZpXzg99oq/cbxuAi5ePoWgTc9Szrk38tT1GEmSofSd8dGci4K6W02pFuQL+kBbXBsCFYAv2fDvSTD4yHqW9HStzCJL/8G3AwWj2eqzGC8ksI9rC/8+RkhWNJcgw1X5kvxPP2qwvyC9L223QX5omx3ppB+d5aG5JF0MzPGczY0C7xIJrL7Wey+ot23x/XhxL8JZHXlw2eBPKgftNk9BFlbhTg+X8vjOJ89BD4SVlIRi2yjJRhuKzOBj2TDu0fwmSnwIbuaDfmZX/idqipkUlQuc4LhgeLmsnuP5ktyYEjCby63reOns28HYjrkyfU6F+J4HdsL4nhZzYO4PVnc3oXrlmC4fjlvHkd5xHtYjvz52RF8ZlXJZ5bApzmQ2xnpP/HBe8hH0g2WkwYfrrdZwGeWIh+utz2Azx6KfLgt7gl8wr6f/haYx6fnwr6fTutjDZA+N7OE+XQBk3zJXCaXoi8pfvNtr2B4oLh5jDfa7N4sDu1sHxaHtrEvi+M6xyD5J9KF9U+LKvBPc1gc5YnKgJ5/orAQZMvguWlD09C7AR9h6y0fgPUWXrfou8ZSfcB3CfYQ4iz++buVZOZ5t/ZEtsW/S4u2Rem/DfZE5a1rT51daDPEg/Pe2xHvOHWe85dsmORuEuLqq5B1sL87lU11dg7kOtv7OtoHE4BPsuI97DPvI6SXzvQjXe/rRtcZ6ZvG+zC92lDP4vaGuAYWRzLa+jxp1lD593Ekfxz9c/6tQvozWR4qKUuXWNwfaGCNHSHW5GB420E+h/pVc1ncFOAzV+AzN0Jm/jylc+vrMlnJ11GQfAuXEYPUzpHctl5srKCd43rdG3Qxz40u2jG/ki54Xcbzjbmfmgxx+7G4uRC3P4vjczsYJP2SLqx+t1SgX25PlCe3/irTiXoKBLm4nuaw6zi62Ifp4vQ9SriYDnlye9oP4rjtUzm5bZcyXaiLQJCZ2wza4QEsDu3wQBaHdngQi6vUDnn7V4kdclvjecJ+It3jfuqc/Av/sZ84trDJyuahYfpQfnxMSbxtutWQbl9Bbip3bqM7Yq6N+DcFLu2wNNe2H8iD+sG5tv0FWVuFOL6/j8dxPvsLfCSsBkUssouWYLiN7gt8pL7sPhF89hX4kF3xuqnoT/qwfvNAcQeze5XOtZHclc61cb0eDHG8jh0CcbysDoU47vsOK1y3BMP1y3nzOMoj3sNy5M8fGMFnvyr57CfwaRaeS4T8Jz54D/lIusFy0uDD9YZt7X6KfLje9gc++yvy4bZ4APCZy57jc23Z6aVn+HN8ro0/i/MhlP5hNs/TWcBsDIbXgx3lSySbPYTFoZ0dyuLQNg5jcVznGCT/RLqodK6N+2qeJy573L4JpT8eyslRXyI1GfIl6VSq17Xax3EzJonu40jteKV9nOnsGn1Ppf2SvRWxyLZbgiC0X5KAOM5n3wg+Un9pZ+3jSD5ktPo42FettO/Bn3+x9XH2BT77KvLhettZ+zjXK/Vx7mR9nKXQdjqap1Lt46Cduerj8LmvRSOcZ0X/xOdKKB2fK0kE8fpC5+Vf+I99odvZPM3a6eFyzWa8/7lrngbDTjtPE7XHBdu+Sve47Cvw2Vn7MFyvo92H4bx5HOWxXN+CP/9i68OM1t6rF3sfho/zeB/m6Rh9GP5sWB9mOevDvMPDeRq0M5/maUj2uH0TSv/hGpqnkeq127Xw+H0c3GvkZr9wqY8zD+QJa8el9omelXwPztNIfan9BD4S1t6KWDhPI+1jjNLNvAg+/HlKR3bF666iX+rB9p8Hqb2stI9Dclfax+F6RV/Iy/MgiKt0fqclGK5fzpvHUR7xHpYjf37/CD7Vzh9KeyFct9XzgM88RT5cb2H7KTX4cL3tqHmnsD7Or6GPQ8/F7eNQ+qtZH+d3ozNPU5EvkWyW73dBO+P9CLQNaX4nrn8a6TyNNI6JO1dC5cD7ZnrlkC2+y5MKhgeKSzPe/IwvDJLOSG6rs/F7lnAxHfLk9TsNcbxOZiCO22sW4nh5t0Mc9/cdEMd9WifE8TFAF8Rx++2GOG6/PRDH7fclEMft93CI4337IwrXZD8pFqdoP2m0ER4oLsN4Y13Nsjisq+0sjpcrBsnuKL/W7npnl3AxHcrK6xnJbd8Hpj7mlbllp+aWX9C78OqB3mVXL150Tu6GG3NLl9UDLDZ12CTtEyIuxwkixLWhDuIOg3h6jaMukEOz8BzxILPhVX9HDFGIf1Pg0g2WhihpkAf1g0OUjCBrqxC3G7vmcZxPRuAjYc1VxCK7k7bEHwZ85gp85kbwOUyQmeyKV3tFd9SOroMHiutg9yodopDclQ5RuF6xeeGuGZsXXv+weeHlSM1LSzBcv2gv2WBoHvEeliN/PhvBJ1Uln5TAp1l4LhHyn/jgPeQj6QbLSYMP11sK+KQU+XC9YVcprciH2yJ2u/g0Dh+iHA+vD1K7yIco/FkcolD6i9kQZUHh2u00WmW+RLLZThaHdtbF4tA2ulkc1zkGyT+RLqoZoqB/4q+ULsoPjYv7Wj0f2tArpZSOH0GDr/Dy4w3wFV7+av4eDP/43Uv3LUmvjEltOqWXtoXvLeRFmtbDbeFuXjWtLdukuB4Wx3WCQbJb0pO12ydjdNfRnxAu+pMF+aEyStOmkp86oAwu2oy05MiHhvhagrTk6HhZqVeaoqUgDUtxyuVgQXfSsBSHcXxYilNovI/IdYKh3JJTJTZTbrso2oy07V2afjtIwJW2cFD6g4X0XP9oM9wu6NlG4TlFm+lvFmSlIJU9Tm/xsselSKnspT4x2iFvE7lOMEg2Q3qq1GYkfxDXZuhZaVn6oDK4ldrM3ML1i8Vm4vgLn2xmLruHNjNXkFHajqntZ15sNoOvpuyMNoOvKVHfOezYlrMLuA2Q/qMw1sIj0uYXfqeqCqVjW6K2S8x1xDsB/IJAnosk/lFLN01CnItjW+aCrHgPfcBeQvqoY1vcjKnlY1v4uNGGehY3F+IaWBwf6+KxLY6OF8rE0T/n3yqkx6NW4palhHW2Ehb3BxpYY0eIRce28HHaHoAlHcU4jt0jnVB7VunRbW6PT4z/+R/0KW58b2ntQ9pmLR1xGeX/JFuYNSp6zaSlOdwAZOZ+odJj3/ixlJUchyPNkdWaLvAYEu7/8RgSPqfVBnFxj9yr9IgSrvsfV7Ccy8sYdV8rxzLNYddxdMGPZarkqBxuazhHw+srzmG66QuM3pFNaKN8OwfaKO/nV3OcUyU2Kh3nlAD5+BZo7qfxVXVK/xe2XvInmG/nR6YSb5tu0Yyh6aTtem7ntePvCyD+TYFLGy21jdIaAtcPto37CLJKr1jj61mVHknDsRoUscguWoLhNjoP+Ehji70i+MwT+Ljdqp/pxrrPA9Z9GyrdF0ByV7ovgOsVX23hdQznO3hZxdnWLK07cN48jvKI97Ac+fP7RfCpdkv93gKfZuG5RMh/4oP3orbu41rmXop8uN5Ga+vyaB0LhPO1/Mhhvi9grxmlZ/hzfF8Afxb3BVD689mR1fsUMB0f8VeRL5Fslm8LRTvj86toG3z9rdLtkPyIv0UjfLWC54nLHrdvQumzUE6O+hLi61moU6le12ofx814JbqPI7XjlfZx8PWsavolcxWxyLalfRzYNkr7DOZF8JH6SztrH0fyIaPVx8G+aqV9D/78i62Pg3s45iny4XrbWfs4lyv1cU5gfZw+aDsdzWGp9nHQzlz1cfi82KIRzs+if5I+L8PnSuL2hfBVdUq/dEYJ84YZ4XLtznj/ctc8DYaddp4m6tNi2PZV+mmxeQKfnbUPw/U62n0Y/LRYpX0L/vyLrQ8zWp8We7H3Yfg4j/dhHo/Rh+HPhvVhOlgf5tUeztOgnfk0T0Oyx+2bUPqna2ieRqrXjvdpxO7j4D6N3d3IE7lPQ2rHpfYJ92nwOJynqeazTXMVsXCexvVnN2vpUzo2VNrHGfIpnRG+A4a+kJcn7pOtdH5H+jQHHodUaZ9Y+jSMxGdulXzmCnxct9WjdVTgXOAzV5EP19uOmncK6+N8G/o49FzcPg6l34f1cb43OvM0FX+WC21WOpJV6huhbUjzO3H900jnaaRxTNy5EioH3jdTLIcBkuOQYHigOP6OQqXH6JDclR6jw+s3HuPK6+RhEMftNQVxvLx3lqN5yH4OYXGK9pNDG+GB4vh7LFhX+XssWFf5eyy8XDFIdkf5rfQYHV7PSO4RHKODTd1c+L1XiLjVHKODryDFPUbnYIEHmQ2v+jtiiEL8mwKXbrA0RDkU5EH94BDlMEFW6RgZPEbnMIGP9Gq/hDVLEYvsTnrlAE+1nSXwmRXB52BB5lo61cuGSoco/HSu00e4VIPNC3fN2Lzw+ofNCy9Hal5aguH6RXtJQR7xHpYjfz4VweeQKvkcIvBpFp5LhPwnPngP+Ui6wXLS4MP1dgjwOUSRD9cbdpUOVeTDbRG7XXwaZ8hX5+BIE2oX+RCFP4tDFEo/lQ1ROgsPuJ1Gq/yEQLRZflwT2hk/IRBtgx9/wnWOQfJP/HWTkQ5R0D/xPgkeo8OPucFX1PgxN3xoQ8fcNAD+xVCuvP4olmtxyDP6r9BlB+LUPc5fGg6R3NLp59W8spvJ9fV39vYOZvsHU/29gzmssyQr3qtj/C3NFdK3CundTjFke8nu+Su7c5lebahncbMhroHF8aE/vrI715H8cfTP+bcK6RfkS+kqKUtpmm1sMDIsejWWv9KG/hDHTza49QPxxyDEvwlkVZanOAaR+tn1gl6bI/TaKsThVhDpdWTptVkJq0ERi9oQaQxSD3wqHYPw53EM4mhqs6LXKG2odAzCfdFIxyA4xczLA6dapS9cSVNxuEWD6xfHIHtBHvFeVF96rwg+e1TJR3rtVpqGT4T8Jz54L2qb9WiNQeIcITBSPtKRiWg/Gnyiln3CxiDrYQxCz8UdgxTTszHIHdBX5fVgR/kSyWbjvtaOtsGnrrnOMUj+iXRRzRgE/ZNUJ9we7RO/f4D9cUf9lXRUWyu1gVFjB6k+4TaKavqKcxSxoraKYrtS6VZRafltZ+0fRNU/1/0D3A5TabstHQ3wYukfjNZW0Rd7/4CPoXj/4AMx+gf82bD+wZ93L2F+eFTmsnT7B2hnrvoHpItK+wd8LIfbmEn2BiHtDIijtJ9n5fWHwnWL8PyEYGjcDBY3nl2jHElIb8OVeVmWLxUurE6OnyVj1oVgkj1K812UDzoirZ7F6dlhf9rKPZuVJS/n5/ObH5qnuH2YqP4D9ymkozh9kXoBi/tUmjOT9MnnEGyoZ3Gu9clljKNPqd8TV5+kI0mfMwFrpoDFdRylT97nsqGexbnWJ5cR9Rl3Di6OPXMdSe3hnoAl9WF5fcc5XcIeI6SXfCOl/y3zObfMHCrfBPY82sJ4AZv70Kh61iTkoxni+LMWd/q0objzBNwo3xH1ah3nJX1KiJ6ttSPFsB3nbTW247ytxna80m2Ucdt40lOlxwjPBdwoX8Lj+LNSn25eGdxKbQbHpL7bDM4N+W4zYe05j0ObCZsn5LjSXjBKL40luQ7QZnibSs86XlOsqT0NFMc/6VLNXGMlNlPuVaQom+GfBML9LfuWwUWbkV5V5fUS5zKkV1Udv47Y1SzISkHyCTg/dICgO2k781yIq/RLuXFthr+qWInNlDtmCG1mL0FG6bUN6YvYvL1Cm5GO2uf6R5vhdkHP1tIX17ltSWWP/Zm4X0lGO5Q+zxHXZvgX3iuxGckfxLUZelZ6nXn/MriV2gz58heLzcTxFz7ZDB/foM3MEmSUjvHR9jMvNpvB/vHOaDN4vOUcAZfP98TZ+zeHpcGxNp/7oGcbhecUbabiI+axzyKNA6W5duwf87EYjqm4nXCdYJBsZk7hulKb2RNwefnYEDXWpmetzbylMD/TBLzomfmF36kKQ2ZgIJduT3f1dOfa2wd6OvC4BRvI/sY74N/e0dvV39uVTve0p3Pt6bL8rf6ntcn6JBum0CzcI1yy/wZ4dv4I84FqTQC/IJD3NRD/JpBVWZ7ivoYGkAf1g/saxgiytgpx6HOkMkkEw+0/ap6oVXi+PgaWlJ8JQWm+demyxUtyx/Vev/TGhbkAAtoK1um6EP4J4fkgAos/46Je9Xd09vWbypXKpZ+3x9Gu1x0Dfd2prkxvz0B/50C2o3+0+ef62nu6+nr6O1IDqZ50T7YSvyKtXSRC/tuQjMBuFbAW51/4Tz6I1yNNH0T4Y0E+JfxiG98g6Il4j3OSt8HBuP6V+DcFTv190b+OA3lQP/heRqMb/eTsEQJke9xnjRF0g3KMBRmbHMkorVWSTBRXz+JIDpumb85QGescyei2jg4OSH0Uvm/mjTNLfHnZ8L0P3O7rWDxP/xa2r/bJwnVLMLRd4n5qPIsfK8TTbyqvOiEtvssyFnQo6ZWnJ5scE5LXMZBXSv+OQv6sbGe1yZhcf1yuuhDMdzHMu6BM+HprVJ2n9OOF9LyOkTwtwfC6OR6e47LzT3biPal8EpAW22Bqp/hzYb8bBZwwGcYJONK7JPjJQc5T6uvhWCop8OF1irf5jQJ/xfahQ2orKUh97QTE8by/NF9Kh0Eau1KebH63zSzhYjqUR6prmn0jut/A7iNf7I+PgbT4jhSXsUFBxlaBzxjAHRshfwJw6oXnmgO5Pkr/48qbEOSNGg+PlA/Hell+KB9ezkOO1AL/yf14Unh2eb4Uz9P/gB+pFbNNQ1/C83BpvnQPfTb2Y7FOLsgPTY9tF6bh7ThP/xOh7UL/wLHsvZ/F6CNI/T7sI4ybVcL8JehT6gO0BMN1gzbcCLx4/5jaF9TBH1m5/m5mOC/Sa3NEHu29P8+U03EZeDrEkNpOwpDqNT3XIsiFdQ99x5gIHlJ7JvFogLhqy0dqt3lfQ+rDSPG8Ped88F6dkL5c/6MpBFvCHSPgSH5+HMQlhDj0YTy/3Idh30Qak3HfKNW7sLKL6ntLssfpV42JkF3SH/dD2nM5qe5UOtXf1TE4mB7o7O1rLzeXQ/fH5ofm6/n/7F4Dy5cN43h6iGtkcfX5ofybCr/rGR+ORXI0QPqZBX/bUrg/hj1Dz7cK/McA/yFyC/e4rSFWUrhH6W2ZTinI6GKOLtPR093b05dKZwYzmWx3Z7lylfTE5w5sIF3zshgj5K0B0s9jbd8+8L5Eg8DPpmuPSJcI+f88hnCvPj/0nlRG3HYpPfFuyg+XkeLGs7gG4DOh8Jvri2ORHA2QPg22y+2Nnm8V+I8D/kPkFu6h7Y4X0o8X0tvyObAgI9ktz7v23N/zPAGf30PZ2h3Wq872znR3d293f2f/YE97f99oz73393QO9mSzfelsz0CuJ9056nP/7dm+wfSgmf/PDqay3elRX/voTWXMWmZfX0c619vTMzjq+U+n04Od7X3dnf0ZM8U46msv7YNdvZ2DXamOzEB7LjPQO9r8e7tyPe2d2Ux/drCntzvVPdr8+wY6+1M92fRAb29XqquzeyRrTzhHYgPNUTlaI479Ln7RTwfD+7Iu1lSSIA/qB9espbVnaR2Ozm5NCHFx1qVdY7UEw8sb5yUk3SQj+GBZ2RBnn4SredG4Nkf8R2ufRNx9BTjXyJ/FMaUNaCfSfgxp7cAXLHreBpzX5PYnjYOj7JHmD6X552sLcehLW4LwsiG5aCzL7zcI2Dj3uAzOp8P5xPmF36kqg/T5G1yfdbSm3SnNl1FoFvKN5c7nSLDccd2bx0nvKCYEGZLwm+vC8r5xTgkX01GQbCQBcWOEfEjzM9jWJAS5otbko+b5pHaCzglNAGYQRM/jSHPkYf2RqHYmEYEt1euo9WrSUVKQLar9l/TcXEH+JBvHts9R3Y7d3yL+TcFwe3TR9pWbD8S6HLWeK809JyCO8xkn8JGw6hSx6iE/vDzQFhz1dWP3g4h/UyDXk/k68qSjfEpC0KvU946zBy4hxFXaX651rKgxXZxyl/hI/k9a9+brrm+BM0/oOe53+bN4Bg+lP3yPEubTbB4wrPylNgH7YZKd1UXkX+LTKDw3v/A/VVloxxtu9+ulerHvwwPFjRfynBDSS/0ikrvS88p4v2g8xPF2aALE8TazGeK4751YuJZsBPtkldoIfz7KFsdUyUfqH7qu8w3Ax/Vel6h+0kj5SOuI0n6navlwWxwHfPhz3Fd+CXwl3zMhtYNn50vxPP1BzFd+FcaMbvZGp3pwjMWDNMZCm+V+Bu2Mn1mDttHM4nDPOQ+SfyJdVHNeWRPDx/qSFJ6Nmu9yNKaO3ed/MbwXZAP2p6R9EtLYIuodIw2sqPYgCXwqbQ+k8a3jsWQ3tq08SP6g0vNOi3vEgsr6D1yvjRAn1d2R9juk+RjsI0vjWn4vqr0dG8Gnvko+UXtCXbWDo9VPwbG1i3eqpHZqtPpDYf2H5j1Kz/DnwvoPONai9DNZ/6G1cO14HbAiXyLZbNy+BdoG71twnWOQ/FNx31NQWf+B2wTlie8TluaVpHYxEQz3sTgPxflJc8v0bK31D7F8pXGoVIZYvrx/iPV1IovjOsFQru9Yybv5Uv+Bp8N9jwlBRqmuSzYQdQ6e9P4Q7tG0QdrPS8/W6vxEVN2W7AL9K7cLtMMWFsd1gqHcfEglNiP5g7g2w/ekfwnmzXg6tA9pDrJB4Bklo9QvjuuzcD+59M4Z8g471ztsnHxcoQ7x9+uk90NJT27Psk11SGfZcr02gExROrSh0jqPewgkfyz1t3B+Q1r75nPBfC0M0+G8rw20TwDPAD+P9VPO3mOoDLxveU5+aByOtQhjXOHwk8ZgeP2wNL/wO1VV6OqV9rfo4Zc+/R71jryb9bz2/gTwCwJ5roH4j9Y78lK7K+0tkeaSca2cj4/W5EvpMC7OOIzHbVXE2q6ItVERa4Ui1l2KWOsUsbYpYmnqSzOPWnLR81pyadrqfYpYmnVb0ya2KGLt8l+7/JfLPGrqfr0ilqbd36+IpVm3a7U+avroWm1rNctxgyLWztAO7Qx51JRL06/WYrttr6tde3NlX5r6elARa5MilmbfpFbbtF31ccflsVbb7Z1hnKZpE7crYtWq3d+riFWrcx0PKGK59NGJwn3pHUEb6L0pXN9ogDUHN++8tg/suHeO2gcSwC8I5DUB4h81B98UyP2x+SOUtS89mM2l+vraM30DHZ2dnZXaBqWvjTN42/sqPd92LMQ1sDi+Xj1pVPYRt/fF0T/nL9XN61geKinLycFQW+P1UVpXXJgfGsfX/GnNkq8rjvTd5LD3Bzk/rMuO3p3Pxa3LtfruvN0TQt+4uDK37Kwb+xZe3X9qbvnSYxYNnNW7ZNnVvQuPGRhYklu6lOcGLQFzy7UhpcF0mJ7iyu2Ipl0X0ptP+ObKmDJYJwKWtOMwqgZxrDMBS3rLQtrlgbuuomo6j5fwsTway8h8NsgcdjK5paYyWNcDlnQyMWGNL4N1A2Dx5/Ek5gkhfHgavkNqgsBbwkddNpeReUl+qMxcrmbAmlgGaylg8ecnAlZLGaxlgMWfb4HnWkP48DR891erwFvCR11OKiPzjfmhMnO5JgHW5DJYNwEWf34yYLWVwboZsPjzbfDclBA+PE0buz9F4C3hoy6nlpH5lvxQmblc9Gyc1nQqu6/YesXuGRP/0WpNy+kVey3TBFlbhTicOZ0m8Jkm8JGwGhSxxipijVPEalTEGq+INUERq1kRq0URq1URa5IiFvlCHLXbML/wP1VVyLbj7mrizflyXe+IEQbxbwqG27cLnyj1Nbh+cITf5kaegaj2uk3QD5XlVCEO7ZHvoObp21ge0R653TbAvYHCUKtVwESfK7U5/B7p1/b9L4MRNa8DiZD/hIv3olb68C1APvrnb15dvefQvNBzYV8XoL5UA6Q/c3YJc2EBUzqRj2SMOhEqEQzXTZxZTomPoq8ZwBuEPQ3yMEJ8COniV86nB8MDxe0m5DkhpE/Cby53pW+pcn+1G8Tx+jkD4ngdx6+U8vpFHxaQbAT7ApXaCH8+yhZbquTTIvAZ7To/XpEP1xv65xZFPlxvbcCnTZEPt0UcT4X5yi3gK+m5MF9JY7gGSH8085X3wSqKm/FauhPHOzygn5FslvsZtLMZLA5tY3cWh2NhHiT/RLqo9C1VXv6UJ3d9ztTgDuxzxj4ho1b7nFLbQM9KdRX7XlF9Sc5HwkoqYtH8jNTnwTYrKfBJRvDBsrKhEfgq+4sObJd5kHxJpSdkkNyV9j24XqdBHLeN6RDH6x/2WXg5ki+T5t3QXqS5P34vqn86JYLP2Cr5jBX4NAvPVduGSrqJmpMcKR+pX++6L7Wj+jhhfY9PQd+Dngvre+AJGZT+MNb3+Cz0PWplHIM2OwPk4nG8f4G2MZPF4ZoGD+XGRpX0PXj/bTeGj/bF04V9nXaswC9s7kGqcy0h/G24OP/C/wr6RZn+wXS2I9fVkersbe8Y6MxmBjJdqYH2jsF0ujud6WnvzmYH+9u7B7oz2cFMV6Y/yuc4Xp+I3S/C9Qk37Wn0+oTkyytZn7ABTw6rhTUFG2gnWZS/dmwL2ZHagptdZdG2IM0pVLpWhf0UjXWJOGuNtTbGcb3WKI1xpLo8GvYdVs5jI+SZ7kaeDMmzmyCPNM6xa0xjguE2xPXFbZLLzdtYuhdWNpz3gvwL/+PM/U0pg4X7kfjzUwCr3Po07keS1v0bIG4m69MlZg9NQ3tk2liaJDvBh+uT+NhANsL7ZTuiThP/psCpzaajbJbrh9vs2CDadnjZhe3RahLyGseWuUzV2jLHqsSWy+kqypZxDB41xpPW/6Q2kfCtjU+fPbr40u5Xab0E55r53MM0hj87An9cBH5jBH6TgI8y4y5/zrsB0u5VwLDyvGXOUL5c32GnYnOZpJP0WiGOyxR2UqakH173miGO6zXsVExJr7wOT4Q4Xh6TII7XTTwFnu9NoT1k/HRFqe2Q5lSj+gPc1ik91U/JFmttXQLnBrB94nF83gDrPJ83wDrP5w2qWbOo5KQ8ae6Zz+eQj5fslp6V5okkG5D6YJR+upCe+0C0GW4XuNZSa+vikl3gWlaldkFxs1gc1wmGcnNNldiM5A/i2gw9y9c1qUylNXLi2RKTZ5SMUfan4bOQN59f4/KHrc9eyNq1qNMVSU+OT1fMSacrcr025IfmO0qHNlRa53E9jvvjNoiT5jgl+yt+nTwo7UHibwqRHHi6XgCYUfMRjr78FXvsgm/+uZ6PKPfeDM4nSW8pujzlDG2gWiyyjZ31awG8XLB/yvXs4msB1doEfz5qH1a19lIn8HG9dpgAPglFPvy5sDcwNfjEGRdp8In6WgB/M5Kvhd49u/QMfy7sFOWwrwU8yubEthSuHb+Fqvq1ALSzSk8Uj+ufSBfV7MNC/8TthdK5/JIA5eHF8iUBLHtevlj2/D2VWv2SAK+vOG6pF2TkfkD6ijX2/XgcnsDAZaM8SV+ZsQG/cE3p3w7+w9GXBcQvXOO7VmNZHpLBcJ2jP6T0n2X+8JnZQ3WG71XzOKm9lt5NxnKQTnAnfKoH3KePi8gDpX8u5tiN8uN47NYujd34O9kN+aH5lt6x5unR70nvRXM/gadNhLUD/DfH4jrHsT2vi5LPJTxsdz/ByuiWmUPl43bdBLJLfTlpjxh+YY3bViOT+UdQZx2NF7uk/iYFaY4afTuvJ+jbm0BmHid9PSghyCD5dtJFpV+G1/ATeF5FrdRb3m5jvY36QkUQDK+35eo59XelPcBo31JbUEmdsWEB8JPWU3idwZNdcCzGMWyQ+vQkt+N+V2cC+JG8/B7n3yTowMV8jdTHlb58JPkB9OvSF5ASwXA7jLJNCStOPzsuVlIRa6wiFvaJuZ2gjeI67/zC71R1oSuujRL/Wv2ifVKQVfI3uF8xKfCRxnu7sPSwXM8bYT+Gj0H4fM6EOUOfoed4358/S2cW4V6Fs+aUMFsK19L7ONj3kPZuRNk/vxemZ56uUXhufuF/qrLQiTdq9evYCSF9uTmE06v8kvVI57el9RCSQbIRHKtWaiP8+ShbbKiST4PAx3Wdf7F/wXaMIh/pLDipD8J9ZWZO6Rn+XNiXculMNpzrmT+nhNlRuHb8pdyKx8FR/V+0M+6D0Db42KnSOU66V82XcilPo/mlXO7LanV+G8u30q8dS/Pbcb6IOpK2qZL5bWmNkqfD+e2EICOv63G+eir1B8cIPKNkjPrqrmSv0v4B6UxOtFPJZ3H5w3zWRXNe+F8jXz3tkuaIuF4bQKYoHdpQaZ0nnUWNaeOsg0trJbxfXpwzzQ9NN79wP1VdyCRAX0kmR33hHudPZT6OxVG6oq9zI2uKZG0q4JMNc548L3WQHq8b4N6yOSW5eR6HtEXseexvj2dxlD7J7pGMxf1XLG58vjKscYA1tgoskqtVSD92hHJJWGMAq1HA4vdIv7Y+DM4p4AXyqda8D8r7bLfMKfHk9Y37P/5s2H6FLXNKmCsL15K/xb4Ar9843sA9UzwubE4efRP3t9jGK9a9jgTwCwJ5joz4NwXD/aKLOTJp7l/6gjjpx9HZK+0kj7QmKM2F2ncTJgbDy0w6d1n6KnnUXgq09XK6kdow3JPIyziqfcM1EG4juAYirXOMD6L3EUT1Y6LOIi/3JWfqo2G/Z/ucF/7b558sXEftyZPqL9Z7aV5eOrcb5zok24r6cnuzkF7qy0t7z5tjYEX1n6TzupsjeHO5+LPIO6yOSH1R0o3jvmiH1Bfla4zYF43aN2BDHF1K5dgK6bnuovZ+SvV4PMTx+od1XJoP5PVFmhvk+xeojcaz6Al7fuF3qsLQlenv6M129KT6cx1dvZ1duH8nYHm2+d27cN0IcdptV6OQTy387lR7N84BKMufdbxPs4jf4AY/RXZ/fL6EL81vks2fmC/p8sT8UJmkOUPCleZ7T4A4PvYmbOtPqP9sr8luqS7jfIINLtdIjU11OZ6fTLeFyE95s+G4vBveNKagL7zgnAyWU6NwT0uWqDl1x3ulMgngFwRyHx/frXFUT9Nx+25kM7ZNpHZr6bLFS3qvzJ2T6x3yuQRUH/7nWedxuJSSgN+4pIPpkwJOVEgIuFLWqUpETVNalbjsAnV1l6ZmqPvFp2Z4qGfxPP28wm/tLsBgV296MNs72NvROzDQ3t9brgvwksK1312AruxodQEcNQcZx10MsQvA80J8k5BOemakXQDb5NArz/aaXnGmZp53NRIQx7sAdRB3EsjH405mcbjV8xQWh1Na0pJF1DSLi2Uu0w3pc7vFP9MtDSP5lL0N9SwOP5LIh3oko01zAOjHxeuSRj+dbpcZMwNtgvx86sZetzOd8HhKz/XgqBx74nZliH+TU72VujJRy0o28K4MHbdR/ODg8b3Lei+8etmi3NKluBUiCb+x/4HdSXw+bEvn/oX/PH25QPKgT+R42F8K60/VCbgUol5nk7ZERh0xg8tycbbVcD1Ky3m49cAGvkwjLZ+Q/5CW2ZIQx5dK6vMlvjbQkha9hoRYJAcugWULv6UlKlza4fxxaWeI3MI9XDqrZCno4MK1D/3ansLvHd2vpWNXPJ/a6trVr40Ocfu11fRZaXrZXvNjemyQ+qyOp6Y6d+TUFPV58PMofCsHtlG49SoRglvrvo0fD0ny0f/R9G10mt4u3xYZso5fo0k7roeib5PqZJRvQ//Fjzm04QSGjWPuEwW+LvNsbKLDcXuRaQvC2wicdg/i802XY0x+k/olSUEOXs+kTy3geCAIwZB8L/JICniU7+YI2ZqD8v49rN2odf9OyyE72r/PLVzv8u+RYVffNdjVd4UQq+9K886o5zjHEVNafnxyWwhenL5wMuQ5Pn5FjEBRX1G+nsvhe999TuH3jvbtND+yy7dHhp1uyw2lw2fKrbc59tcdjvWUdrk+lGKfK4naUsH5V/sqKec1Wkd7lDvijGxDehUU1z0r3UItYe3IMpWOUpPWOHENuZ7FjYG4hvzwPNp+xByWDusg9t14W0X9LotxEMOjeX6pzdf23a58hg1tQXi/h+7V+rrQgYXftbwuNK9wPT4o9W2zDC+sjvCxAl1Lr/bw468c1ufiJ5zqBVml19btWjEd9223veVOXnTCLbn+G5ddvXjRcb39V+UCCLhYnGCZD2uYeUYljCR7Xgo+dIq7C793dKcY31tw9E5XppHxdICfks4a4O9rjYc40oG0STIR8jtso4CUNhGB2yzEESYNaLm8lI9G+O/oO3PFAYyjb2SKZcW/WzAF8sn1PV9JBsKjOtuAAgVDJyBsKDYihf840LNhfuF/qrqQDiAkBV4UyGb4N79In5NAVleDruK7427wizbpqmMr2eSQd/wL/6VywM4i1lNlWXuLHTkmQxJ4oow8jeTz6uB3PdxPxkgr2SbFFTtsEc/hhjW8h4ODQEhf7PwV/jeEYPF3Onn6sZDWVRm2CTKR7P8P/VUYXYsECQA=",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "get_custody_balance",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "custody_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "length": 17,
            "item_types": []
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12133945852524408359": {
            "error_kind": "string",
            "string": "Function get_custody_balance can only be called statically"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_notes_internal",
        "get_collapse_hints",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "withdraw",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "custody_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "length": 17,
            "item_types": []
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "14721978132355969467": {
            "error_kind": "string",
            "string": "Insufficient balance in custody"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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3lSBesabalDHm2pQx5sqJL0Zb6qQCGSBugJ1vKkGdbypBnW8qQZ1vKmGcsSbKlAXvKkGdbypBnW8qQZ1vKkGdYG6AnW8qQZ1vKkGdbypQtIreFOFREDwpgrUC95UgzreVIM63lSDOt5UQTkWgboCdbypBnW8qQZ1vKkGdbypBnW8qQL1ijfVoI431aCON1VIeiveVCERqAJ1Bep4Uw3qeFMN6nhTDep4Uw3liDdVoL7hTTWo4001qONNNajjTTWoC9QVqONNNajjTTWo400Vkt4Nb6qQCGx4UwXqDW+qQR1vqkEdb6pBHW+qoBybQF2BOt5UgzreVIM63lSDOt5UgzreVIF6x5tqUMebalDHmyokvR1vqpAIdIG6AnW8qQZ1vKkGdbypBnW8qYZyxJu+n3oPeFMN6nhTDep4Uw3qeFMN6gJ1Bep4Uw3qeFMN6njT9ye9PeBN358I9IA3VaAe8aYa1PGmGtTxphrU8aYKyjEK1BWo4001qONNNajjTTWo4001qONNFagnvKkGdbypBnW8qULSm/CmColAEqgrUMebalDHm2pQx5tqUMebaihHvKkC9Yw31aCON9WgjjfVoI431aAuUFegjjfVoI431aCON1VIejPeVCERyHhTBeqCN9WgjjfVoI431aCON1VQjiJQV6CON9WgjjfVoI431aCON9WgjjdVoF7wphrU8aYa1PGmCklvwZsqJAJFoK5AHW+qQR1vqkEdb6pBHW+qoRzxpgrUK95UgzreVIM63lSDOt5Ug7pAXYE63lSDOt5UgzreVCHprXhThUSg4k0VqG94Uw3qeFMN6nhTDep4UwXluAnUFajjTTWo4001qONNNajjTTWo400VqDe8qQZ1vKkGdbypQtLb8KYKiUATqCtQx5tqUMebalDHm2pQx5tqKEe8qQL1jjfVoI431aCON9WgjjfVoC5QV6CON9WgjjfVoI43VUh6O95UIRHoeNO3Uy8h4E01qONNNajjTTWo403frhwf1AXqCtTxphrU8aYa1PGmGtTxphrU8aYK1CPeVIM63lSDOt707UnvgzreVCERiAJ1Bep4Uw3qeFMN6nhTDep4Uw3liDdVoJ7wphrU8aYa1PGmGtTxphrUBeoK1PGmGtTxphrU8aYKSW/CmyokAglvqkA94001qONNNajjTTWo400VlGMWqCtQx5tqUMebalDH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z7Hx64HUz3X7Sf1ct19ov+f2k/q5bj+pn+v2k/q5bj+pn+v2k/p5bn8k9XP8gW+PpH6eQ99I6ue6/aR+rtsvtN9z+0n9XLef1M+18SP1c91+Uj/X7Sf189z+ROrnuv2kfq7bT+rnuv2kfq7bL7Tfc/tJ/Tx/4JtI/TyHvonUz3X7Sf1ct5/Uz3P7M6mf6/aT+nk2fpnUz3X7Sf1ct19ov+f2k/q5bj+pn+v2k/q5bj+pn+v2k/p5br+Q+nn+wFdI/TyHvkLq57r9pH6u2y+033P7Sf1ct5/Uz7XxI/Vz3X5SP9ftJ/Xz3P5C6ue6/aR+rttP6ue6/aR+rtsvtN9z+0n9PH/gW0j9PIe+hdTPdftJ/Vy3n9TPc/srqZ/r9pP6eTZ+ldTPdftJ/Vy3X2i/5/aT+rluP6mf6/aT+rluP6mf6/aT+nlu/0bq5/kD343Uz3Pou5H6uW4/qZ/r9gvt99x+Uj/X7Sf1c238SP1ct5/Uz3X7Sf08t7+R+rluP6mf6/aT+rluP6mf6/YL7ffcflI/zx/4NlI/z6FvI/Vz3X5SP9ftJ/Xz3P5O6ue6/aR+no1fJ/Vz3X5SP9ftF9rvuf2kfq7bT+rnuv2kfq7bT+rnuv2kfn7bv4VA6uf3A99H+0n9/Ia+j/aT+rluP6mf6/YL7ffcflI/1+0n9XNt/Ej9XLef1M91+0n9PLc/kvq5bj+pn+v2k/q5bj+pn+v2C+333H5SP88f+EZSP8+hbyT1c91+Uj/X7Sf189z+ROrnuv2kfp6NXyL1c91+Uj/X7Rfa77n9pH6u20/q57r9pH6u20/q57r9pH6e259J/Tx/4JtJ/TyHvpnUz3X7Sf1ct19ov+f2k/q5bj+pn2vjR+rnuv2kfq7bT+rnuf1C6ue6/aR+rttP6ue6/aR+rtsvtN9z+0n9PH/gK6R+nkNfIfVz3X5SP9ftJ/Xz3P5C6ue6/aR+no1fIfVz3X5SP9ftF9rvuf2kfq7bT+rnuv2kfq7bT+rnuv2kfp7bX0n9PH/gW0n9PIe+ldTPdftJ/Vy3X2i/5/aT+rluP6mfa+NH6ue6/aR+rttP6ue5/Rupn+v2k/q5bj+pn+v2k/q5br/Qfs/tJ/Xz/IHvRurnOfTdSP1ct5/Uz3X7Sf08t7+R+rluP6mfZ+PXSP1ct5/Uz3X7hfZ7bj+pn+v2k/q5bj+pn+v2k/q5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",
      "brillig_names": [
        "discover_new_messages",
        "get_notes_internal",
        "get_collapse_hints",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "random",
        "notify_created_note_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "storage_read",
        "get_public_data_witness",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAAALgvfqPPq\nA3nd26JJbL7HnaWx/eToLdLy9wZ8HPGVFkABMmRnZ+HN73YpsO3Lwav4iGY0YC3p6MFu0ViWmti4\nyh1xZFg8ySG+D7UKdoWAbkCEUvGofihm1Tb8MfZcRt5+Efq39+LzJoA8nNjZwHNm3g6jeEWHBmuv\n2aYZQyy8EKISv5BSu5GSGqMoPQwa2gv8eQEet/DhSHOkHYwPAW36nBo3FIhTwU13jeBny9vtge1Q\nvF5FhQq5i+uwbFcbv5NBGTHyp9vS1iykCyw+otlEqkfPTQwTM1kZw3e9O6+4OgEqJO+Svgv5uSMZ\nZZ2LIAGw0O6VyqKK8A66ZEEaU6jPTxImlvHnZbthGDsByCHfk6taHilCgAo1cqj0k68zsi/6AKuN\n4xm2F7cbrUW54PrF4WU8Kpq2lC6vx/3dudsOHUAq0YVKsbwoVRMXmFc5Ol3UNsR8MtRjLF0QX32b\n3vSTuQ5BvgUu7sfqy8qrrvmbQXmKMNalVrlQGU718VSoUoT/IuSmLVifXcWOAD4X0sKeZqqcjXq3\nWBuYEO2nPlPhfd8OP4PTyf+mJHwLpRXOLm9SrLCVbfb6d5ltuCSwof5icAgsZKbaJw9p1+cbqbhm\no1/hIMFBKUIklmmIy3sciHHxFxpsATFPP+jmqDzi1vnGRtyfM/qiZS3QdNUGEU7gbUMMsr5EowJH\nO8UWSn9pe0qTeY3pZENlY++ILcesUd5+WyRSezM6GEjumOiPvkkWZEf+4BW3FAHuB07nkAWsPAA8\nGZ7U66W0WuMtvEDHth7RlfgGo6qOS23EqacqsUfhJ2Av/+68GA7QUmgYUJLeUaPfuIbVUeUz7/R4\nr5ZJAof/MSfmAW5FBY7ag3B/MDJvRuHT7WyIwQuiLdCLBb2TtR4wHocD7sINykdFXDmoGDbve/E5\nLcb/GIJ6OpU7Qta+cGgQWNYHo36iOR3LEGCgAqii+ard5wU+lXArHCis7+OLdCJ7UO2iV8GK+/bw\n+I2wkTDIZtEwXudLesh2hR5UkpbMIGqouj8Jxtki8brbOO2SMJD0RWklAHP22ccwTaWLQikW24Ti\n6tvXLePTAAhzf4dbDP5pRTFyqXoatNS7wgInuB0aR7lCAsIgds1l3WUSycOiIB3X3iva39HM3fgT\ns2tWAfWJlH2qEKartHJkomp7nolAR5y+5xITzRUAAyta8+sgv7NQTs8KedC7DijGaX4NZYU8R+DG\nRX8iNNZ7h/myChgXLcUvjIEG4vpzuu0+mY5cL/hzd6iJ4SFd3sm1BN8uAiHekE8UEuOWxFiRQaFp\nVtZrdoaLt13OALrNN6klRuEtJQNyazVVaeR/FoupU3Hw5g4xVxBAisFudey3zGTsmwytt0iyPxjW\nb3hGJJjLrqfTMPXlaUxUDNqZAHJFTZRbF8BDgrMCCzMnu2LwAcqYBTzc4jN6uyTKFadM7RydyGQh\nQV6ez+k8/S1DrPTC/KuO9rx4gM7HVSO8TIilbXThnSNd7bjKMOxHSznkSQMS7IrmYTWRSKpPTBcm\n4/NFoKTKFxxqNEacdztMuai82qC1wUuc0udlu8ufegVfZfEpOscAc8qljohsJK9hfw0Fb0JelIR0\nPLQd2dbPDSOdUxgC9C/2bKpmFHEBPRSeFYI+7JYreI2hOrohD7OTs17XoKTEIjOZmHGS2rLq3O2o\nzuafyrqRcjdxE6fTCOzJVKnQZkMSSyNna8dDm9LAmzKtjacznvy5YEurKwsxnbD1XYcc6gOBqCwK\nHOY8W6WvDdFFoYkSGCW58LNrmsNUU/6vTA1QLT7wF+aHsjYi9rOCMaWQrxJJvHq+z9UdzbR072UZ\nQgkU7PwLVx13NrpPVJK/F2Rf9L1s2C3pPt13doYv8HWysgtaDT7C5fKzBDrVkn917iJOe4uwdsAd\nnRXmldtJYoR5L0k+SqJepx+Q/5V+KqqeomSYTxXLfqssT2ml2Ailb00MDfwyFqfkTkJc7/GGGfQr\nfw/rg2SOEbH+DYvGtgxvIQt+Bww1reRIgasMq+ppQb4/zeTE4IFhvnl5SCKu+7P2F0xNqsxv6+gt\niDGpBETvEX32GkvxinRGtU2OzdDlJyENPQ9wXJw7Qm4veGR5CujPFMTyBusHozGX/1z2u6wLrwcD\nm+cLVXtvDU1Z+xKAoZlYPQqQ5tVT5L1kSbWO9QehChGFSw0wrqddreiukl/tbL8F77PitlsEveca\nM00v6zMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAACAm18dXbYS+/Y8e8++mxohSRLgCaqbCS148nwGGOcGMEZvfTeqyAJojzO39MG\n9ne/tTnD2nFnmTPFve/egukuCgDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04s\nAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJ\niS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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hnGsDlMN41i9qBrGsbpWNYwCxhYYx+qy1TCO1b2rYRzLFahhHMttqGHExbTA2MNH4HvAiItpghEX0wTjYH3jPmyZw/dAK/Tw2eOW0x2sD6tNd7B+qTbdwfqaynR7+Exsy+kO1ifUpjvY/bw23cHSw9p0xdd0fXVVPXzuseV0fXVVPXyGsOV0fXVVPXwer+V0fXVVPXy2reV0fXVVPXxOrOV0fXVVPXzmquV0fXVVPXx+qeV0fXVVPXwWqOV0fXVVPXyupuV0fXVVPXxGpeV0fXVVPXzeo+V0fXVVPXx2ouV0fXVVPXwOoeV0fXVVPSzT33K6vrqqHpaPbzldX11VD8uat5yur66qhwW9W07XV1eVfHVVyVdXlXx1VclXV5XE13R9dVXJV1fVw1csWk7XV1fVwxcnGk53rO9I1Kfrq6sa6zsS9en66qrG+o5Efbq+uqqxviNRn66vrmqs70jUp+urqxrrOxL16frqqgb7jkR1ur66qsG+9VCdrq+uarDvMVSn66urGuybCdXp+uqqBvuuQXW6vrqqwb49UJ2ur65qsK8JVKfrq6sa7GsC1en66qoG+5pAdbquuqo42qr/tem66qriaKvo16brqquKk/iarquuKo62ynttuq66qjjaqum16frqqkZbhbw2XV9d1Wiretem66urmsXXdH11Vb7WVo++1laPvtZWj77WVo++1laPvtZWj77WVo++1laPvtZWj77WVo+jra3+se8cpW3beZrCTxvfOfJJwjYc+SZhG458lLAJx9HWr1fjyGcJ23B081nw+3TF13TdfGb7Pl03zed9um56xPt03bRy9+m66bj+mO5oS9DXpuumf7lP183nj+/T9dVVjbYEfW26vrqq0Zagr03XV1c12hL0ten66qpGW4K+Nl1fXdVoS9DXpuurqxptCfradH11VaMtQV+brq+uarQl6GvT9dVVjbYEfW26vrqq0Zagr03XV1c12hL0ten66qpGW4K+Nl1fXdVoS9DXpuurqxptCfradH11VaMtQV+brq+uarQl6GvT9dVVjbYEfW26vrqq0Zagr03XV1c12hL0ten66qpGW4K+Nl1fXdVoS9DXpuurqxptCfradH11VaMtQV+brq+uarQl6GvT9dVVjbYEfW26vrqq0Zagr03XV1c12hL0ten66qpGW4K+Nl1XXZWMtgR9bbquuioZ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6Hz8sfPxW7//1sbf+f03dH7/DZ3ff0Pn99/Q+f03dn7/jZ3ff2Pn99/Y+f03dn7/jZ3ff2Pn99/Y+f03dn7/jZ3ff6Xz+690fv+Vzu+/0vn9Vzq//0rn91/p/P4rnd9/pfP7r3R+/106v/8und9/l87vv0vn99+l8/vv0vn9d+n8/rt0fv9dOr//Lp3ff1Pn99/U+f03dX7/TZ3ff1Pn99/U+f03dX7/TZ3ff1Pn99/U+f137fz+u3Z+/107v/+und9/187vv2vn99+18/vv2vn9d+38/rt2fv/Nnd9/c+f339z5/Td3fv/Nnd9/c+f339z5/Td3fv/Nnd9/c+f339L5/bd0fv8tnd9/S+f339L5/bd0fv8tnd9/S+f339L5/bf0ff+Vqe/7r0x9339l6vv+K1Pf91+Z+r7/ytT3/Vemvu+/MvV9/5Wp7/uvTJ3ff+fO779z5/ffufP779z5/df8+le18Xd+/+18/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9K+l8/SvpfP0r6Xz9q6Xz9a+Wzte/Wjpf/2rpfP2rZer7/rt0vv7V0vn6V0vn618tna9/tXS+/tXS+fpXS+frXy2dr3+1dL7+1dL5+ldL5+tfLebXv5qmbSRpiun7+E3df+9DMnVLvQ/J1F3yjyHZWnjqPiRT97L7kEzdnu5DMnXHuQ/J1E3kPiRT94X7kExd6u9Dsnf1trUg0n1I9q7etpYtug/J3tXb1uJC9yHZu3rbWgLoPiR7V29bC/Xch2Tv6m1rOZ37kOxdvW0tenMfkr2rt62lae5D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",
      "brillig_names": [
        "sync_notes"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "CustodyNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "custody_id",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "amount",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "pSymm"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "custody_notes",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "pSymm::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "pSymm::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "pSymm::get_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "pSymm::get_config_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "custody_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "pSymm::deposit_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "pSymm::deposit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "custody_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "pSymm::withdraw_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "pSymm::withdraw_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "custody_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "pSymm::get_custody_balance_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "pSymm::get_custody_balance_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "102": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "104": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "105": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "106": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "108": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "109": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "110": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "111": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "118": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "119": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "124": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "126": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "129": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "132": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "135": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "138": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "139": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "141": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "142": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "143": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "147": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "148": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "149": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "150": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "151": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "153": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "154": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "155": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "156": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "158": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "164": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\nmod test;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateSet<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:insert\n    pub fn insert<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        let (retrieved_notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < retrieved_notes.len() {\n                let retrieved_note = retrieved_notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, retrieved_note, note_hash);\n            }\n        }\n\n        // Since the notes were already destroyed, we no longer need the additional data in RetrievedNote and can\n        // discard it.\n        retrieved_notes.map(|retrieved_note| retrieved_note.note)\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, retrieved_note: RetrievedNote<Note>) {\n        let note_hash = compute_note_hash_for_read_request(retrieved_note, self.storage_slot);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, retrieved_note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note> PrivateSet<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes<let N: u32>(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\n    where\n        Note: Packable<N>,\n    {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "166": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "182": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    // Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "184": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "185": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "186": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/comparison.nr",
      "source": "struct ComparatorEnum {\n    pub EQ: u8,\n    pub NEQ: u8,\n    pub LT: u8,\n    pub LTE: u8,\n    pub GT: u8,\n    pub GTE: u8,\n}\n\npub global Comparator: ComparatorEnum =\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::Comparator;\n    use super::compare;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n"
    },
    "187": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "188": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "190": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "192": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "193": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "196": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "20": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "220": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "222": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "265": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "280": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "282": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "283": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "284": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "293": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "297": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "299": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "300": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "309": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "320": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "334": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "338": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "339": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "355": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "356": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "358": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "364": {
      "path": "/home/qbit/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "393": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "51": {
      "path": "/home/qbit/Desktop/work/otc-noirhack/contracts/psymm/src/main.nr",
      "source": "mod config;\nmod types;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract pSymm {\n    use dep::aztec::{\n        context::PrivateContext,\n        macros::{\n            functions::{initializer, private, public, view},\n            storage::storage,\n        },\n        prelude::{AztecAddress, Map, PrivateSet, PublicImmutable},\n        note::note_interface::{NoteHash, NoteProperties},\n        utils::comparison::Comparator,\n    };\n\n    use dep::token::Token;\n\n    use crate::types::custody_note::CustodyNote;\n    use crate::config::Config;\n\n    #[storage]\n    struct Storage<Context> {\n        /// L2 token address for custody operations\n        config: PublicImmutable<Config, Context>,\n        /// Mapping of owner address to private note sets\n        custody_notes: Map<AztecAddress, PrivateSet<CustodyNote, Context>, Context>,\n    }\n\n    global MAX_NOTES: u32 = 8;\n\n    /// Initialize with the L2 token address\n    #[public]\n    #[initializer]\n    fn constructor(token: AztecAddress) {\n        storage.config.initialize(Config { token });\n    }\n\n    /// Read-only view of the contract config\n    #[private]\n    #[view]\n    fn get_config() -> Config {\n        storage.config.read()\n    }\n    #[private]\n    #[view]\n    fn get_custody_balance(custody_id: Field) -> u128 {\n        let cfg = storage.config.read();\n        let caller = context.msg_sender();\n        // Get notes without popping them\n        let notes = storage.custody_notes.at(caller).get_notes(\n            dep::aztec::prelude::NoteGetterOptions::new()\n                .set_limit(MAX_NOTES)\n                .select(CustodyNote::properties().custody_id, Comparator.EQ, custody_id)\n        );\n\n        let mut total_amount = 0 as u128;\n        for i in 0..MAX_NOTES {\n            if i < notes.len() {\n                total_amount += notes.get_unchecked(i).note.amount;\n            }\n        }\n        total_amount\n    }\n\n    /// Deposit `amount` of L2 token into private custody under `custody_id`\n    #[private]\n    fn deposit(custody_id: Field, amount: u128, nonce: Field) {\n        let caller = context.msg_sender();\n        let cfg = storage.config.read();\n\n        Token::at(cfg.token)\n            .transfer_in_private(caller, context.this_address(), amount, nonce)\n            .call(&mut context);\n\n        // Update custody balance by adding a new note owned by the caller\n        let new_note = CustodyNote::new(custody_id, amount, caller);\n        storage.custody_notes.at(caller).insert(new_note).emit(\n            dep::aztec::messages::logs::note::encode_and_encrypt_note(&mut context, caller, caller)\n        );\n    }\n\n    /// Withdraw `amount` of L2 token from private custody under `custody_id`\n    #[private]\n    fn withdraw(custody_id: Field, amount: u128) {\n        let caller = context.msg_sender();\n\n        // Pop notes to cover the withdrawal amount\n        let notes = storage.custody_notes.at(caller).pop_notes(\n            dep::aztec::prelude::NoteGetterOptions::new()\n                .set_limit(MAX_NOTES)\n                .select(CustodyNote::properties().custody_id, Comparator.EQ, custody_id)\n        );\n\n        let mut total_amount = 0 as u128;\n        for i in 0..MAX_NOTES {\n            if i < notes.len() {\n                total_amount += notes.get_unchecked(i).get_amount();\n                // Compute and push nullifier for each popped note to prevent double-spending\n                let note = notes.get_unchecked(i);\n                let note_hash = note.compute_note_hash(storage.custody_notes.at(caller).storage_slot);\n                let nullifier = note.compute_nullifier(&mut context, note_hash);\n                context.push_nullifier(nullifier);\n            }\n        }\n\n        assert(total_amount >= amount, \"Insufficient balance in custody\");\n\n        // If there's change, create a new note for the remaining amount\n        if total_amount > amount {\n            let change_note = CustodyNote::new(custody_id, total_amount - amount, caller);\n            storage.custody_notes.at(caller).insert(change_note).emit(\n                dep::aztec::messages::logs::note::encode_and_encrypt_note(&mut context, caller, caller)\n            );\n        }\n\n        // Transfer `amount` of L2 token back to caller (private)\n        let cfg = storage.config.read();\n        Token::at(cfg.token)\n            .transfer_in_private(context.this_address(), caller, amount, 0)\n            .call(&mut context);\n    }\n}\n"
    },
    "53": {
      "path": "/home/qbit/Desktop/work/otc-noirhack/contracts/psymm/src/types/custody_note.nr",
      "source": "use dep::aztec::{\n    context::PrivateContext,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize},\n        utils::arrays::array_concat,\n    },\n};\n\n/// A private note representing a custody balance associated with an account and custody ID.\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct CustodyNote {\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The ID of the custody under which this balance is held.\n    custody_id: Field,\n    /// The amount of tokens held in custody.\n    amount: u128,\n}\n\nimpl NoteHash for CustodyNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl CustodyNote {\n    pub fn new(custody_id: Field, amount: u128, owner: AztecAddress) -> Self {\n        let randomness = unsafe { random() };\n        Self { owner, randomness, custody_id, amount }\n    }\n\n    pub fn get_custody_id(self) -> Field {\n        self.custody_id\n    }\n\n    pub fn get_amount(self) -> u128 {\n        self.amount\n    }\n}\n"
    },
    "55": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "56": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "64": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "65": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "66": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "70": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "82": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "85": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "86": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "87": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "91": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "92": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "95": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "96": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "99": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    }
  }
}
