{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "pSymm",
  "functions": [
    {
      "name": "get_config",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5276036973553878575": {
            "error_kind": "string",
            "string": "Function get_config can only be called statically"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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q23LXm1b9mrbslfblr3atuzVtmWvti17tW3Zq23LXm1b9mrbslfblr3atuzVtmWvti17tW3Zq23LXm1b9mrbslfblr3atuzVtmWvti17tW3Zq23LXm1b9mrbslfblr3atuzVtmWvti17tW3Zq23LXm1b9mrbslfblr3atuzVtmWvti17tW3Zq23LXm1b9mrbslfblr3atuzVtmWvti17tW3Zq23LXm1b9mrbslfblr3atuzVtmWv9iR7zcfDe7cAzRROO6mSGI/Tsv12WmnHWab3WdyG4+caTphrOHGu4aS5hpOnGs5ZFj9qOGau4di5huPmGs5cV+U811U5z3VVznNdlfNcV+U81VXZbVNdld021VXZbb2vym9fxXQbj5tsPDTZePxk4wmTjSdONp6Pr83303LTaWZrO614TbrdV9y38LjdvfMVaCZEd7zdN8Tw2FintNPBzbzum8jcroiu8tlh244NsDb3+DF53r7Gbycfv992AYJ37nX8Tvj4Sfj4vfDxB+Hjj8LHn4SPP8sef/mRFEHjn339rY1f+Pprha+/Vvj6a4Wvv1b4+muFr79W+Pprha+/Tvj664Svv074+uuEr79O+PrrhK+/Tvj664Svv074+uuEr78kfP0l4esvCV9/Sfj6S8LXXxK+/pLw9ZeEr78kfP0l4euvF77+euHrrxe+/nrh668Xvv564euvF77+euHrrxe+/nrh628Qvv4G4etvEL7+BuHrbxC+/gbh628Qvv4G4etvEL7+BuHrbxS+/kbh628Uvv5G4etvFL7+RuHrbxS+/kbh628Uvv5G4etvEr7+JuHrbxK+/ibh628Svv4m4etvEr7+JuHrbxK+/ibh628Wvv5m4etvFr7+ZuHrbxa+/mbh628Wvv5m4etvFr7+ZtnrL22y11/aZK+/tMlef2mTvf7SJnv9pU32+kub7PWXNtnrL22y11/ahK+/Rvj6O/3+V7XxC19/he9/RcL3vyLh+1+R8P2vSPj+VyR8/ysSvv8VCd//ioTvf0XC978i4ftfkfD9r0j4/lckfP8rEr7/FQnf/4qE739Fwve/IuH7X5Hw/a9I+P5XJHz/KxK+/xUJ3/+KhO9/RcL3vyLh+1+R8P2vSPj+VyR8/ysSvv8VCd//ioTvf0XC978i4ftfkfD9r0j4/lckfP8rEr7/FQnf/4qE739Fwve/IuH7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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "deposit",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "custody_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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lv8+pKn64fuQpmoW70OaqpO6D4nmG9JUa/B9SFMtUPchzXf1NvNdvc18V28739Xbznf1tvNdved6x/19SPNdved69/p9SPNdved6J/h9SPNdved6V/XvIc313uf7kOa7es/1PuL7kOa7es/1ntz7kOa7es/1/tb7kOa7es/1XtH7kOa7es/1vsv7kOa7es/1Hsb7kOa7es/1fsD7kOa7es/13rr7kOa7es/1PrX7kOa7es/1nq/7kOa7es/1/qn7kOa7es/1XqT7kOa7es/1vp77kOa7es/1Hpn7kOa7es/1fpP7kOa7es/13o37kOa7es/1Poj7kOa7es/1noL7kOa7es+1f/59SPNdvefa1/0+pPmu3nPtN34f0nxX77n2wb4Pab6r91z7M9+HNN/Ve659g+9Dmu/qPdd+tvchzXf1nms/0fuQ5rt6z7Wf431I812959pP7z6k+a7ec+1ndh/SfFfvufaTug9pvqv3XPv53Ic039V7rv1U7kOa7+o912YZ9yHNd/Wea5uF+5Cmu3qnuX6gfx/SdFfvNNdPu+9Dmu7qnbbprt5prl/M3oc03dU7zfdbyzTfby3TfL+1TPP91jLN91vLNN9vLdN8v7VM8/3WMs33W8s0328t03y/tUzz/dYyzfdbyzTfby3TfL+1TPP91jLN91vLNN9vLdN8v7VM8/3WMs33W8vE9JumLT6GZOLTkO5f8vH1+Pdpn/9G5n6aaTvNtp3m2k6jttN822mh7bTYdlpqO62tSnxblfi2KvFtVeLbqsS3VYlvqxLfViW+rUp8W5X4tioJbVUS2qoktFVJaKuS0FYloa1KQluVhLYqCW1VEtqqJLZVSWyrkthWJbGtSmJblcS2KoltVRLbqiS2VUlsq5LUViWprUpSW5WktipJbVWS2qoktVVJaquS1FYlqa1KcluV5LYqyW1VktuqJLdVSW6rktxWJbmtSnJbleSmKsnb1naaaTvNtp3m2k6jttN822mh7bTYdlqxSigcp31748zjtFw+zTxOs9t/vrfbt3uvXwffjPVxrE2mcGxOe1aQ8/djfw+nfE9p3HDMXMOxcw3HzTUcmms4fq7hhLmGE+caTpprOHNdle1cV2U711XZznVVtr2vymE/1mybLYyHJhuPn2w8YbLxxMnGk+YaD9MGjm9vUGWmLRkrX0I9voTnRiyZx5f4/PQl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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "random",
        "notify_created_note_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "withdraw",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "custody_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "length": 17,
            "item_types": []
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13107192312614724151": {
            "error_kind": "string",
            "string": "Return notes not sorted in descending order."
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15238796416211288225": {
            "error_kind": "string",
            "string": "Balance too low"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7L3dciTJll73Lud6LsLdd/z4vIpMJqNEUkYz2lAmHl3R+O5CFzoTKCIHCXR571jlse6KY06czG/tytrf8kT0//jHf/xP/+f/93//H//l3/7zf/vv//jX/+1//OO//rf/6z/887/8t397+X/9j3+U+PF/++//z3/4tz/+n//9n//h//3nP/61rrH/yz/+07/9x5c/bqX+z3/5x3/+L//1P/3jX/vxP//l4+Eay+1w3d4Ob/3B4bb09c/DrWzH54fL2tf48/TLn98dr0d99EpK3W6vpMT6dro//Olta7cfHmX56fT//i//KKvJ/DvJbCbz7ySzP0wmjvKWTPs8mSjl9vKjrG//Cy8h/fE/cPzd/wP90f9AaXW98SqtHevn/xMvx8v99Lq9HV4fHO693+amLEuJ9y/oEa5Y3/F690peX39dfvPXXx6//qPU+yvqe3n/+v/4/1UfjkXfb/9TbVnexmItj97z8jbZ5d0MlXV/+Lfs/iaWt7+9rTz6O7P3uP313XtvT/4+tv0GKtpblnV5lOX+9iGyr08Ol/0N01G2J4eX+08uy9HfH/4j7WbaiWmHaSemvZp2Ytrbr6ddjuP2P1Df7S+P017Xfns521Hf3mhZHv3sbe23w/vb+1xf/6Haf9+Xfjx96aV//tJrXdvb/rq+/x94sHHVt0msx/H54XK8TVePt8Nla49CKcftR6+1vq0Fpb7uBf0q77Qtl3mn5TLvtF7mnbbLvNO4zDtdL/NOt8u80/0y7/QyO1K7zI4Ul9mR4jI7UlxmR4rL7EgRl3mnl9mR4jI7UlxmR4rL7EhxmR1pvcyOtF5mR1ovsyOtl9mR1rjMO73MjrReZkdaL7MjrZfZkdbL7EjbZXak7TI70naZHWm7zI60xWXe6WV2pO0yO9J2mR1pu8yOtF1mR9ovsyPtl9mR9svsSPtldqQ9LvNOL7Mj7ZfZkfbL7Ej7RDtS67dfwFvj3ev4451+PL315fYWt972J6f7evs1sb6/O3uUHxlOtH2dleEx0V53WoYTbYynZTjRLnpahhNtuadlGGb4yxlOtJmfluFEO/9pGU7UJk7L0J7y6xnaU345w25P+fUM7Sm/nqE95dcztKf8eoZhhr+coT3l1zO0p/x6hvaUX8/QnvLrGdpTfjnDslhUBoRoUxkQolVlQIh2lQEhhiH+eoi2lQEhWlcGhGhfGRCihWVAiDaWXw+x2FgGhGhjGRCijWVAiDaWASGGIf56iDaWASHaWAaEaGMZEKKNZUCINpZfD7HaWAaEaGMZEKKNZUCINpYBIYYh/nqINpYBIdpYBoRoYxkQoo1lQIg2li+FeNz+U44vN/XHTyk+eNnrfv/P365//Mce/5fMZ/qvv/02mduH8jO3PuVnbtvKzzzMPD1zu1x+5la//MxtivmZWyzzM7eHpmc+039h87fJ3B6an7k9ND9ze2h+5mHm6ZnbQ/Mzt4fmZ24Pzc/cHpqfuT00PfOZ/ivGv03m9tD8zO2h+ZnbQ/MzDzNPz9wemp+5PTQ/c3tofub20PzM7aHpmc/0X4r/bTK3h+Znbg/Nz9wemp95mHl65vbQ/MztofmZ20PzM7eH5mduD03PfLeH5mduD83P3B6an7k9ND/zMPP0zO2h+ZnbQ/Mzt4fmZ24Pzc/cHpqe+WEPzc/cHpqfuT00P3N7aH7mYebpmdtD8zO3h+Znbg/Nz9wemp+5PTQ9824Pzc/cHpqfuT00P3N7aH7mYebpmdtD8zO3h+Znbg/Nz9wemp+5PTQ787rYQ/Mzt4fmZ24Pzc/cHpqfeZh5eub20PzM7aH5mdtD8zO3h+Znbg9Nz7zYQ/Mzt4fmZ24Pzc/cHpqfeZh5eub20PzM7aH5mdtD8zO3h+Znbg9Nz7zaQ/Mzt4fmZ24Pzc/cHpqfeZh5eub20PGZb+X2Ql5e6fYxc3vo8MxfSs9bIPEgc3vo+MzjuL3HGr1/zNwemp+5PTQ982YPzc/cHjo+82257Yp1K/vHzO2h+ZnbQ/MzDzNPz9wemp+5PfRvyPw4boHspXzM3B46PvO93ed8X5ePmdtD8zO3h6ZnHvbQ/MztofmZ20PzM7eH5mceZp6euT00P3N7aH7m9tD8zO2h+ZnbQ9MzX+2h+ZnbQ//mzPcnp/ftlt6+v33/KOorHivr36va149fEVitrPmZh5mnZ25lzc/cypqfuZU1P3Mra37mVtb0zDcr6/DMW6y3F9LW8vFXMjYra37m9tD8zO2h+ZmHmadnbg/Nz9wemv6rR5s9ND9ze2h+5vbQ9Mx3e2j6r8Hs9tD8zO2h+ZnbQ/MzDzNPz9wemv5rjbs9NP0rX7s9ND9ze2h+5vbQ9MwPe2h+5vbQ/MztofmZ20PzMw8zT8/cHpqfuT00P3N7aH7m9tD8zO2h6Zl3eyj51xq7lTX9q+rdypqfuZU1P/Mw8/TMraz5mVtZ8zO3suZnbmXNz9zKOv5XMpZebumVFv9r5m2xsuZnbg/Nz9wemp+5PTQ/8zDz9MztofmZ20PH7+frm2pf92eno/Tjnsi7L7Zvr3zsrNm/Xt0WO2t+5nbW9MyLnTU/cztrfuZ21vzM7azZjxFoJcw8PXM7a37mdtb8zO2h2b/S3oo9ND9ze2h65tUemp+5PTQ/c3to9iNKWrWHZv/6Rqth5umZ20PzM7eH5mduD83P3B6an7k9ND3zZg/Nz9wemp+5PTQ/c3tofuZh5umZ20PzM7eH5mduDwU/oqQ1K2v2r522ZmVNzzysrPmZW1nzM7ey5mduZc3PPMw8PXMra37mVtb8zK2s+ZnbQ9N/pT3soemZr/bQ/MztofmZ20PzM7eH5mceZp6euT00P3N7aH7m9lD0I6dWOyubj/02/XEmm/02P3P7bX7m9tv8zO23+ZmHmadnbr9Nf2zPZr/Nz9x+m5+5nTU/c3to+iNkdntofub20PzM7aH5mdtD8zMPM89+JNhuD03/dcndHpqfuT00P3N7aH7m9tD0zA97aH7m9tD8zO2h+ZnbQ/MzDzNPz9wemp+5PTQ/c3tofub20PzM7aHkR4J1K2v6r793K2t+5lbW/MytrPmZh5mnZ25lzc/cypqfuZU1P3Mra37mVtbszGOxh2Y/ciAWe2h+5vbQ/MztofmZh5mnZ24Pzc/cHpqfuT00P3N7aH7m9lDyI6ei2FnZfOy32Y8ziWK/zc/cfpufeZh5eub22/zM7bf5mdtvsx/bE8V+m5+5/TY982pnzc/cHpr9CJmo9tD8zO2h+ZmHmadnbg/Nz9wemv1IsJcIzDz51yVf3reZp2duD03PvNlD8zO3h+Znbg/Nz9wemp95mHl65vbQ/MztofmZ20PzM7eH5mduD03PPOyh+ZnbQ8GPBIuwsqb/+ntYWfMzDzNPz9zKmp+5lTU/cytrfuZW1vzMrazpma9W1vzMraz5mdtD0x85sNpD8zMPM0/P3B6an7k9ND9ze2h+5vbQ/MztoemZb/bQ/MztoehHTm12VjYf+23640y2MPP0zO23+Znbb/Mzt9/mZ26/zc/cfpv+2J7dfpufuf02P3M7a37m9tD0R8jsYebpmdtD8zO3h+Znbg/Nz9wemv5IsN0emv7rkoc9ND9ze2h+5vbQ/MztofmZh5mnZ24Pzc/cHpqfuT00P3N7aH7m9tD0zLs9ND9ze2h+5vbQ/MztoeRHgvUQT/avv3cra37mVtb8zK2s+ZlbWfMzt7JmZ74uVtb8zK2s+ZlbWfMzt7LmZx5mnvzIgXWxh+Znbg/Nz9wemp+5PTQ/c3toeubFHpqfuT00P3N7aH7m9lDyI6fWEvJB87HfZj/O5OX/ZObpmdtv8zO33+Znbr9Nz7zab/Mzt99mP7Znrfbb/Mztt/mZh5mnZ24PzX6EzFrtofmZ20PzM7eH5mduD03PvNlDsx8JtjZ7aPavS77cfph5eub20PzMw8zTM7eH5mduD83P3B6an7k9ND9ze2h65mEPzc/cHpqfuT00P3N7aH7mYebpmdtDwY8Ee3kf4sn+9fewsuZnbmXNz9zKmp75amXNz9zKmp+5lTU/cytrfuZh5umZW1nzM7eHpj9yYLWH5mduD83P3B6anvlmD83P3B6an7k9ND9ze2h+5mHm6ZnbQ9GPnNrsrGw+9tv0x5ls9tv8zO236Znv9tv8zO23+Znbb/Mzt9+mP7ZnDzNPz9x+m5+5nTU/c3to+iNkdntofub20PTMD3tofub20PzM7aHpjwQ77KHpvy55hJmnZ24Pzc/cHpqfuT00P3N7aH7m9tD0zLs9ND9ze2h+5vbQ/MztofmZh5mnZ24Pzc/cHpqfuT2U/EiwbmVN//X3bmXNznxbrKz5mVtZ8zO3suZnbmXNzzzMPD1zK2t+5lbW/MytrPmZ20OzHzmwLfbQ9MyLPTQ/c3tofub20PzM7aH5mYeZp2duD83P3B6an7k9lPzIqa3YWdl87LfZjzPZqv02P3P7bX7m9tv8zO23+ZmHmadnbr/NfmzPVu23+Znbb/Mzt7PmZ24PzX6EzNbsofmZ20PzM7eH5mduD83PPMw8+ZFgW7OHZv+65NbsofmZ20PzM7eH5mduD03PPOyh+ZnbQ/Mzt4fmZ24Pzc88zDw9c3tofub20PzM7aH5mdtD8zO3h4IfCbatVtb0X39fraz5mVtZ8zO3suZnHmaenrmVNT9zK2t+5lbW/MytrPmZW1nTM9/soemPHNjsofmZ20PzM7eH5mceZp6euT00P3N7aH7m9tD8zO2h+ZnbQ9GPnNrtrGw+9tv0x5ns9tv8zO23+ZmHmadnbr/Nz9x+m5+5/Tb9sT27/TY/c/tteuaHnTU/c3to+iNkDntofub20PzMw8zTM7eH5mduD01/JNhhD03/dcnDHpqfuT00PfNuD83P3B6an7k9ND9ze2h+5mHm6ZnbQ/Mzt4fmZ24Pzc/cHpqfuT00O/N9sYfmZ24PBT8SbF+srNm//r4vVtb8zMPM0zO3suZnbmXNz9zKmp+5lTU/cytreubFypqfuZU1P3N7aPYjB/ZiD83PPMw8PXN7aH7m9tD8zO2h+ZnbQ/Mzt4emZ17tofmZ20PJj5zaq52Vzcd+m/04k72Gmadnbr/Nz9x+m5+5/TY/c/ttfub22+zH9uzNfpufuf02P3M7a37m9tDsR8jsLcw8PXN7aH7m9tD8zO2h+ZnbQ7MfCbY3e2j6r0uGPTQ/c3tofub20PzM7aH5mYeZp2duD83P3B6an7k9ND9ze2h+5vbQ9MxXe2h+5vbQ/MztofmZ20PJjwRbQzzZv/6+WlnzM7ey5mduZc3P3Mqan7mVNT3zzcqan7mVNT9zK2t+5lbW/MzDzLMfObDZQ/Mzt4fmZ24Pzc/cHpqfuT00PfPdHpqfuT00P3N7aH7m9lD0I6f2kA+aj/02/XEmu/02P3P7bX7m9tv8zO236Zkf9tv8zO236Y/tOey3+Znbb/MzDzNPz9wemv4ImcMemp+5PTQ/c3tofub20PTMuz00/ZFg3R6a/uuS3R6an7k9ND/zMPP0zO2h+ZnbQ/Mzt4fmZ24Pzc/cHpqd+bHYQ/Mzt4fmZ24Pzc/cHpqfeZh5eub2UPAjwY7Fypr96+/HYmXNz9zKmp+5lTU982Jlzc/cypqfuZU1P3Mra37mYebpmVtZ8zO3h2Y/cuAo9tD8zO2h+ZnbQ9Mzr/bQ/MztofmZ20PzM7eH5mceZp6euT2U/Mipo9pZ2Xzst9mPMzmq/TY/c/tteubNfpufuf02P3P7bX7m9tvsx/YcLcw8PXP7bX7mdtb8zO2h2Y+QOZo9ND9ze2h65mEPzc/cHpqfuT00+5FgR9hD039dMsLM0zO3h+Znbg/Nz9wemp+5PTQ/c3toeuarPTQ/c3tofub20PzM7aH5mYeZp2duD83P3B6an7k9lPxIsNXKmv7r76uVNT3zzcqan7mVNT9zK2t+5lbW/MzDzNMzt7LmZ25lzc/cypqfuT00/ZEDmz00PfPdHpqfuT00P3N7aH7m9tD8zMPM0zO3h+Znbg/Nz9wein7k1G5nZfOx36Y/zuSw3+Znbr/Nz9x+m5+5/TY/8zDz9Mztt+mP7Tnst/mZ22/zM7ez5mduD01/hEy3h+Znbg/Nz9wemp+5PTQ/8zDz7EeCdXto+q9Ldntofub20PzM7aH5mdtDszPviz00P3N7aH7m9tD8zO2h+ZmHmadnbg/Nz9wemp+5PTQ/c3tofub2UPAjwXqxsmb/+nsvVtb8zK2s+ZlbWfMzDzNPz9zKmp+5lTU/cytrfuZW1vzMrazpmVd7aPYjB3q1h+Znbg/Nz9wemp95mHl65vbQ/MztofmZ20PzM7eH5mduDyU/cqo3Oyubj/02+3Emvdlv8zO33+ZnHmaenrn9Nj9z+21+5vbb7Mf29Ga/zc/cfpueedhZ8zO3h2Y/QqaHPTQ/c3tofuZh5umZ20PzM7eHZj8SrIc9NP3XJcMemp+5PTQ989Uemp+5PTQ/c3tofub20PzMw8zTM7eH5mduD83P3B6an7k9ND9ze2h65ps9ND9zeyj5kWCblTX91983K2t+5mHm6ZlbWfMzt7LmZ25lzc/cypqfuZU1PfPdypqfuZU1P3N7aPojB3Z7aH7mYebpmdtD8zO3h+Znbg/Nz9wemp+5PTQ988Memp+5PRT9yKnDzsrmY79Nf5zJEWaenrn9Nj9z+21+5vbb/Mztt/mZ22/TH9vT7bf5mdtv8zO3s+Znbg9Nf4RMDzNPz9wemp+5PTQ/c3tofub20PRHgnV7aPavS5ZlsYieELpN9ITQraInhG4XPSH0MPT80G2jJ4RuHT0hdPvoCaFbSE8I3UaaH3qxkZ4Quo30hNBtpCeEbiMFPyDshU/IJ/m34V9Ct7yeELrl9YTQLa8nhG55PSF0y2t+6NXyekLoltcTQre8nhC65fWE0MPQk59F8BK6jfSE0G2kJ4RuIz0hdBvpCaHbSPNDbzbSE0K3kWb/GvtL6DbSE0K3kZ4Qehh6fug20hNCt5GeEPpVG+ne7qHv7f1e93L6NZmr1sbnyVy12z1NJq5awJ4nc9WWdCzb7S0epT5K5qpV5ljb7Wcf21KenF6Xdv/R777q+cesfczjKPdrnpcffT/d+qP3eNTj9o3GI949H+DfO11u//4e9Y/M/jz98kMe/b3ocTu9996enG5vZN79HarLo7f4IiNub7HV7fPDpbXb4dLev+aHh18+xe4LxtHfH36d16u2QOf195zXcF6d199oXq/qHpzXX5nX/T5VdV+fHC77G8WjbL84r1fVNs7r7zmvVzVef9+8tmXp9/DeverHE1jKut4GtpTtKE7sk4m9qon85sRu9x/djycTG295vLzFd1am/enF46qO88TM16va0zMzv6yX/Vbmx3L/J2hvz7a3Vm+Ha0R58i/Q5f91W/XfTuC5E6jR/soE9nr7ImRf1ycTuC77/XW8XBg/+HcnzDw9c83ilz5pj7vMXZbt2Udt2e4ftfXdd3f8qH38UassTB3B19Ava7y2t79u2/sHRD3+rN33m3Xte3/72Vt9GHqst/he/nz8dPw19ctam1NT19vkf8BsipsTQvcbdf/ON+q2yxqFtr67CXx2utblfstY3//30B+eLuXuFErZn4361pdbcdn6T//NnYdbccR9K97q+8OvPC/bzyflGfKciudlvcKkPC9b0ifledn+PynPy5qFSXle1lnMyXO/rA6ZlOdlTcukPPVDc/HUD83FM+Q5FU/90Fw89UNz8dQPzcVTPzQXT/3QVDwP/dBcPPVDc/HUD83FUz80F8+Q51Q89UNz8dQPzcVTPzQXT/3QXDz1Q1Px7PqhuXjqh+biqR+ai6d+aC6eIc+peOqH5uKpH5qLp35oLp76obl46odm4lkW/dBcPPVDc/HUD83FUz80F8+Q51Q89UNz8dQPzcVTPzQXT/3Q2Tz3GrefvdctPiJS+dARFS0OHpFi5nxE/fafltxbeYBI14JHpD7BIwoR0REpOfCI9BZ4RKoIPCLtAr4XaRfoiKp2AY9Iu4BHpF3AI9Iu0De6GiKiI9Iu4BFpF/CItAt4RNoFPCLtAh1R0y6cjqj02+mXP24fEWkX6NW1aRfwiLQLeEQhIjoi7QIekXYBv3RrF/CItAt4RNoFOqLQLuARaRfwiLQLeETaBTyiEBEdkXaBfhkR2gW6AArtAh6RdgGPSLtAR7RqF/CItAv0pXvVLuARaRfwiEJEdETaBTwi7QIekXYBj0i7gEekXaAj2rQL9MuITbtAF0CbdgGPSLuARxQioiPSLuARaRfwS7d2AY9Iu4BHpF2gI9q1C3hE2gU8Iu0CHpF2AY8oRERHpF2gX0bs2gW6ANq1C3hE2gU8Iu0CHdGhXcAj0i7Ql+5Du4BHpF3AIwoR0RFpF/CItAt4RNoFPCLtAh6RdoGOqGsX6JcRXbtAF0Bdu4BHpF3AIwoR0RFpF/CItAv4pVu7gEekXcAj0i7AEdVFu4BHpF3AI9Iu4BFpF/CIQkR0RNoF+GVEXbQLcAFUF+0CHpF2AY9Iu0BHVLQLeETaBfrSXbQLeETaBTyiEBEdkXYBj0i7gEekXcAj0i7gEWkX6IiqdoF+GVG1C3QBVLULeETaBTyiEBEdkXYBj0i7gF+6tQt4RNoFPCLtAh1R0y7gEWkX8Ii0C3hE2gU8ohARHZF2gX4Z0bQLdAHUtAt4RNoFPCLtAh1RaBfwiLQL9KU7tAt4RNoFPKIQER2RdgGPSLuAR6RdwCPSLuARaRfoiFbtAv0yYtUu0AXQql3AI9Iu4BGFiOiItAt4RNoF/NKtXcAj0i7gEWkX6Ig27QIekXYBj0i7gEekXcAjChHREWkX6JcRm3aBLoA27QIekXYBj0i7QEe0axfwiLQL9KV71y7gEWkX8IhCRHRE2gU8Iu0CHpF2AY9Iu4BHpF2gIzq0C/TLiEO7QBdAh3YBj0i7gEcUIqIj0i7gEWkX8Eu3dgGPSLuAR6RdoCPq2gU8Iu0CHpF2AY9Iu4BHFCKiI9Iu0C8junaBLoC6dgGPSLuAR6RdgCNqi3YBj0i7AF+626JdwCPSLuARhYjoiLQLeETaBTwi7QIekXYBj0i7QEdUtAvwy4hWtAt0AVS0C3hE2gU8ohARHZF2AY9Iu4BfurULeETaBTwi7QIdUdUu4BFpF/CItAt4RNoFPKIQER2RdoF+GVG1C3QBVLULeETaBTwi7QIdUdMu4BFpF+hLd9Mu4BFpF/CIQkR0RNoFPCLtAh6RdgGPSLuAR6RdoCMK7QL9MiK0C3QBFNoFPCLtAh5RiIiOSLuAR6RdwC/d2gU8Iu0CHpF2gY5o1S7gEWkX8Ii0C3hE2gU8ohARHZF2gX4ZsWoX6AJo1S7gEWkX8Ii0C3REm3YBj0i7QF+6N+0CHpF2AY8oRERHpF3AI9Iu4BFpF/CItAt4RNoFOqJdu0C/jNi1C3QBtGsX8Ii0C3hEISI6Iu0CHpF2Ab90axfwiLQLeETaBTqiQ7uAR6RdwCPSLuARaRfwiEJEdETaBfplxKFdoAugQ7uAR6RdwCPSLtARde0CHpF2gb50d+0CHpF2AY8oRERHpF3AI9Iu4BFpF/CItAt4RNoFOKJYtAvwy4hYtAtwARSLdgGPSLuARxQioiPSLuARaRfwS7d2AY9Iu4BHpF2gIyraBTwi7QIekXYBj0i7gEcUIqIj0i7QLyOKdoEugIp2AY9Iu4BHpF2gI6raBTwi7QJ96a7aBTwi7QIeUYiIjki7gEekXcAj0i7gEWkX8Ii0C3RETbtAv4xo2gW6AGraBTwi7QIeUYiIjki7gEekXcAv3doFPCLtAh6RdoGOKLQLeETaBTwi7QIekXYBjyhEREekXaBfRoR2gS6AQruAR6RdwCPSLtARrdoFPCLtAn3pXrULeETaBTyiEBEdkXYBj0i7gEekXcAj0i7gEWkX6Ig27QL9MmLTLtAF0KZdwCPSLuARhYjoiLQLeETaBfzSrV3AI9Iu4BFpF+iIdu0CHpF2AY9Iu4BHpF3AIwoR0RFpF+iXEbt2gS6Adu0CHpF2AY9Iu0BHdGgX8Ii0C/Sl+9Au4BFpF/CIQkR0RNoFPCLtAh6RdgGPSLuAR6RdoCPq2gX6ZUTXLtAFUNcu4BFpF/CIQkR0RNoFPCLtAn7p1i7gEWkX8Ii0C3BE66JdwCPSLuARaRfwiLQLeEQhIjoi7QL8MmJdtAtwAbQu2gU8Iu0CHpF2gY6oaBfwiLQL9KW7aBfwiLQLeEQhIjoi7QIekXYBj0i7gEekXcAj0i7QEVXtAv0yomoX6AKoahfwiLQLeEQhIjoi7QIekXYBv3RrF/CItAt4RNoFOqKmXcAj0i7gEWkX8Ii0C3hEISI6Iu0C/TKiaRfoAqhpF/CItAt4RNoFOqLQLuARaRfoS3doF+hLd2gX8B90ISI6Iu0CHpF2AY9Iu4BHpF3AL93aBfrSvWoX6B90q3YBj0i7gEekXcAjChHREWkX6Ev3ql3AI9Iu4BFpF/CItAunI4r76Zc/7h8QbdoFPCLtwpcQteV2ura9DkW09aX8eXrr5SdED152jdubPOpWP/JURczFU28xF8+Q51Q8NSJz8VSfzMVT1zIXT8XMXDy1OFPx3FU+c/HUD83FUz80F0/90Fw8Q55T8dQPzcVTPzQXT/3QXDz1Q3Px1A9NxfPQD83FUz80F0/90Fw89UNz8Qx5TsVTPzQXT/3QXDz1Q3Px1A/NxVM/NBXPrh+ai6d+aC6e+qG5eOqH5uIZ8pyKp35oLp76obN5PnvIVVf54BFpcfCIFDPnI/r0CUrbomvBI1Kf4BFpRPCIlBx4RCEiOiJVBB6RdgHei7ZFu4BHpF3AI9Iu0BEV7QIekXaBvtEV7QIekXYBjyhEREekXcAj0i7gEWkX8Ii0C6cj+vy/irsV7QK9ulbtAh6RdgGPSLuAR6RdwCMKEcGX7qpdwCPSLuARaRfwiLQLeETaBTqipl3AI9Iu4BFpF/CItAv0y4gWIoILoKZdwCPSLuARaRfwiLQLeETaBfrSHdoFPCLtAh6RdgGPSLuARxQioiPSLuARaRfwiLQLeETaBfplRGgX6AJo1S7gEWkX8Ii0C3hE2gU8ohARfOletQt4RNoFPCLtAh6RdgGPSLtAR7RpF/CItAt4RNoFPCLtAv0yYgsRwQXQpl3AI9Iu4BFpF/CItAt4RNoF+tK9axfwiLQLeETaBTwi7QIeUYiIjki7gEekXcAj0i7gEWkX6JcRu3aBLoAO7QIekXYBj0i7gEekXcAjChHBl+5Du4BHpF3AI9Iu4BFpF/CItAt0RF27gEekXcAj0i7gEWkX6JcRPUQEF0Bdu4BHpF3AI9Iu4BFpF/CItAvwpXtftAt4RNoFPCLtAh6RdgGPKERER6RdwCPSLuARaRfwiLQL8MuIfdEuwAXQXrQLeETaBTwi7QIekXYBjyhEBF+6i3YBj0i7gEekXcAj0i7gEWkX6IiqdgGPSLuAR6RdwCPSLtAvI2qICC6AqnYBj0i7gEekXcAj0i7gEWkX6Et30y7gEWkX8Ii0C3hE2gU8ohARHZF2AY9Iu4BHpF3AI9Iu0C8jmnaBLoBCu4BHpF3AI9Iu4BFpF/CIQkTwpTu0C3hE2gU8Iu0CHpF2AY9Iu0BHtGoX8Ii0C3hE2gU8Iu0C/TJiDRHBBdCqXcAj0i7gEWkX8Ii0C3hE2gX60r1pF/CItAt4RNoFPCLtAh5RiIiOSLuAR6RdwCPSLuARaRfolxGbdoEugHbtAh6RdgGPSLuAR6RdwCMKEcGX7l27gEekXcAj0i7gEWkX8Ii0C3REh3YBj0i7gEekXcAj0i7QLyOOEBFcAB3aBTwi7QIekXYBj0i7gEekXaAv3V27gEekXcAj0i7gEWkX8IhCRHRE2gU8Iu0CHpF2AY9Iu0C/jOjaBbgAOhbtAh6RdgGPSLuAR6RdwCMKEbGX7mPRLuARaRfwiLQLeETaBTwi7QIdUdEu4BFpF/CItAt4RNoF+GXEUUJEcAFUtAt4RNoFPCLtAh6RdgGPSLtAX7qrdgGPSLuAR6RdwCPSLuARhYjoiLQLeETaBTwi7QIekXaBfhlRtQt0AdS0C3hE2gU8Iu0CHpF2AY8oRARfupt2AY9Iu4BHpF3AI9Iu4BFpF+iIQruAR6RdwCPSLuARaRfolxERIoILoNAu4BFpF/CItAt4RNoFPCLtAn3pXrULeETaBTwi7QIekXYBjyhEREekXcAj0i7gEWkX8Ii0C/TLiFW7QBdAm3YBj0i7gEekXcAj0i7gEYWI4Ev3pl3AI9Iu4BFpF/CItAt4RNoFOqJdu4BHpF3AI9Iu4BFpF+iXEXuICC6Adu0CHpF2AY9Iu4BHpF3AI9Iu0JfuQ7uAR6RdwCPSLuARaRfwiEJEdETaBTwi7QIekXYBj0i7QL+MOLQLdAHUtQt4RNoFPCLtAh6RdgGPKEQEX7q7dgGPSLuAR6RdwCPSLuARaRfgiPqiXcAj0i7gEWkX8Ii0C/DLiL6EiNgCqC/aBTwi7QIekXYBj0i7gEekXaAv3UW7gEekXcAj0i7gEWkX8IhCRHRE2gU8Iu0CHpF2AY9Iu0C/jCjaBboAqtoFPCLtAh6RdgGPSLuARxQigi/dVbuAR6RdwCPSLuARaRfwiLQLdERNu4BHpF3AI9Iu4BFpF+iXES1EBBdATbuAR6RdwCPSLuARaRfwiLQL9KU7tAt4RNoFPCLtAh6RdgGPKERER6RdwCPSLuARaRfwiLQL9MuI0C7QBdCqXcAj0i7gEWkX8Ii0C3hEISL40r1qF/CItAt4RNoFPCLtAh6RdoGOaNMu4BFpF/CItAt4RNoF+mXEFiKCC6BNu4BHpF3AI9Iu4BFpF/CItAv0pXvXLuARaRfwiLQLeETaBTyiEBEdkXYBj0i7gEekXcAj0i7QLyN27QJdAB3aBTwi7QIekXYBj0i7gEcUIoIv3Yd2AY9Iu4BHpF3AI9Iu4BFpF+iIunYBj0i7gEekXcAj0i7QLyN6iAgugLp2AY9Iu4BHpF3AI9Iu4BFpF9hLd10W7QIekXYBj0i7gEekXcAjChHREWkX8Ii0C3hE2gU8Iu0C+zLiBZF2gS2A6lK0C3hE2gU8Iu0CHpF2AY8oRARfuot2AY9Iu4BHpF3AI9Iu4BFpF+iIqnYBj0i7gEekXcAj0i7QLyNqiAgugKp2AY9Iu4BHpF3AI9Iu4BFpF+hLd9Mu0Jfupl2gf9A17QIekXYBjyhEREekXcAj0i7gl27tAn7p1i7gP+i0C3REoV3AI9Iu4BFpF/CItAv0pTtCRHRE2gU8Iu0CHpF24XREcT/98sf9IyLtAh6RduFriHq5vcdY+k+nf+S4qgDG5GhPH5OjZXpMjjbeMTmGOQ7J0e74pRxfXuw9x3Y8Od3bcXslPZaflqSPh1s7br2ktf7u8P7o8FL3O5jW3h9+xWnPnAqnnXQqnPbXqXDadX8rnGW9vY5W9v4B52blngqnzX8qnAqI3wtnv+OspX1+uG713lK39uRw6a08zPo2KBoWB+XH4WW5gfnjKRmfH173G/G19/dv73WmwplypgbPlObNmRo9U+o/Z+p1pmK7z9TWf2mmdJDO1OiZUoQ6Uz8Ov7X+Wo74WOZUrA7KVwZlV946KF8aFLWwg/JK8f4yaqvH54dLu+8zpfXycaq0007V+KlSZTtV35+qtdwOlzXqr/S0PRxAB/DMAVSSO4CnDqBG3QH8CwO43b+jsP5cQr89gOp3B/DUAdTVTzyA634fwGdXOs++eLXr6h2UH4fHfaHhUOs7U6NnyhsAZ+p1poZ9oeHQ/ztTo2dK++9M/Tj85Er7CAfFQfnKoGjTHZQvDYrW20H5vnR88nWGQ5XtVI2fKv20U/X9qRp3RXzovR3AMwewK8kdwFMHUKPuAP6FARz2HYWufncATx1AXf28A7i32yPv6779Ylvt4aA4KF8ZFF29gzJ6T1frO1OjZ0qp70yNnimVvjM1uqFp6Z2psTNVFsX7bzVTdY/7TB3PTNLAZxKXRUHuoPw4POzXGMqi83amRs+UGtuZGj1T4Uw5Uz9matSvxpRFOe5MjZ4p5bgz9ePw578cURaNt4PypUFRYzsoXxoU3bSD8kpx3C/GlKKddqrGT5Uq26n6/lQN+3JAKXpvB/DUAVSSO4CnDmA4gA7g9wdw2PdeivrdATx1AHX1Ew/guGcSl6Krd1B+HB73hYai1nemRs+UNwDO1OtMDftCQ9X/O1OjZ0r770z9OPzkSrtq6R2ULw2KNt1B+dKghIPioHxbOj75OkNVZTtV46dKP+1UfX+qxl0RV723A3jqACrJHcBTB1Cj7gD+hQEc9h2Fpn53AE8dQF39vAM48FGzpenqHZQvDYqu3kEZvKe3cKacqcEzpdR3pkbPlErfmRrd0LT0ztTomVK8f2mmtuUuZbZSfzr9mqP+eEiOcVkNurbbzz62pTw5vS73v9SxvJ1t8SiPo9w/D19+9P1064/e41GPdzz3p6fL7WPrqOsbz5cf8uD03uN2eu+9PTnd3si0t8+4ujx6i620N2e6fX74xUu8aYv3r/nh4SVur6Is7z7EXw6/zutlranz+gvzut+nqu7rk8Nlf6N4lO0X5/Wy8tZ5/S3n9bIO+W+b17bcd7C2vHvVjyewlPW+4JWyHcWJfTKx4cR+ZWK3+4/ux5OJjbc8Xt7iu77byp+ZX9bgnpj5ZQ3niZlf1gB+K/Njuf8TtLdn21urd/EWUZ78C+S/bpf1hd+awH5/KlJf1ycTuC53T7yWpT34W39Zt3he5qse8kuftMddpS3L9uyjtmz3j9radj9qP/+oXVWLqSP4Gvpl/dj29tdtW5dnn7X7fnNefe9vP3urD0OP9f5EkZcN4qfjr6lf1vKcmnqY+gmpX9ZVnJr6ZW3F91I/7m64H+++Afcw9e1Yby9kO/a3f6e3PyO/rKw4L/LLtvPzIr9sOT8t8u2y3fy8yC/bRf/GyPtdU2+97h8it4mmR24NTY88jDw7cgtoeuS2z/TIbZ/pkds+0yO3fWZHvts+0yO3faZHbvtMj9z2mR55GPn4yONuEvv6MXLbZ3rkts/0yG2f6ZHbPtMjt31mR37YPtMjt32mR277TI/c9pkeeRh5duS2z/TIbZ/pkds+0yO3faZHbvvMjrzbPtMjt32mR277TI/c9pkeeRh5duS2z/TIbZ/pkds+0yO3faZHbvtMjrwuts/0yG2f6ZHbPtMjt32mRx5Gnh257TM9cttneuS2z/TIbZ/pkds+syMvts/0yG2f6ZHbPtMjt32mRx5Gnh257TM9cttneuS2z/TIbZ/pkds+syOvts/0yG2f6ZHbPtMjt32mRx5Gnh257TM9cttneuS2z/TIbZ/pkds+syNvts/0yG2f6ZHbPtMjt32mRx6XjbzXW+T7cjw5/fmTg2u7bqEcmeJ1O+LIFK9b+0ameN0mNzLF65az76X46b/Rcd2+NTLF61aokSletxWNTPG6RWdkimGKA1K0u4xI0e4yIkW7y4gU7S4jUrS7DEhxtbuMSNHuMiJFu8uIFO0uI1IMUxyQ4mW7y7Ld3uJRavx0+jWZy/aRtt7nK8qz0388ruL+Hvdn01hKvdnuUvbydHaXcp/d8ja75eHLrvdBP+pW3x9+5XnZZjQpz8t2tEl5XrYtzslzu2xvnZTnZRv0pDwv2+Un5XlZqzApz5DnVDwva1om5akfmounfmgunvqhuXjqh6biueuH5uKpH5qLp35oLp76obl4hjyn4qkfmounfmgunvqhuXjqh+biqR+aiuehH5qLp35oLp76obl46ofm4hnynIqnfmgunvqhuXjqh+biqR+ai6d+aCqeXT80F0/90Fw89UNz8dQPzcUz5DkVT/3QXDz1Q3Px1A/NxVM/NBdP/dBMPNuiH5qLp37obJ57jdvP3usWHxGpfPCItDh4RCGi0xH1238fdG/lASJdCx6R+gSPSCOCR6TkwCPSW9ARFVUEHpF2gd6LinYBj0i7gEcUIqIj0i7gEWkX8BuddgGPSLuAR6RdoCOq2gU8Iu0CHpF2AY9Iu3A6otJvp1/+uH1EFCKCV9eqXcAj0i7gEWkX8Ii0C3hE2gX60t20C3hE2gU8Iu0CHpF2AY8oRERHpF3AI9Iu4BFpF/CItAv0y4imXaALoNAu4BFpF/CItAt4RNoFPKIQEXzpDu0CHpF2AY9Iu4BHpF3AI9Iu0BGt2gU8Iu0CHpF2AY9Iu0C/jFhDRHABtGoX8Ii0C3hE2gU8Iu0CHpF2gb50b9oFPCLtAh6RdgGPSLuARxQioiPSLuARaRfwiLQLeETaBfplxKZdoAugXbuAR6RdwCPSLuARaRfwiEJE8KV71y7gEWkX8Ii0C3hE2gU8Iu0CHdGhXcAj0i7gEWkX8Ii0C/TLiCNEBBdAh3YBj0i7gEekXcAj0i7gEWkX6Et31y7gEWkX8Ii0C3hE2gU8ohARHZF2AY9Iu4BHpF3AI9Iu0C8junYBLoBi0S7gEWkX8Ii0C3hE2gU8ohARe+mORbuAR6RdwCPSLuARaRfwiLQLdERFu4BHpF3AI9Iu4BFpF+CXEVFCRHABVLQLeETaBTwi7QIekXYBj0i7QF+6q3YBj0i7gEekXcAj0i7gEYWI6Ii0C3hE2gU8Iu0CHpF2gX4ZUbULdAHUtAt4RNoFPCLtAh6RdgGPKEQEX7qbdgGPSLuAR6RdwCPSLuARaRfoiEK7gEekXcAj0i7gEWkX6JcRESKCC6DQLuARaRfwiLQLeETaBTwi7QJ96V61C3hE2gU8Iu0CHpF2AY8oRERHpF3AI9Iu4BFpF/CItAv0y4hVu0AXQJt2AY9Iu4BHpF3AI9Iu4BGFiOBL96ZdwCPSLuARaRfwiLQLeETaBTqiXbuAR6RdwCPSLuARaRfolxF7iAgugHbtAh6RdgGPSLuAR6RdwCPSLtCX7kO7gEekXcAj0i7gEWkX8IhCRHRE2gU8Iu0CHpF2AY9Iu0C/jDi0C3QB1LULeETaBTwi7QIekXYBjyhEBF+6u3YBj0i7gEekXcAj0i7gEWkX4IjWRbuAR6RdwCPSLuARaRfglxHrEiJiC6B10S7gEWkX8Ii0C3hE2gU8Iu0Cfeku2gU8Iu0CHpF2AY9Iu4BHFCKiI9Iu4BFpF/CItAt4RNoF+mVE0S7QBVDVLuARaRfwiLQLeETaBTyiEBF86a7aBTwi7QIekXYBj0i7gEekXaAjatoFPCLtAh6RdgGPSLtAv4xoISK4AGraBTwi7QIekXYBj0i7gEekXaAv3aFdwCPSLuARaRfwiLQLeEQhIjoi7QIekXYBj0i7gEekXaBfRoR2gS6AVu0CHpF2AY9Iu4BHpF3AIwoRwZfuVbuAR6RdwCPSLuARaRfwiLQLdESbdgGPSLuAR6RdwCPSLtAvI7YQEVwAbdoFPCLtAh6RdgGPSLuAR6RdoC/du3YBj0i7gEekXcAj0i7gEYWI6Ii0C3hE2gU8Iu0CHpF2gX4ZsWsX6ALo0C7gEWkX8Ii0C3hE2gU8ohARfOk+tAt4RNoFPCLtAh6RdgGPSLtAR9S1C3hE2gU8Iu0CHpF2gX4Z0UNEcAHUtQt4RNoFPCLtAh6RdgGPSLsAX7q3RbuAR6RdwCPSLuARaRfwiEJEdETaBTwi7QIekXYBj0i7AL+M2BbtAlwAbUW7gEekXcAj0i7gEWkX8IhCRPClu2gX8Ii0C3hE2gU8Iu0CHpF2gY6oahfwiLQLeETaBTwi7QL9MqKGiOACqGoX8Ii0C3hE2gU8Iu0CHpF2gb50N+0CHpF2AY9Iu4BHpF3AIwoR0RFpF/CItAt4RNoFPCLtAv0yomkX6AIotAt4RNoFPCLtAh6RdgGPKEQEX7pDu4BHpF3AI9Iu4BFpF/CItAt0RKt2AY9Iu4BHpF3AI9Iu0C8j1hARXACt2gU8Iu0CHpF2AY9Iu4BHpF2gL92bdgGPSLuAR6RdwCPSLuARhYjoiLQLeETaBTwi7QIekXaBfhmxaRfoAmjXLuARaRfwiLQLeETaBTyiEBF86d61C3hE2gU8Iu0CHpF2AY9Iu0BHdGgX8Ii0C3hE2gU8Iu0C/TLiCBHBBdChXcAj0i7gEWkX8Ii0C3hE2gX60t21C3hE2gU8Iu0CHpF2AY8oRERHpF3AI9Iu4BFpF/CItAv0y4iuXYALoH3RLuARaRfwiLQLeETaBTyiEBF76d4X7QIekXYBj0i7gEekXcAj0i7QERXtAh6RdgGPSLuAR6RdgF9G7CVEBBdARbuAR6RdwCPSLuARaRfwiLQL9KW7ahfwiLQLeETaBTwi7QIeUYiIjki7gEekXcAj0i7gEWkX6JcRVbtAF0BNu4BHpF3AI9Iu4BFpF/CIQkTwpbtpF+hLd9Mu4D/otAt4RNoFPCLtAh1RaBfwiLQL9KU7tAv0pTu0C/gPuhARHZF2AY9Iu4BHpF3AI9Iu4Jdu7QId0apdwCPSLuARaRdORxT30y9/3D8i0i7gEYWIvoKoLbfTte11KKKtL+XP01svPyF68LJr3N7kUbf6kacqYi6eeou5eCo55uKpEZmLp/pkKp6brmUunoqZuXhqcebiqfKZi2fIcyqe+qG5eOqH5uKpH5qLp35oLp76oal47vqhuXjqh+biqR+ai6d+aC6eIc+peOqH5uKpH5qLp35oLp76obl46oem4nnoh+biqR+ai6d+aC6e+qG5eIY8p+KpH5qLp35oLp76obl46ofm4qkfOpvns4dcdZUPHpEWB49IMXM+os+foNR1LXhEISI6Io0IHpGSA49Ib4FHpIrAI9IuwHvRsWgX8Ii0C3hE2gU8Iu0CHlGIiL3RHYt2AY9Iu4BHpF3AI9Iu4BFpF+iIinYBj0i7cDqiz/+ruEfRLtCra9Eu4BGFiOiItAt4RNoFPCLtAn7p1i7gEWkX6IiqdgGPSLuAR6RdwCPSLuARhYjoiLQLeETaBfplRNUu0AVQ1S7gEWkX6IiadgGPSLuAR6RdoC/dTbuARxQioiPSLuARaRfwiLQLeETaBTwi7QIdUWgX8Ii0C/TLiNAu0AVQaBfwiEJEdETaBTwi7QIekXYBv3RrF/CItAt0RKt2AY9Iu4BHpF3AI9Iu4BGFiOiItAt4RNoF+mXEql2gC6BVu4BHpF2gI9q0C3hE2gU8Iu0CfenetAt4RCEiOiLtAh6RdgGPSLuAR6RdwCPSLtAR7doFPCLtAv0yYtcu0AXQrl3AIwoR0RFpF/CItAt4RNoF/NKtXcAj0i7QER3aBTwi7QIekXYBj0i7gEcUIqIj0i7gEWkX6JcRh3aBLoAO7QIekXaBjqhrF/CItAt4RNoF+tLdtQt4RCEiOiLtAh6RdgGPSLuAR6RdwCPSLsAR9UW7gEekXYBfRvRFuwAXQH3RLuARhYjoiLQLeETaBTwi7QJ+6dYu4BFpF+iIinYBj0i7gEekXcAj0i7gEYWI6Ii0C3hE2gX6ZUTRLtAFUNEu4BFpF+iIqnYBj0i7gEekXaAv3VW7gEcUIqIj0i7gEWkX8Ii0C3hE2gU8Iu0CHVHTLuARaRfolxFNu0AXQE27gEcUIqIj0i7gEWkX8Ii0C/ilW7uAR6RdoCMK7QIekXYBj0i7gEekXcAjChHREWkX8Ii0C/TLiNAu0AVQaBfwiLQLdESrdgGPSLuAR6RdoC/dq3YBjyhEREekXcAj0i7gEWkX8Ii0C3hE2gU6ok27gEekXaBfRmzaBboA2rQLeEQhIjoi7QIekXYBj0i7gF+6tQt4RNoFOqJdu4BHpF3AI9Iu4BFpF/CIQkR0RNoFPCLtAv0yYtcu0AXQrl3AI9Iu0BEd2gU8Iu0CHpF2gb50H9oFPKIQER2RdgGPSLuAR6RdwCPSLuARaRfoiLp2AY9Iu0C/jOjaBboA6toFPKIQER2RdgGPSLuAR6RdwC/d2gU8Iu0CG1FbFu0CHpF2AY9Iu4BHpF3AIwoR0RFpF/CItAvsy4gXRNoFtgB6QaRdwCPSLtARFe0CHpF2AY9Iu0Bfuot2AY8oRERHpF3AI9Iu4BFpF/CItAt4RNoFOqKqXcAj0i7QLyOqdoEugKp2AY8oRERHpF3AI9Iu4BFpF/BLt3YBj0i7QEfUtAt4RNoFPCLtAh6RdgGPKERER6RdwCPSLtAvI5p2gS6AmnYBj0i7QEcU2gU8Iu0CHpF2gb50h3YBjyhEREekXcAj0i7gEWkX8Ii0C3hE2gU6olW7gEekXaBfRqzaBboAWrULeEQhIjoi7QIekXYBj0i7gF+6tQt4RNoFOqJNu4BHpF3AI9Iu4BFpF/CIQkR0RNoFPCLtAv0yYtMu0AXQpl3AI9Iu0BHt2gU8Iu0CHpF2gb5079oFPKIQER2RdgGPSLuAR6RdwCPSLuARaRfoiA7tAh6RdoF+GXFoF+gC6NAu4BGFiOiItAt4RNoFPCLtAn7p1i7gEWkX6Ii6dgGPSLuAR6RdwCPSLuARhYjoiLQLeETaBfplRNcu0AVQ1y7gEWkX4IjKol3AI9Iu4BFpF+BLd1m0C3hEISI6Iu0CHpF2AY9Iu4BHpF3AI9Iu0BEV7QIekXYBfhnx8sNEBBdARbuARxQioiPSLuARaRfwiLQL+KVbu4BHpF2gI6raBTwi7QIekXYBj0i7gEcUIqIj0i7gEWkX6JcRVbtAF0BVu4BHpF2gI2raBTwi7QIekXaBvnQ37QIeUYiIjki7gEekXcAj0i7gEWkX8Ii0C3REoV3AI9Iu0C8jQrtAF0ChXcAjChHREWkX8Ii0C3hE2gX80q1dwCPSLtARrdoFPCLtAh6RdgGPSLuARxQioiPSLuARaRfolxGrdoEugFbtAh6RdoGOaNMu4BFpF/CItAv0pXvTLuARhYjoiLQLeETaBTwi7QIekXYBj0i7QEe0axfwiLQL9MuIXbtAF0C7dgGPKERER6RdwCPSLuARaRfwS7d2AY9Iu0BHdGgX8Ii0C3hE2gU8Iu0CHlGIiI5Iu4BHpF2gX0Yc2gW6ADq0C3hE2gU6oq5dwCPSLuARaRfoS3fXLuARhYjoiLQLeETaBTwi7QIekXYBj0i7AEdUF+0CHpF2AX4ZURftAlwA1UW7gEcUIqIj0i7gEWkX8Ii0C/ilW7uAR6RdoCMq2gU8Iu0CHpF2AY9Iu4BHFCKiI9Iu4BFpF+iXEUW7QBdARbuAR6RdoCOq2gU8Iu0CHpF2gb50V+0CfemuISL6B512AY9Iu4BHpF3AI9Iu4BFpF+hLd9Mu0Jfupl2gf9A17QIekXYBjyhEREekXcAj0i7gl27tAh6RdgGPSLtARxTahdMRxf30yx/3j4i0C3hE2oWvIerl9h5j6T+dfs1RBTAmxzDHITlapsfkaOMdk6O1dEyOdscv5fjyYu85tuPJ6d6O2yvpsfy0JH083Npx6yWt9XeH90eHl7rfwbT2/vArTnvmTDhXO+lUOO2vU+G06/5WOMt6ex1//Ed8P+K0ck+FM8Q5E04FxO+Fs99x1tI+P1y3em+pW3tyuPRWHmZ9GxQNi4Py4/Cy3MDUpT45vO434mvv79/e60xpm5yp0TOleXOmRs+U+s+Zep2p2O4ztfVfmalNB+lMjZ4pRagz9ePwW+uv5YgPZW5TsTooXxoU5a2D8qVBCQfFQflB8f4yaqvH54dLu+8zpfXycaq0007V+KlSZTtV35+qtdwOlzXqL/U0vbcDeOoAKskdwFMHUKPuAP6FAdzu31FYfy6h3x3AXf3uAJ46gLr6iQdw3e8D+OxK59kXr3ZdvYPy4/C4LzTsan1navRMhTPlTP1z6Bcadv2/MzV6prT/ztSPw0+utHctvYPypUHRpjsoXxoUrbeD8n3p+OTrDIcq26kaP1X6aafq+1M17or40Hs7gKcOoJLcATx1AMMBdAC/P4DDvqNwqN8dwFMHUFc/7wDu7fbI+5c7mV9tq7p6B+VLg6Krd1BG7+lqfWdq8Ex1pb4zNXqmVPrO1OCG1rX0ztTomVK8/1YzVfe4z9TxzCSNfCZxDwfFQfnj8LhfY+g6b2dq9EypsZ2p0TOl8XamXmdq2K/GdOW4MzV6ppTjztSPw5//ckRbNN4OypcGRY3toHxpUHTTDsorxXG/GNMW7bRTNX6qwqlyqr49VcO+HNAWvbcDeOoAKskdwFMHUKPuAP6FARz1vZe2qN8dwFMHUFc/8QCOeyZxK7p6B+XH4WFfaGhFre9MjZ4pbwCcqdeZGvWFhlb0/87U6JkKZ8qZ+ufzK+2ipXdQvjQo2nQH5UuDovV2UL4vHZ98naGosp2q8VOln3aqvj9V466Iq97bATx1AJXkDuCpA6hRdwD/wgAO+45CVb87gKcOYDiA0w7gwEfNtqqrd1C+NCi6egdl9J6u1nemRs+UUt+ZGj1TKn1nanBDa1p6Z2r0TCnevzRT23KXMlupP51+zVF/PCbHy2rQtd1+9rEt5cnpdbn/pY7l7WyLR3kc5f55+PKj76dbf/Qej3q847k/PV1uH1tHXd94vvyQB6f3HrfTe+/tyen2Rqa9fcbV5dFbbKW9OdPt88PlZcju2uL9a354eInbqyjLuw/xl8Ov8xrOq/P67Xnd71NV9/XJ4bK/UTzK9ovzell567z+lvN6WYf8t81rW+47WFveverHE1jKel/wStmO4sQ+mdjLGurvTex2/9H9eDKx8ZbHy1t813db+TPzyxrcEzO/rOE8L/O4rAH8VubHcv8naG/PtrdW7+Itojz5F+jy/7rFZX3htyaw35+K1Nf1yQSuy90Tr2VpD/7WX9Ytnpi5HvJLn7THXaUty/bso7Zs94/a2nY/ap981IYjmDmCr6Ff1o9tb3/dtnV59lm77zfn1ff+9rO3+jD0WO9PFClx/HT8NfXLWp5TU7+sqTg19cu6ilNTv6ytODP19bK+4tTUL9vRv5f6cb8H6ce7b3s+TH071tsL2Y79bSfd/oz8shX9vMgv29DPizyMPDty+2h65JbR9MhtoumRW0PHR97vF49br/uHyO2g2ZFvFtD0yG2f6ZHbPtMjt32mRx5Gnh257TM9cttneuS2z/TIbZ/pkds+syPfbZ/pkds+0yO3faZHbvtMjzyMPDty22d65LbP9Mhtn+mR2z7TI7d9Zkd+2D7TI7d9pkdu+0yP3PaZHnkYeXbkts/0yG2f6ZHbPtMjt32mR277zI682z7TI7d9pkdu+0yP3PaZHnkYeXbkts/0yG2f6ZHbPtMjt32mR277TI48FttneuS2z/TIbZ/pkds+0yMPIx8fedwfDtLXj5HbPtMjt32mR277TI/c9pkeue0zO/Ji+0yP3PaZHrntMz1y22d65GHk2ZHbPtMjt32mR277TI/c9pkeue0zO/Jq+0yP3PaZHrntMz1y22d65GHk2ZHbPtMjt32mR277TI/c9pkeue0zO/Jm+0yP3PaZHrntMz1y22d65GHk2ZHbPtMjt32mR277TI/c9pkeue0zO/K4bvvs9Rb5vhxPTj/5jau4bqEcmeJ1O+LIFK9b+0amGKY4IMXrlrORKV63b41M8boVamSK121FI1O8btEZmOJqdxmRot1lRIp2lxEp2l1GpBimOCBFu8uIFO0uI1K0u4xI0e4yIkW7y4AUN7vLiBTtLl9L8dM7wM3uMiJFu8uIFMMUB6RodxmRot1lRIp2lxEp2l1GpGh3GZDibncZkaLdZUSKdpcRKdpdRqQYpjggRbvLiBTtLiNSvGx3WbbbWzxKjZ9OvyZz2T7S1vt8RXl2utbluL/H/dk0llJvtruUvTyd3aXcZ7e8zW55+LLrfdCPutX3h195XrYZzcnzuGxHm5TnZdvipDwv21sn5XnZBj0pz5DnVDwvaxUm5XlZvzEpz8ualkl56ofm4qkfmopn1w/NxVM/NBdP/dBcPPVDc/EMeU7FUz80F0/90Fw89UNz8dQPzcVTPzQTz3XRD83FUz80F0/90Fw89UNz8Qx5TsVTPzQXT/3QXDz1Q3Px1A/NxVM/NBXPoh+ai6d+aC6e+qG5eOqH5uIZ8pyKp35oLp76obl46ofm4qkfmounfmgqnlU/NBdP/dBcPPVDc/HUD53Nc69x+9l73eIjohARHZEWB49IMXM+ot5viFp5gEjXgkekPsEj0ojQETUlBx6R3gKPSBWBR6RdoPeiFiKiI9Iu4BFpF/CItAt4RNoF/EanXaAjCu0CHpF2AY9Iu4BHpF3AIwoR0RFpF05HVPrt9Msft4+ItAv06hraBTwi7QIekXaBjmjVLuARaRfoS/eqXcAj0i7gEYWI6Ii0C3hE2gU8Iu0CHpF2AY9Iu0BHtGkX6JcRm3aBLoA27QIekXYBjyhEREekXcAj0i7gl27tAh6RdgGPSLtAR7RrF/CItAt4RNoFPCLtAh5RiIiOSLtAv4zYtQt0AbRrF/CItAt4RNoFOqJDu4BHpF2gL92HdgGPSLuARxQioiPSLuARaRfwiLQLeETaBTwi7QIdUdcu0C8junaBLoC6dgGPSLuARxQioiPSLuARaRfwS7d2AY9Iu4BHpF2AI9oW7QIekXYBj0i7gEekXcAjChHREWkX4JcR26JdgAugbdEu4BFpF/CItAt0REW7gEekXaAv3UW7gEekXcAjChHREWkX8Ii0C3hE2gU8Iu0CHpF2gY6oahfolxFVu0AXQFW7gEekXcAjChHREWkX8Ii0C/ilW7uAR6RdwCPSLtARNe0CHpF2AY9Iu4BHpF3AIwoR0RFpF+iXEU27QBdATbuAR6RdwCPSLtARhXYBj0i7QF+6Q7uAR6RdwCMKEdERaRfwiLQLeETaBTwi7QIekXaBjmjVLtAvI1btAl0ArdoFPCLtAh5RiIiOSLuAR6RdwC/d2gU8Iu0CHpF2gY5o0y7gEWkX8Ii0C3hE2gU8ohARHZF2gX4ZsWkX6AJo0y7gEWkX8Ii0C3REu3YBj0i7QF+6d+0CHpF2AY8oRERHpF3AI9Iu4BFpF/CItAt4RNoFOqJDu0C/jDi0C3QBdGgX8Ii0C3hEISI6Iu0CHpF2Ab90axfwiLQLeETaBTqirl3AI9Iu4BFpF/CItAt4RCEiOiLtAv0yomsX6AKoaxfwiLQLeETaBTiifdEu4BFpF+BL975oF/CItAt4RCEiOiLtAh6RdgGPSLuAR6RdwCPSLtARFe0C/DJiL9oFugAq2gU8Iu0CHlGIiI5Iu4BHpF3AL93aBTwi7QIekXaBjqhqF/CItAt4RNoFPCLtAh5RiIiOSLtAv4yo2gW6AKraBTwi7QIekXaBjqhpF/CItAv0pbtpF/CItAt4RCEiOiLtAh6RdgGPSLuAR6RdwCPSLtARhXaBfhkR2gW6AArtAh6RdgGPKERER6RdwCPSLuCXbu0CHpF2AY9Iu0BHtGoX8Ii0C3hE2gU8Iu0CHlGIiI5Iu0C/jFi1C3QBtGoX8Ii0C3hE2gU6ok27gEekXaAv3Zt2AY9Iu4BHFCKiI9Iu4BFpF/CItAt4RNoFPCLtAh3Rrl2gX0bs2gW6ANq1C3hE2gU8ohARHZF2AY9Iu4BfurULeETaBTwi7QId0aFdwCPSLuARaRfwiLQLeEQhIjoi7QL9MuLQLtAF0KFdwCPSLuARaRfoiLp2AY9Iu0Bfurt2AY9Iu4BHFCKiI9Iu4BFpF/CItAt4RNoFPCLtAhzRsWgX4JcRx6JdgAugY9Eu4BFpF/CIQkR0RNoFPCLtAn7p1i7gEWkX8Ii0C3RERbuAR6RdwCPSLuARaRfwiEJEdETaBfplRNEu0AVQ0S7gEWkX8Ii0C3REVbuAR6RdoC/dVbuAR6RdwCMKEdERaRfwiLQLeETaBTwi7QIekXaBjqhpF+iXEU27QBdATbuAR6RdwCMKEdERaRfwiLQL+KVbu4BHpF3AI9Iu0BGFdgGPSLuAR6RdwCPSLuARhYjoiLQL9MuI0C7QBVBoF/CItAt4RNoFOqJVu4BHpF2gL92rdgGPSLuARxQioiPSLuARaRfwiLQLeETaBTwi7QId0aZdoF9GbNoFugDatAt4RNoFPKIQER2RdgGPSLuAX7q1C3hE2gU8Iu0CHdGuXcAj0i7gEWkX8Ii0C3hEISI6Iu0C/TJi1y7QBdCuXcAj0i7gEWkX6IgO7QIekXaBvnQf2gU8Iu0CHlGIiI5Iu4BHpF3AI9Iu4BFpF/CItAt0RF27QL+M6NoFugDq2gU8Iu0CHlGIiI5Iu4BHpF3AL93aBTwi7QIekXYBjqgv2gU8Iu0CHpF2AY9Iu4BHFCKiI9IuwC8j+qJdgAugvmgX8Ii0C3hE2gU6oqJdwCPSLtCX7qJdwCPSLuARhYjoiLQLeETaBTwi7QIekXYBj0i7QEdUtQv0y4iqXaALoKpdwCPSLuARhYjoiLQLeETaBfzSrV3AI9Iu4BFpF+iImnYBj0i7gEekXcAj0i7gEYWI6Ii0C/TLiKZdoAugpl3AI9Iu4BFpF+iIQruAR6RdoC/doV3AI9Iu4BGFiOiItAt4RNoFPCLtAh6RdgGPSLtAR7RqF+iXEat2gS6AVu0CHpF2AY8oRERHpF3AI9Iu4Jdu7QJ+6dYu4D/otAt0RJt2AY9Iu4BHpF3AI9Iu0JfuLUQEX7o37QL+g067gEekXcAj0i7gEWkX6Ih27QJ96d61C3hE2gU8Iu0CHlGI6GxEcT/98sf9IyLtAh6RduFLiNpyO13bXoci2vpS/jy99fITogcvu8btTR51qx95qiLm4qm3mIunkmMqnodGZC6e6pO5eOpa5uKpmJmLZ8hzKp4qn7l46ofm4qkfmounfmgunvqhqXh2/dBcPPVDc/HUD83FUz80F8+Q51Q89UNz8dQPzcVTPzQXT/3QXDz1QxPxjGXRD83FUz80F0/90Fw89UNz8Qx5TsVTPzQXT/3QXDz1Q3Px1A/NxVM/NBXPoh+ai6d+6Gyenz/k6gWRygePSIuDRxQiOh3RZ09QekGka8EjUp/gEWlE8IiUHHhEegs6oqqKwCPSLtB7UdUu4BFpF/CIQkR0RNoFPCLtAn6j0y7gEWkX8Ii0C3RETbuAR6RdwCPSLuARaRdOR/TpfxX3BVGICF5dm3YBj0i7gEekXcAj0i7gEWkX6Et3aBfwiLQLeETaBTwi7QIeUYiIjki7gEekXcAj0i7gEWkX6JcRoV2gC6BVu4BHpF3AI9Iu4BFpF/CIQkTwpXvVLuARaRfwiLQLeETaBTwi7QId0aZdwCPSLuARaRfwiLQL9MuILUQEF0CbdgGPSLuAR6RdwCPSLuARaRfoS/euXcAj0i7gEWkX8Ii0C3hEISI6Iu0CHpF2AY9Iu4BHpF2gX0bs2gW6ADq0C3hE2gU8Iu0CHpF2AY8oRARfug/tAh6RdgGPSLuAR6RdwCPSLtARde0CHpF2AY9Iu4BHpF2gX0b0EBFcAHXtAh6RdgGPSLuAR6RdwCPSLsCX7rJoF/CItAt4RNoFPCLtAh5RiIiOSLuAR6RdwCPSLuARaRfglxFl0S7ABVAp2gU8Iu0CHpF2AY9Iu4BHFCKCL91Fu4BHpF3AI9Iu4BFpF/CItAt0RFW7gEekXcAj0i7gEWkX6JcRNUQEF0BVu4BHpF3AI9Iu4BFpF/CItAv0pbtpF/CItAt4RNoFPCLtAh5RiIiOSLuAR6RdwCPSLuARaRfolxFNu0AXQKFdwCPSLuARaRfwiLQLeEQhIvjSHdoFPCLtAh6RdgGPSLuAR6RdoCNatQt4RNoFPCLtAh6RdoF+GbGGiOACaNUu4BFpF/CItAt4RNoFPCLtAn3p3rQLeETaBTwi7QIekXYBjyhEREekXcAj0i7gEWkX8Ii0C/TLiE27QBdAu3YBj0i7gEekXcAj0i7gEYWI4Ev3rl3AI9Iu4BFpF/CItAt4RNoFOqJDu4BHpF3AI9Iu4BFpF+iXEUeICC6ADu0CHpF2AY9Iu4BHpF3AI9Iu0Jfurl3AI9Iu4BFpF/CItAt4RCEiOiLtAh6RdgGPSLuAR6RdoF9GdO0CXADVRbuAR6RdwCPSLuARaRfwiEJE7KW7LtoFPCLtAh6RdgGPSLuAR6RdoCMq2gU8Iu0CHpF2AY9IuwC/jKglRAQXQEW7gEekXcAj0i7gEWkX8Ii0C/Slu2oX8Ii0C3hE2gU8Iu0CHlGIiI5Iu4BHpF3AI9Iu4BFpF+iXEVW7QBdATbuAR6RdwCPSLuARaRfwiEJE8KW7aRfwiLQLeETaBTwi7QIekXaBjii0C3hE2gU8Iu0CHpF2gX4ZESEiuAAK7QIekXYBj0i7gEekXcAj0i7Ql+5Vu4BHpF3AI9Iu4BFpF/CIQkR0RNoFPCLtAh6RdgGPSLtAv4xYtQt0AbRpF/CItAt4RNoFPCLtAh5RiAi+dG/aBTwi7QIekXYBj0i7gEekXaAj2rULeETaBTwi7QIekXaBfhmxh4jgAmjXLuARaRfwiLQLeETaBTwi7QJ96T60C3hE2gU8Iu0CHpF2AY8oRERHpF3AI9Iu4BFpF/CItAv0y4hDu0AXQF27gEekXcAj0i7gEWkX8IhCRPClu2sX8Ii0C3hE2gU8Iu0CHpF2AY6oLdoFPCLtAh6RdgGPSLsAv4xoS4iILYDaol3AI9Iu4BFpF/CItAt4RNoF+tJdtAt4RNoFPCLtAh6RdgGPKERER6RdwCPSLuARaRfwiLQL9MuIol2gC6CqXcAj0i7gEWkX8Ii0C3hEISL40l21C3hE2gU8Iu0CHpF2AY9Iu0BH1LQLeETaBTwi7QIekXaBfhnRQkRwAdS0C3hE2gU8Iu0CHpF2AY9Iu0BfukO7gEekXcAj0i7gEWkX8IhCRHRE2gU8Iu0CHpF2AY9Iu0C/jAjtAl0ArdoFPCLtAh6RdgGPSLuARxQigi/dq3YBj0i7gEekXcAj0i7gEWkX6Ig27QIekXYBj0i7gEekXaBfRmwhIrgA2rQLeETaBTwi7QIekXYBj0i7QF+6d+0CHpF2AY9Iu4BHpF3AIwoR0RFpF/CItAt4RNoFPCLtAv0yYtcu0AXQoV3AI9Iu4BFpF/CItAt4RCEi+NJ9aBfwiLQLeETaBTwi7QIekXaBjqhrF/CItAt4RNoFPCLtAv0yooeI4AKoaxfwiLQLeETaBTwi7QIekXYBvnTHol3AI9Iu4BFpF/CItAt4RCEiOiLtAh6RdgGPSLuAR6RdgF9GxKJdgAugKNoFPCLtAh6RdgGPSLuARxQigi/dRbuAR6RdwCPSLuARaRfwiLQLdERVu4BHpF3AI9Iu4BFpF+iXETVEBBdAVbuAR6RdwCPSLuARaRfwiLQL9KW7aRfwiLQLeETaBTwi7QIeUYiIjki7gEekXcAj0i7gEWkX6JcRTbtAF0ChXcAj0i7gEWkX8Ii0C3hEISL40h3aBfrSHdoF/AeddgGPSLuAR6RdoCNatQt4RNoF+tK9ahfoS/eqXcB/0IWI6Ii0C3hE2gU8Iu0CHpF2Ab90axfoiDbtAh6RdgGPSLtwOqK4n3754/4RkXYBjyhE9CVEvdzeYyz9p9OvOaoAxuRoTx+To2V6TI423jE5WkuH5LjbHb+U48uLvefYjieneztur6TH8tOS9PFwa8etl7TW3x3eHx1e6n4H09r7w6847ZlT4bSTToXT/joVzhDn74SzrLfX0creP+K0ck+F0+Y/FU4FxO+Fs99x1tI+P1y3em+pW3tyuPRWHmZ9GxQNi4Py4/Cy3MDUpT45vO434mvv79/e60xpm5ypwTN1aN6cqdEzpf5zpl5nKrb7TG39l2ZKB+lMjZ4pRagz9ePwW+uv5YgPZe4IB8VB+cqgKG8dlC8NilrYQXmleH8ZtdXj88Ol3feZ0nr5OFXaaadq/FSpsp2q70/VWm6Hyxr1l3qa3tsBPHMAu5LcATx1ADXqDuBfGMDt/h2F9ecS+u0BVL87gKcOoK5+4gFc9/sAPrvSefbFqx4OioPyz6FfaOhqfWdq9Ex5A+BMvc7UsC80dP2/MzV6prT/ztSPw0+utLuW3kH5wqCsizbdQfnSoGi9HZTvS8fPv86wLqpsp2r8VOmnnarvT9WwK+J1CQfQATxzAJXkDuCpA6hRdwD/wgCO+o7CuqjfHcBTB1BXP+8A7u32yPu6b7/aVnX1DspXBqXo6h2UwXt6Ues7U6NnSqnvTI2eKZW+MzW4oZVwppypwTOleP+tZqrucZ+p45lJGvhM4rUoyB2UH4eH/RrDWnTeztTomVJjO1OjZ0rj7Uy9ztSoX41Zq3LcmRo9U8pxZ+rH4Se/HFE13g7KlwZFje2gfGlQwkFxUH5QHPiLMVU77VSNnypVtlP1/aka9+WAqvd2AE8dQCW5A3jqAGrUHcC/MIDDvvfS1O8O4KkDqKufeADHPZN4bbp6B+XH4XFfaGhqfWdq9EyFM+VM/XPoFxqa/t+ZGj1T2n9n6sfhJ1faTUvvoHxpULTpDsqXBkXr7aB8Xzo++TpDqLKdqvFTpZ92qr4/VeOuiEPv7QCeOoBKcgfw1AEMB9AB/P4ADvuOQqjfHcBTB1BXP+8AjnzUbOjqHZQvDYqu3kEZvaer9Z2pwTO1KvWdqdEzpdJ3pgY3tFVL70yNninF+5dmalvuUmYr9afTrzmGOQ7J8bIadG23n31sS3lyel3uf6ljeTvb4lEeR7l/Hr786Pvp1h+9x6Me73juT0+X28fWUdc3ni8/5MHpvcft9N57e3K6vZFpb59xdXn0Fltpb850+/xwae1NW7x/zQ8PL3F7FWV59yH+cvh1Xi9rTZ3XX5jX/T5VdV+fHC77G8WjbL84r5eVt87rbzmvl3XIf9u8tuW+g7Xl3at+PIGlrPcFr5TtKE7sk4m9rKH+3sRu9x/djycTG295vLzFd323ldfMt8sa3BMzv6zhPDHzyxrAb2V+LPd/gvb2bHtr9S7eIsqTf4Eu/6/bdllf+K0J7PenIvV1fTKB63L3xGtZ2oO/9WHm6ZnrIb/0SXvcVdqybM8+ast2/6itbfej9slHrWoxdQRfQ7+sH9ve/rpt6/Lss3bfb86r7/3tZ2/1Yegvud4SKXH8dPw19ctanlNTv6ypODP1/bKu4tTUL2srTk39sr7i1NQv29G/l/pxvwfpx7tvez5MfTvW2wvZjv1tJ93+jDyMPDvyyzb08yK/bCM9L3L7aHrkltH0yG2i2ZEf1tDxkff7xePW6/4hcjtoeuQW0PTIbZ/pkYeRZ0du+0yP3PaZHrntMz1y22d65LbP7Mi77TM9cttneuS2z/TIbZ/pkYeRZ0du+0yP3PaZHrntMz1y22d65LbP5Mi3xfaZHrntMz1y22d65LbP9MjDyLMjt32mR277TI/c9pkeue0zPXLbZ3bkxfaZHrntMz1y22d65LbP9MjDyLMjt32mR277TI/c9pkeue0zPXLbZ3bk1faZHrntMz1y22d65LbP9MjDyLMjt33+DZHH/UkVff0Yue0zPXLbZ3rkts/0yG2f2ZE322d65LbP9Mhtn+mR2z7TIw8jz47c9pkeue0zPXLbZ3rkts/0yG2f2ZGH7TM9cttneuS2z/TIbZ/pkYeRZ0du+0yP3PaZHrntMz1y22d65LbP7MhX22d65LbP9Mhtn+mR2z7TIw8jz47c9pkeue0zPXLbZ3rkts/0yG2f2ZFvts/0yK/bPnu9Rb4vx5PTT37jartuoRyZ4nU74sgUwxQHpHjdJjcyxeuWs5EpXrdvjUzxuhVqZIrXbUUDU9yvW3RGpmh3GZGi3WVEinaXESmGKQ5I0e4yIkW7y4gU7S4jUrS7jEjR7jIgxcPuMiJFu8uIFO0uX0vx0zvAw+4yIsUwxQEp2l1GpGh3GZGi3WVEinaXESnaXQak2O0uI1K0u4xI0e4yIkW7y4gUwxQHpGh3GZGi3WVEinaXESletrss2+0tHqXGT6dfk7lsH2nrfb6iPDtd63Lc3+P+bBpLqTfbXcpens7uUu6zW95mtzx82fU+6Efd6vvDf/Dcl8s2o0l5XrajTcrzsm1xUp6X7a2T8gx5TsXzsl1+Up6XtQqT8rys35iU52VNy6Q89UNT8Sz6obl46ofm4qkfmounfmguniHPqXjqh+biqR+ai6d+aC6e+qG5eOqHpuJZ9UNz8dQPzcVTPzQXT/3QXDxDnlPx1A/NxVM/NBdP/dBcPPVDc/HUD03Fs+mH5uKpH5qLp35oLp76obl4hjyn4qkfmounfmgunvqhuXjqh+biqR+aimfoh+biqR+ai6d+aC6e+qG5eIY8T+a517j97L1u8RGRygePSIuDR6SYOR9R7zdErTxApGvBI1Kf0BGtGhE8IiUHHpHeAo9IFYFHFCKC96JVu4BHpF3AI9Iu4BFpF/CItAv0jW7TLuARaRfwiLQLeETaBTyiEBEdkXYBj0i7cDqi0m+nX/64fUSkXaBX1027gEekXaAj2rULeETaBTwi7QJ96d61C3hEISI6Iu0CHpF2AY9Iu4BHpF3AI9Iu0BEd2gU8Iu0C/TLi0C7QBdChXcAjChHREWkX8Ii0C3hE2gX80q1dwCPSLtARde0CHpF2AY9Iu4BHpF3AIwoR0RFpF/CItAv0y4iuXaALoK5dwCPSLsARHYt2AY9Iu4BHpF2AL93Hol3AIwoR0RFpF/CItAt4RNoFPCLtAh6RdoGOqGgX8Ii0C/DLiKNoF+gCqGgX8IhCRHRE2gU8Iu0CHpF2Ab90axfwiLQLdERVu4BHpF3AI9Iu4BFpF/CIQkR0RNoFPCLtAv0yomoX6AKoahfwiLQLdERNu4BHpF3AI9Iu0Jfupl3AIwoR0RFpF/CItAt4RNoFPCLtAh6RdoGOKLQLeETaBfplRGgX6AIotAt4RCEiOiLtAh6RdgGPSLuAX7q1C3hE2gU6olW7gEekXcAj0i7gEWkX8IhCRHRE2gU8Iu0C/TJi1S7QBdCqXcAj0i7QEW3aBTwi7QIekXaBvnRv2gU8ohARHZF2AY9Iu4BHpF3AI9Iu4BFpF+iIdu0CHpF2gX4ZsWsX6AJo1y7gEYWI6Ii0C3hE2gU8Iu0CfunWLuARaRfoiA7tAh6RdgGPSLuAR6RdwCMKEdERaRfwiLQL9MuIQ7tAF0CHdgGPSLtAR9S1C3hE2gU8Iu0Cfenu2gU8ohARHZF2AY9Iu4BHpF3AI9Iu4BFpF+CI+qJdwCPSLsAvI/qiXYALoL5oF/CIQkR0RNoFPCLtAh6RdgG/dGsX8Ii0C3RERbuAR6RdwCPSLuARaRfwiEJEdETaBTwi7QL9MqJoF+gCqGgX8Ii0C3REVbuAR6RdwCPSLtCX7qpdwCMKEdERaRfwiLQLeETaBTwi7QIekXaBjqhpF/CItAv0y4imXaALoKZdwCMKEdERaRfwiLQLeETaBfzSrV3AI9Iu0BGFdgGPSLuAR6RdwCPSLuARhYjoiLQLeETaBfplRGgX6AIotAt4RNoFOqJVu4BHpF3AI9Iu0JfuVbuARxQioiPSLuARaRfwiLQLeETaBTwi7QId0aZdwCPSLtAvIzbtAl0AbdoFPKIQER2RdgGPSLuAR6RdwC/d2gU8Iu0CHdGuXcAj0i7gEWkX8Ii0C3hEISI6Iu0CHpF2gX4ZsWsX6AJo1y7gEWkX6IgO7QIekXYBj0i7QF+6D+0CHlGIiI5Iu4BHpF3AI9Iu4BFpF/CItAt0RF27gEekXaBfRnTtAl0Ade0CHlGIiI5Iu4BHpF3AI9Iu4Jdu7QIekXaBjWhdFu0CHpF2AY9Iu4BHpF3AIwoR0RFpF/CItAvsy4gXRNoFtgB6QaRdwCPSLtARFe0CHpF2AY9Iu0Bfuot2AY8oRERHpF3AI9Iu4BFpF/CItAt4RNoFOqKqXcAj0i7QLyOqdoEugKp2AY8oRERHpF3AI9Iu4BFpF/BLt3YBj0i7QEfUtAt4RNoFPCLtAh6RdgGPKERER6RdwCPSLtAvI5p2gS6AmnYBj0i7QEcU2gU8Iu0CHpF2gb50h3YBjyhEREekXcAj0i7gEWkX8Ii0C3hE2gU6olW7gEekXaBfRqzaBboAWrULeEQhIjoi7QIekXYBj0i7gF+6tQt4RNoFOqJNu4BHpF3AI9Iu4BFpF/CIQkR0RNoFPCLtAv0yYtMu0AXQpl3AI9Iu0BHt2gU8Iu0CHpF2gb5079oFPKIQER2RdgGPSLuAR6RdwCPSLuARaRfoiA7tAh6RdoF+GXFoF+gC6NAu4BGFiOiItAt4RNoFPCLtAn7p1i7gEWkX6Ii6dgGPSLuAR6RdwCPSLuARhYjoiLQLeETaBfplRNcu0AVQ1y7gEWkX4IjKol3AI9Iu4BFpF+BLd1m0C3hEISI6Iu0CHpF2AY9Iu4BHpF3AI9Iu0BEV7QIekXYBfhnx8sNEBBdARbuARxQioiPSLuARaRfwiLQL+KVbu4BHpF2gI6raBTwi7QIekXYBj0i7gEcUIqIj0i7gEWkX6JcRVbtAF0BVu4BHpF2gI2raBTwi7QIekXaBvnQ37QIeUYiIjki7gEekXcAj0i7gEWkX8Ii0C3REoV3AI9Iu0C8jQrtAF0ChXcAjChHREWkX8Ii0C3hE2gX80q1dwCPSLtARrdoFPCLtAh6RdgGPSLuARxQioiPSLuARaRfolxGrdoEugFbtAh6RdoGOaNMu4BFpF/CItAv0pXvTLuARhYjoiLQLeETaBTwi7QIekXYBj0i7QEe0axfwiLQL9MuIXbtAF0C7dgGPKERER6RdwCPSLuARaRfwS7d2Ab90axfoH3SHdgGPSLuAR6RdwCPSLuARhYjgS/ehXaAv3Yd2Af9Bp13AI9Iu4BFpF+iIunYBj0i7QF+6u3YBj0i7gEcUIqIj0i6cjijup1/+uH9EpF3AI9IufAlRW26na9vrUERbX8qfp7defkL04GXXuL3Jo271I09VxFw89RYz8ayLkmMunhqRuXiqT+biqWuZi2fIcyqeWpy5eKp85uKpH5qLp35oLp76oal4Fv3QXDz1Q3Px1A/NxVM/NBfPkOdUPPVDc/HUD83FUz80F0/90Fw89UNT8az6obl46ofm4qkfmounfmguniHPqXjqh+biqR+ai6d+aC6e+qG5eOqHpuLZ9ENz8dQPzcVTP3Q2zycPuapN5YNHFCKiI1LMnI/o0yco1aZrwSNSn+ARaUTwiJQcdESht8AjUkXgEWkX6L0otAt4RCEiOiLtAh6RdgGPSLuA3+i0C3hE2gU6olW7gEekXcAj0i7gEWkX8IhCRGcj+vy/iltX7QK9uq7aBTwi7QIekXYBj0i7QEe0aRfoS/emXcAj0i7gEWkX8IhCRHRE2gU8Iu0CHpF2AY9Iu4BHpF2gX0bs2gW6ANq1C3hE2gU8Iu0CHlGIiI5Iu0BfunftAh6RdgGPSLuAR6RdoCM6tAt4RNoFPCLtAh6RdgGPKEQEv4w4tAt0AXRoF/CItAt4RNoFPCLtAh1R1y7Ql+6uXcAj0i7gEWkX8IhCRHRE2gU8Iu0CHpF2AY9Iu4BHpF2AX0a0RbsAF0AvAERER6RdwCPSLuARhYjoiLQL8KW7LdoFPCLtAh6RdgGPSLtAR1S0C3hE2gU8Iu0CHpF2AY8oRAS/jCjaBboAKtoFPCLtAh6RdgGPSLtAR1S1C/Slu2oX8Ii0C3hE2gU8ohARHZF2AY9Iu4BHpF3AI9Iu4BFpF+iXEU27QBdATbuAR6RdwCPSLuARhYjoiLQL9KW7aRfwiLQLeETaBTwi7QIdUWgX8Ii0C3hE2gU8Iu0CHlGICH4ZEdoFugAK7QIekXYBj0i7gEekXaAjWrUL9KV71S7gEWkX8Ii0C3hEISI6Iu0CHpF2AY9Iu4BHpF3AI9Iu0C8jNu0CXQBt2gU8Iu0CHpF2AY8oRERHpF2gL92bdgGPSLuAR6RdwCPSLtAR7doFPCLtAh6RdgGPSLuARxQigl9G7NoFugDatQt4RNoFPCLtAh6RdoGO6NAu0JfuQ7uAR6RdwCPSLuARhYjoiLQLeETaBTwi7QIekXYBj0i7QL+M6NoFugDq2gU8Iu0CHpF2AY8oRERHpF2gL91du4BHpF3AI9Iu4BFpF+CIYtEu4BFpF/CItAt4RNoFPKIQEfsyIhbtAlwAxaJdwCPSLuARaRfwiLQLdERFu0Bfuot2AY9Iu4BHpF3AIwoR0RFpF/CItAt4RNoFPCLtAh6RdoF+GVG1C3QBVLULeETaBTwi7QIeUYiIjki7QF+6q3YBj0i7gEekXcAj0i7QETXtAh6RdgGPSLuAR6RdwCMKEcEvI5p2gS6AmnYBj0i7gEekXcAj0i7QEYV2gb50h3YBj0i7gEekXcAjChHREWkX8Ii0C3hE2gU8Iu0CHpF2gX4ZsWoX6AJo1S7gEWkX8Ii0C3hEISI6Iu0CfeletQt4RNoFPCLtAh6RdoGOaNMu4BFpF/CItAt4RNoFPKIQEfwyYtMu0AXQpl3AI9Iu4BFpF/CItAt0RLt2gb5079oFPCLtAh6RdgGPKERER6RdwCPSLuARaRfwiLQLeETaBfplxKFdoAugQ7uAR6RdwCPSLuARhYjoiLQL9KX70C7gEWkX8Ii0C3hE2gU6oq5dwCPSLuARaRfwiLQLeEQhIvhlRNcu0AVQ1y7gEWkX8Ii0C3hE2gU4onXRLsCX7nXRLuARaRfwiLQLeEQhIjoi7QIekXYBj0i7gEekXcAj0i7ALyPWol2gC6CiXcAj0i7gEWkX8IhCRHRE2gX60l20C3hE2gU8Iu0CHpF2gY6oahfwiLQLeETaBTwi7QIeUYgIfhlRtQt0AVS1C3hE2gU8Iu0CHpF2gY6oaRfoS3fTLuARaRfwiLQLeEQhIjoi7QIekXYBj0i7gEekXcAj0i7QLyNCu0AXQKFdwCPSLuARaRfwiEJEdETaBfrSHdoFPCLtAh6RdgGPSLtAR7RqF/CItAt4RNoFPCLtAh5RiAh+GbFqF+gCaNUu4BFpF/CItAt4RNoFOqJNu0BfujftAh6RdgGPSLuARxQioiPSLuARaRfwiLQLeETaBTwi7QL9MmLXLtAF0K5dwCPSLuARaRfwiEJEdETaBfrSvWsX8Ii0C3hE2gU8Iu0CHdGhXcAj0i7gEWkX8Ii0C3hEISL4ZcShXaALoEO7gEekXcAj0i7gEWkX6Ii6doG+dHftAh6RdgGPSLuARxQioiPSLuARaRfwiLQLeETaBTwi7QL8MmJbtAtwAbQt2gU8Iu0CHpF2AY8oRERHpF2AL93bol3AI9Iu4BFpF/CItAt0REW7gEekXcAj0i7gEWkX8IhCRPDLiKJdoAugol3AI9Iu4BFpF/CItAt0RFW7QF+6q3YBj0i7gEekXcAjChHREWkX8Ii0C3hE2gU8Iu0CHpF2gX4Z0bQLdAHUtAt4RNoFPCLtAh5RiIiOSLtAX7qbdgGPSLuAR6RdwCPSLtARhXYBj0i7gEekXcAj0i7gEYWI4JcRoV2gC6DQLuARaRfwiLQLeETaBTqiVbtAX7pX7QIekXYBj0i7gEcUIqIj0i7gEWkX8Ii0C3hE2gU8Iu0C/TJi0y7QBdCmXcAj0i7gEWkX8IhCRHRE2gX60r1pF/BLt3YB/0GnXcAj0i7QEe3aBTwi7QIekXaBvnTv2gX60r2HiOgfdNoFPCLtAh6RdgGPSLuAR6RdoC/dh3YBj0i7gEekXcAj0i6cjijup1/+uH9EFCKiI9IufA1RL7f3GEv/6fRrjiqAMTna08fkaJkek6ONd0iO3Vo6Jke745dyfHmx9xzb8eR0b8ftlfRYflqSPh5u7bj1ktb6u8P7o8NL3e9gWnt/+BWnPXMqnHbSqXCGOGfCadf9rXCW9fY6Wtn7R5xW7qlw2vynwqmA+L1w9jvOWtrnh+tW7y11a08Ol97Kw6xvg6JhcVB+HF6WG5i61CeH1/1GfO39/dv7Y6b2RdvkTI2eKc2bMzV6ptR/ztTrTMV2n6mt/9JM6SCdqdEzFc6UM/XH4bfWX8sR/2uZ2xcVq4PypUFR3jooXxoUtbCD8krx/jJqq8fnh0u77zOl9fJxqrTTTtX4qVJlO1Xfn6q13A6XNeqv9LSi93YATx1AJbkDeOoAatQdwL8wgNv9OwrrzyX02wOofncATx3AcADnHcB1vw/gsyudJ1+82ouu3kH5cXjcFxqKWt+ZGj1T3gA4U68zNewLDUX/70yNnintvzP14/CTK+2qpXdQvjQo2nQH5UuDovV2UL4vHZ98naGqsp2q8VMVTpVT9e2pGndFXPXeDuCpA6gkdwBPHUCNugP4FwZw2HcUqvrdATx1AHX18w7g3m6PvK/79otttenqHZQvDYqu3kEZvKc3tb4zNXqmlPrO1OiZCmfKmRrb0JqW3pkaPVOK999qpuoe95k6npmkgc8k3puC3EH5cXjcrzE0nbczNXqm1NjO1OCZCo23M/U6U8N+NSaU487U6JlSjjtTPw4/+eWI0Hg7KF8alHBQHJSvDIpu2kF5pTjwF2NCO+1UjZ8qVbZT9f2pGvflgNB7O4CnDqCS3AE8cwBXjboD+BcGcNj3Xlb1uwN46gDq6icewIHPJF519Q7Kj8PjvtCwhjPlTA2eKW8AnKnXmRr2hYZV/+9MjZ4p7b8z9ePwkyvtVUvvoHxpULTpDspXBmXTejso35eOT77OsKmynarxU6Wfdqq+P1Xjrog3vbcDeOoAhgPoAJ45gBp1B/AvDOCw7yhs6ncH8NQB1NXPO4AjHzW76eodlC8Niq7eQRm8p+9qfWdq9Ewp9Z2p0TOl0nemBje0XUvvTI2eqXCmvjJT23KXMlupP51+zVF/PCbHy2rQtd1+9rEt5cnpdbn/pY7l7WyLR3kc5f55+PKj76dbf/Qej3q847k/PV1uH1tHXd94vvyQB6f3HrfTe+/tyen2Rqa9fcbV5dFbbKW9OdPt88OltTdt8f41Pzy8xO1VlOXdh/jL4dd5vaw1dV5/YV73+1TVfX1yuOxvFI+y/eK8XlbeOq+/5bxe1iH/bfPalvsO1pZ3r/rxBJay3he8UrajOLGfT+xxWUP9vYnd7j+6H08mNt7yeHmL7/puK39mflmDe2LmlzWcJ2Z+WQP4rcyP5f5P0N6ebW+t3sVbRHnyL5D/uoUT+IUJ7PenIvV1fTKB63L3xGtZ2oO/9Zd1iydmrof80iftcVdpy7I9+6gt2/2jtrbdj9onH7WqxdQRfA39sn5se/vrtq3Ls8/aF5F4+7Dd+9vP3urD0GO9P1GkxPHT8dfUL2t5zky9X9ZUnJr6ZV3Fqalf1lacmvplfcWpqYepfyX1434P0o933/Z8mPp2rLcXsh372066/Rn5ZSv6eZFftqGfF/llG+l5kdtH0yO3jCZHfiw20fTIraHjI+/3i8et1/1D5HbQ9MgtoOmRh5FnR277TI/c9pkeue0zPXLbZ3rkts/syIvtMz1y22d65LbP9Mhtn+mRh5FnR277TI/c9pkeue0zPXLbZ3rkts/syKvtMz1y22d65LbP9Mhtn+mRh5FnR277TI/c9pkeue0zPXLbZ3rkts/syJvtMz1y22d65LbP9Mhtn+mRh5FnR277TI/c9pkeue0zPXLbZ3rkts/syMP2mR657TM9cttneuS2z/TIw8izI7d9pkdu+/wbIo/7kyr6+jFy22d65LbP9Mhtn9mRr7bP9Mhtn+mR2z7TI7d9pkceRp4due0zPXLbZ3rkts/0yG2f6ZHbPrMj32yf6ZHbPtMjt32mR277TI88jDw7cttneuS2z/TIbZ/pkds+0yO3fWZHvts+0yO3faZHbvtMj9z2mR55GHl25LbP9Mhtn+mR2z7TI7d9pkdu+8yO/LB9pkdu+0yP/Lrts9db5PtyPDn95DeujusWypEphikOSPG6tW9kitdtciNTvG45G5nidfvWyBSvW6EGptiv24pGpnjdojMyRbvLiBTtLiNSDFMckKLdZUSKdpcRKdpdRqRodxmRot3l11Psi91lRIp2lxEp2l1GpGh3+VqKn90B9iVMcUCKdpcRKdpdRqRodxmRot1lRIp2lwEpFrvLiBTtLiNStLuMSNHuMiLFMMUBKdpdRqRodxmRot1lRIp2lxEpXra7LNvtLR6lxk+nfyRTL9tH2nqfryjPTte6HPf3uD+bxlLqzXaXspens7uU++yWt9ktD192vQ/6Ubf6/vArz8s2o0l5XrajTcrzsm1xUp4hz6l4XrZBT8rzsl1+Up6XtQqT8rys35iU52VNy5w8m35oLp76obl46ofm4qkfmotnyHMqnvqhuXjqh+biqR+ai6d+aC6e+qGpeIZ+aC6e+qG5eOqH5uKpH5qLZ8hzKp76obl46ofm4qkfmounfmgunvqhqXiu+qG5eOqH5uKpH5qLp35oLp4hz6l46ofm4qkfmounfmgunvqhuXjqh6biuemH5uKpH5qLp35oLp76obl4hjyn4qkfOpvnXuP2s/e6xUdEKh88Ii0OHpFi5nxEvd8QtfIAka6FjmhXn+ARaUTwiJQceER6CzyiEBEdkXaB3ot27QIekXYBj0i7gEekXaAjOrQL9I3u0C7gEWkX8Ii0C3hEISI6Iu0CHpF2AY9Iu3A6otJvp1/+uH1EpF3AV1ftAh1R1y7gEWkX8Ii0C3hE2gX60t1DRHRE2gU8Iu0CHpF2AY9Iu4BHpF1gI9qWRbuAR6RdwCPSLrAvI14QaRfYAugFUYiIjki7gEekXcAj0i7gEWkX8Eu3doGOqGgX8Ii0C3hE2gU8Iu0CHlGIiI5Iu4BHpF3AI9Iu0C8jinaBLoCKdoGOqGoX8Ii0C3hE2gU8Iu0CfemuISI6Iu0CHpF2AY9Iu4BHpF3AI9Iu0BE17QIekXYBj0i7QL+MaNoFugBqISI6Iu0CHpF2AY9Iu4BHpF3AL93aBTqi0C7gEWkX8Ii0C3hE2gU8ohARHZF2AY9Iu4BHpF2gX0aEdoEugEK7QEe0ahfwiLQLeETaBTwi7QJ96V5DRHRE2gU8Iu0CHpF2AY9Iu4BHpF2gI9q0C3hE2gU8Iu0C/TJi0y7QBdAWIqIj0i7gEWkX8Ii0C3hE2gX80q1doCPatQt4RNoFPCLtAh6RdgGPKERER6RdwCPSLuARaRfolxG7doEugHbtAh3RoV3AI9Iu4BFpF/CItAv0pfsIEdERaRfwiLQLeETaBTwi7QIekXaBjqhrF/CItAt4RNoF+mVE1y7QBVAPEdERaRfwiLQLeETaBTwi7QJ+6dYuwBGVRbuAR6RdwCPSLuARaRfwiEJEdETaBTwi7QIekXYBfhlRFu0CXACVRbtAR1S0C3hE2gU8Iu0CHpF2gb50lxARHZF2AY9Iu4BHpF3AI9Iu4BFpF+iIqnYBj0i7gEekXaBfRlTtAl0A1RARHZF2AY9Iu4BHpF3AI9Iu4Jdu7QIdUdMu4BFpF/CItAt4RNoFPKIQER2RdgGPSLuAR6RdoF9GNO0CXQA17QIdUWgX8Ii0C3hE2gU8Iu0CfemOEBEdkXbhX+mItAt4RNoFPCLtAh6RdoGOaNUu4BFpF/CItAunI3pyGbFqF87/W/S5AFpDRHRE2gU8Iu0CHpF2AY9Iu4BfurULdESbdgGPSLuAR6RdwCPSLuARhYjoiLQLeETaBTwi7QL9MmLTLtAF0KZdoCPatQt4RNoFPCLtAh6RdoG+dO8hIjoi7QIekXYBj0i7gEekXcAj0i7QER3aBTwi7QIekXaBfhlxaBfoAugIEdERaRfwiLQLeETaBTwi7QJ+6dYu0BF17QIekXYBj0i7gEekXcAjChHREWkX8Ii0C3hE2gX6ZUTXLtAFUNcuwBHVRbuAR6RdwCPSLuARaRfgS3ddQkR0RNoFPCLtAh6RdgGPSLuAR6RdoCMq2gU8Iu0CHpF2AX4ZUYt2gS6ASoiIjki7gEekXcAj0i7gEWkX8Eu3doGOqGoX8Ii0C3hE2gU8Iu0CHlGIiI5Iu4BHpF3AI9Iu0C8jqnaBLoCqdoGOqGkX8Ii0C3hE2gU8Iu0CfeluISI6Iu0CHpF2AY9Iu4BHpF3AI9Iu0BGFdgGPSLuAR6RdoF9GhHaBLoAiRERHpF3AI9Iu4BFpF/CItAv4pVu7QEe0ahfwiLQLeETaBTwi7QIeUYiIjki7gEekXcAj0i7QLyNW7QJdAK3aBTqiTbuAR6RdwCPSLuARaRfoS/cWIqIj0i7gEWkX8Ii0C3hE2gU8Iu0CHdGuXcAj0i7gEWkX6JcRu3aBLoD2EBEdkXYBj0i7gEekXcAj0i7gl27tAh3RoV3AI9Iu4BFpF/CItAt4RCEiOiLtAh6RdgGPSLtAv4w4tAt0AXRoF+iIunYBj0i7gEekXcAj0i7Ql+4eIqIj0i7gEWkX8Ii0C3hE2gU8Iu0CHFFbtAt4RNoFPCLtAvwyoi3aBbgAakuIiI5Iu4BHpF3AI9Iu4BFpF/BLt3aBjqhoF/CItAt4RNoFPCLtAh5RiIiOSLuAR6RdwCPSLtAvI4p2gS6AinaBjqhqF/CItAt4RNoFPCLtAn3priEiOiLtAh6RdgGPSLuAR6RdwCPSLtARNe0CHpF2AY9Iu0C/jGjaBboAaiEiOiLtAh6RdgGPSLuAR6RdwC/d2gU6otAu4BFpF/CItAt4RNoFPKIQER2RdgGPSLuAR6RdoF9GhHaBLoBCu0BHtGoX8Ii0C3hE2gU8Iu0CfeleQ0R0RNoFPCLtAh6RdgGPSLuAR6RdoCPatAt4RNoFPCLtAv0yYtMu0AXQFiKiI9Iu4BFpF/CItAt4RNoF/NKtXaAj2rULeETaBTwi7QIekXYBjyhEREekXcAj0i7gEWkX6JcRu3aBLoB27QId0aFdwCPSLuARaRfwiLQL9KX7CBHREWkX8Ii0C3hE2gU8Iu0CHpF2gY6oaxfwiLQLeETaBfplRNcu0AVQDxHREWkX8Ii0C3hE2gU8Iu0CfunWLsCX7li0C/APuli0C3hE2gU8Iu0CHlGIiI5IuwBfumPRLuCXbu0C/oNOu4BHpF2gIyraBTwi7QIekXaBvnQX7QIeUYiIjki7gEekXTgdUdxPv/xx/4hIu4BHpF34EqK23E7XttehiLa+lD9Pb738hOjBy65xe5NH3epHnqqIqXhWvcVcPJUcc/HUiMzFU30yF8+Q51Q8FTNz8dTizMVT5TMXT/3QXDz1Q1PxbPqhuXjqh+biqR+ai6d+aC6eIc+peOqH5uKpH5qLp35oLp76obl46oem4hn6obl46ofm4qkfmounfmguniHPqXjqh+biqR+ai6d+aC6e+qG5eOqHpuK56ofm4qkfmounfmgunvqhs3k+e8jVGiKiI9Li4BEpZs5H9PkTlFZdCx6R+gSPSCNCR7QpOfCI9BZ4RKoIPCLtAr0XbSEiOiLtAh6RdgGPSLuAR6RdwG902gU6ol27gEekXcAj0i7gEWkX8IhCRHRE2oXTET35r+Lu2gV6dd21C3hE2gU8Iu0CHdGhXcAj0i7Ql+5Du4BHpF3AIwoR0RFpF/CItAt4RNoFPCLtAh6RdoGOqGsX6JcRXbtAF0Bdu4BHpF3AIwoR0RFpF/CItAv4pVu7gEekXcAj0i7AEa2LdgGPSLuAR6RdwCPSLuARhYjoiLQL8MuIddEuwAXQumgX8Ii0C3hE2gU6oqJdwCPSLtCX7qJdwCPSLuARhYjoiLQLeETaBTwi7QIekXYBj0i7QEdUtQv0y4iqXaALoKpdwCPSLuARhYjoiLQLeETaBfzSrV3AI9Iu4BFpF+iImnYBj0i7gEekXcAj0i7gEYWI6Ii0C/TLiKZdoAugpl3AI9Iu4BFpF+iIQruAR6RdoC/doV3AI9Iu4BGFiOiItAt4RNoFPCLtAh6RdgGPSLtAR7RqF+iXEat2gS6AVu0CHpF2AY8oRERHpF3AI9Iu4Jdu7QIekXYBj0i7QEe0aRfwiLQLeETaBTwi7QIeUYiIjki7QL+M2LQLdAG0aRfwiLQLeETaBTqiXbuAR6RdoC/du3YBj0i7gEcUIqIj0i7gEWkX8Ii0C3hE2gU8Iu0CHdGhXaBfRhzaBboAOrQLeETaBTyiEBEdkXYBj0i7gF+6tQt4RNoFPCLtAh1R1y7gEWkX8Ii0C3hE2gU8ohARHZF2gX4Z0bULdAHUtQt4RNoFPCLtAhzRtmgX8Ii0C/Cle1u0C3hE2gU8ohARHZF2AY9Iu4BHpF3AI9Iu4BFpF+iIinYBfhmxFe0CXQAV7QIekXYBjyhEREekXcAj0i7gl27tAh6RdgGPSLtAR1S1C3hE2gU8Iu0CHpF2AY8oRERHpF2gX0ZU7QJdAFXtAh6RdgGPSLtAR9S0C3hE2gX60t20C3hE2gU8ohARHZF2AY9Iu4BHpF3AI9Iu4BFpF+iIQrtAv4wI7QJdAIV2AY9Iu4BHFCKiI9Iu4BFpF/BLt3YBj0i7gEekXaAjWrULeETaBTwi7QIekXYBjyhEREekXaBfRqzaBboAWrULeETaBTwi7QId0aZdwCPSLtCX7k27gEekXcAjChHREWkX8Ii0C3hE2gU8Iu0CHpF2gY5o1y7QLyN27QJdAO3aBTwi7QIeUYiIjki7gEekXcAv3doFPCLtAh6RdoGO6NAu4BFpF/CItAt4RNoFPKIQER2RdoF+GXFoF+gC6NAu4BFpF/CItAt0RF27gEekXaAv3V27gEekXcAjChHREWkX8Ii0C3hE2gU8Iu0CHpF2AY5oX7QL8MuIfdEuwAXQvmgX8Ii0C3hEISI6Iu0CHpF2Ab90axfwiLQLeETaBTqiol3AI9Iu4BFpF/CItAt4RCEiOiLtAv0yomgX6AKoaBfwiLQLeETaBTqiql3AI9Iu0Jfuql3AI9Iu4BGFiOiItAt4RNoFPCLtAh6RdgGPSLtAR9S0C/TLiKZdoAugpl3AI9Iu4BGFiOiItAt4RNoF/NKtXcAj0i7gEWkX6IhCu4BHpF3AI9Iu4BFpF/CIQkR0RNoF+mVEaBfoAii0C3hE2gU8Iu0CHdGqXcAj0i7Ql+5Vu4BHpF3AIwoR0RFpF/CItAt4RNoFPCLtAh6RdoGOaNMu0C8jNu0CXQBt2gU8Iu0CHlGIiI5Iu4BHpF3AL93aBTwi7QIekXaBjmjXLuARaRfwiLQLeETaBTyiEBEdkXaBfhmxaxfoAmjXLuARaRfwiLQLdESHdgGPSLtAX7oP7QIekXYBjyhEREekXcAj0i7gEWkX8Ii0C3hE2gU6oq5doF9GdO0CXQB17QIekXYBjyhEREekXcAj0i7gl27tAh6RdgGPSLsAR3Qs2gU8Iu0CHpF2AY9Iu4BHFCKiI9IuwC8jjkW7ABdAx6JdwCPSLuARaRfoiIp2AY9Iu0Bfuot2AY9Iu4BHFCKiI9Iu4BFpF/CItAt4RNoFPCLtAh1R1S7QLyOqdoEugKp2AY9Iu4BHFCKiI9Iu4BFpF/BLt3YBj0i7gEekXaAjatoFPCLtAh6RdgGPSLuARxQioiPSLtAvI5p2gS6AmnYBj0i7gEekXaAjCu0CHpF2gb50h3YBj0i7gEcUIqIj0i7gEWkX8Ii0C3hE2gU8Iu0CHdGqXaBfRqzaBboAWrULeETaBTyiEBEdkXYBj0i7gF+6tQt4RNoFPCLtAh3Rpl3AI9Iu4BFpF/CItAt4RCEiOiLtAv0yYtMu0AXQpl3AI9Iu4BFpF+iIdu0CHpF2gb5079oFPCLtAh5RiIiOSLuAR6RdwCPSLuARaRfwiLQLdESHdoF+GXFoF+gC6NAu4BFpF/CIQkR0RNoFPCLtAn7p1i7gl27tAv6DTrtAR9S1C3hE2gU8Iu0CHpF2gb509xARfOnu2gX8B512AY9Iu4BHpF3AI9IuwBH1RbsAX7r7ol3AI9Iu4BFpF/CIQkRnI4r76Zc/7h8RaRfwiLQLX0PUy+09xtJ/Ov2aowpgTI729DE5WqaH5FhsvGNytJaOydHu+KUcX17sPcd2PDnd23F7JT2Wn5akj4dbO269pLX+7vD+6PBS9zuY1t4ffsVpz5wKZ4hzJpz216lw2nV/K5xlvb2OVvb+EaeVeyqcNv+pcCogfi+c/Y6zlvb54brVe0vd2pPDpbfyMOs/B6VqWByUH4eX5QamLvXJ4XW/EV97f//2XmdK2+RMjZ4pzZszNXqm1H/O1OtMxXafqa3/0kyFM+VMDZ4pRagz9ePwW+uv5YiPZU7F6qB8aVCUtw7KlwZFLeygvFK8v4za6vH54dLu+0xpvXycKu20UzV8qpoq26n6/lSt5Xa4rFF/pac1vbcDeOoAKskdwFMHUKPuAP6FAdzu31FYfy6h3x7AcAAdwDMHUFc/8QCu+30An13pPPviVdPVOyg/Do/7QkNT6ztTo2fKGwBn6nWmhn2hoen/nanBMxXaf2fqx+EnV9qhpXdQvjQo2nQH5UuDovV2UL4vHZ98nSHCqXKqhk+Vftqp+v5UjbsiDr23A3jqACrJHcBTB1Cj7gD+hQEc9h2FUL87gGcO4Kqrn3cA93Z75H3dt19sq6uu3kH50qDo6h2UwXv6qtZ3pkbPVDhTztTgmVLpO1OjG5qW3pkaPVOK999qpuoe95k6npmkkc8kXhXkDsqPw+N+jWHVeTtTg2dqU2M7U6NnSuPtTL3O1LBfjdmU487U6JlSjjtTPw4/+eWILRwUB+Urg6LGdlC+NCi6aQflleLAX4zZtNNO1fipUmU7Vd+fqnFfDtj03g7gmQO4K8kdwFMHUKPuAP6FARz2vZdd/e4AnjqAuvqJB3DgM4n3cFAclH8O/ULDrtZ3pkbPlDcAztTrTA37QsOu/3emRs+U9t+Z+nH4yZX2rqV3UL4yKIc23UH50qBovR2U70vHJ19nOFTZTtX4qdJPO1Xfn6pxV8RHOIAO4JkDqCR3AE8dQI26A/gXBnDYdxQO9bsDeOoA6urnHcCRj5o9dPUOylcGpevqHZTBe3pX6ztTo2dKqe9MjZ4plb4zNbih9XCmnKnBM6V4/9JMbctdymyl/nT6NUf98ZgcL6tB13b72ce2lCen1+X+lzqWt7MtHuVxlPvn4cuPvp9u/dF7POrxjuf+9HS5fWwddX3j+fJDHpzee9xO7y8b0pPT7Y1Me/uMq8ujt9hKe3Om2+eHS2tv2uL9a354eInbqyjLuw/xl8Ov83pZa+q8/sK87vepqvv65HDZ3ygeZfvFeb2svHVef7953Zflsg75b5vXttx3sLa8e9WPJ7CU9b7glbIdxYl9MrGXNdTfm9jt/qP78WRi4y2Pl7f4ru+28mfmlzW4J2Z+WcN5YuZh5l/I/Fju/wTt7dn21updvEWUJ/8C+a/bZX3htyaw35+K1Nf1yQSuy90Tr2VpD/7WX9Ytnpi5HvJLn7THXaW9jOmzj9qy3T9qa9v9qH3yUataTB3B19Av68e2t79u27o8+6zd95vz6nt/+9lbfRh6rPcnipQ4fjr+I/VyWctzauqXNRWnpn5ZV3Fq6pe1FaemHqZ+QuqX7ejfS/2434P04923PR+mvh3r7YVsx/62k25/Rn7Zin5e5Jdt6OdFftlGel7k9tHsyKtlND1ym2h65NbQ8ZH3+8Xj1uv+IXI7aHrkYeTZkds+0yO3faZHbvtMj9z2mR657TM78mb7TI/c9pkeue0zPXLbZ3rkYeTZkds+0yO3faZHbvtMj9z2mR657TM78rB9pkdu+0yP3PaZHrntMz3yMPLsyG2f6ZHbPtMjt32mR277TI/c9pkd+Wr7TI/c9pkeue0zPXLbZ3rkYeTZkds+0yO3faZHbvtMj9z2mR657TM78s32mR657TM9cttneuS2z/TIw8izI7d9pkdu+0yP3Pb5N0Qe9ydV9PVj5LbP9Mhtn9mR77bP9Mhtn+mR2z7TI7d9pkceRp4due0zPXLbZ3rkts/0yG2f6ZHbPrMjP2yf6ZHbPtMjt32mR277TI88jDw7cttneuS2z/TIbZ/pkds+0yO3fWZH3m2f6ZHbPtMjt32mR277TI88jDw7cttneuS2z/TIbZ/pkds+0yO3fSZHXhbbZ3rkts/0yG2f6ZFft332eov8Rag+Of35b1yVJUxxQIrX7YgjU7xu7RuZ4nWb3MgUr1vORqZ43b41MMVy3Qo1MsXrtqKRKV636IxM0e4yIsUwxQEp2l1GpGh3GZGi3WVEinaXESnaXQakWO0uI1K0u4xI0e4yIkW7y4gUwxS/lOKnd4DV7jIiRbvLiBTtLiNStLuMSNHuMiDFZncZkaLdZUSKdpcRKdpdRqQYpjggRbvLiBTtLiNStLuMSNHuMiJFu8uAFOOy3WXZbm/xeLGsP51+TeayfaSt9/mK8ux0rctxf4/7s2ksLyr29rrLXp7O7lLus1veZrc8fNn1PuhH3er7w688L9uMJuV52Y42Kc+Q51Q8L9tbJ+V52QY9Kc/LdvlJeV7WKkzK87J+Y06e62VNy6Q89UNz8dQPzcVTPzQXz5DnVDz1Q3Px1A/NxVM/NBdP/dBcPPVDU/Hc9ENz8dQPzcVTPzQXT/3QXDxDnlPx1A/NxVM/NBdP/dBcPPVDc/HUD03Fc9cPzcVTPzQXT/3QXDz1Q3PxDHlOxVM/NBdP/dBcPPVDc/HUD83FUz80Fc9DPzQXT/3QXDz1Q3Px1A/NxTPkORVP/dBcPPVDZ/Pca9x+9l63+IhI5YNHpMXBI1LMnI+o9xuiVj4i6roWPCL1CR6RRgSPSMmBRxQioiNSReARaRfovahrF/CItAt4RNoFOKK6aBfwiLQL8I2uLtoFPCLtAh5RiIiOSLuAR6RdwCPSLuARaRdOR/Tism+IXpzpR0TaBXp1LdoFPCLtAh6RdgGPSLuARxQigi/dRbuAR6RdwCPSLuARaRfwiLQLdERVu4BHpF3AI9Iu4BFpF+iXETVEBBdAVbuAR6RdwCPSLuARaRfwiLQL9KW7aRfwiLQLeETaBTwi7QIeUYiIjki7gEekXcAj0i7gEWkX6JcRTbtAF0ChXcAj0i7gEWkX8Ii0C3hEISL40h3aBTwi7QIekXYBj0i7gEekXaAjWrULeETaBTwi7QIekXaBfhmxhojgAmjVLuARaRfwiLQLeETaBTwi7QJ96d60C3hE2gU8Iu0CHpF2AY8oRERHpF3AI9Iu4BFpF/CItAv0y4hNu0AXQLt2AY9Iu4BHpF3AI9Iu4BGFiOBL965dwCPSLuARaRfwiLQLeETaBTqiQ7uAR6RdwCPSLuARaRfolxFHiAgugA7tAh6RdgGPSLuAR6RdwCPSLtCX7q5dwCPSLuARaRfwiLQLeEQhIjoi7QIekXYBj0i7gEekXaBfRnTtAlwAtUW7gEekXcAj0i7gEWkX8IhCROyluy3aBTwi7QIekXYBj0i7gEekXaAjKtoFPCLtAh6RdgGPSLsAv4x4oSYiuAAq2gU8Iu0CHpF2AY9Iu4BHpF2gL91Vu4BHpF3AI9Iu4BFpF/CIQkR0RNoFPCLtAh6RdgGPSLtAv4yo2gW6AGraBTwi7QIekXYBj0i7gEcUIoIv3U27gEekXcAj0i7gEWkX8Ii0C3REoV3AI9Iu4BFpF/CItAv0y4gIEcEFUGgX8Ii0C3hE2gU8Iu0CHpF2gb50r9oFPCLtAh6RdgGPSLuARxQioiPSLuARaRfwiLQLeETaBfplxKpdoAugTbuAR6RdwCPSLuARaRfwiEJE8KV70y7gEWkX8Ii0C3hE2gU8Iu0CHdGuXcAj0i7gEWkX8Ii0C/TLiD1EBBdAu3YBj0i7gEekXcAj0i7gEWkX6Ev3oV3AI9Iu4BFpF/CItAt4RCEiOiLtAh6RdgGPSLuAR6RdoF9GHNoFugDq2gU8Iu0CHpF2AY9Iu4BHFCKCL91du4BHpF3AI9Iu4BFpF/CItAtwRLFoF/CItAt4RNoFPCLtAvwyIpYQEVsAxaJdwCPSLuARaRfwiLQLeETaBfrSXbQLeETaBTwi7QIekXYBjyhEREekXcAj0i7gEWkX8Ii0C/TLiKJdoAugql3AI9Iu4BFpF/CItAt4RCEi+NJdtQt4RNoFPCLtAh6RdgGPSLtAR9S0C3hE2gU8Iu0CHpF2gX4Z0UJEcAHUtAt4RNoFPCLtAh6RdgGPSLtAX7pDu4BHpF3AI9Iu4BFpF/CIQkR0RNoFPCLtAh6RdgGPSLtAv4wI7QJdAK3aBTwi7QIekXYBj0i7gEcUIoIv3at2AY9Iu4BHpF3AI9Iu4BFpF+iINu0CHpF2AY9Iu4BHpF2gX0ZsISK4ANq0C3hE2gU8Iu0CHpF2AY9Iu0BfunftAh6RdgGPSLuAR6RdwCMKEdERaRfwiLQLeETaBTwi7QL9MmLXLtAF0KFdwCPSLuARaRfwiLQLeEQhIvjSfWgX8Ii0C3hE2gU8Iu0CHpF2gY6oaxfwiLQLeETaBTwi7QL9MqKHiOACqGsX8Ii0C3hE2gU8Iu0CHpF2Ab50r4t2AY9Iu4BHpF3AI9Iu4BGFiOiItAt4RNoFPCLtAh6RdgF+GbEu2gW4AFqLdgGPSLuAR6RdwCPSLuARhYjgS3fRLuARaRfwiLQLeETaBTwi7QIdUdUu4BFpF/CItAt4RNoF+mVEDRHBBVDVLuARaRfwiLQLeETaBTwi7QJ96W7aBTwi7QIekXYBj0i7gEcUIqIj0i7gEWkX8Ii0C3hE2gX6ZUTTLtAFUGgX8Ii0C3hE2gU8Iu0CHlGICL50h3YBj0i7gEekXcAj0i7gEWkX6IhW7QIekXYBj0i7gEekXaBfRqwhIrgAWrULeETaBTwi7QIekXYBj0i7QF+6N+0CHpF2AY9Iu4BHpF3AIwoR0RFpF/CItAt4RNoFPCLtAv0yYtMu0AXQrl3AI9Iu4BFpF/CItAt4RCEi+NK9axfwiLQLeETaBTwi7QIekXaBjujQLuARaRfwiLQLeETaBfplxBEiggugQ7uAR6RdwCPSLuARaRfwiLQL9KW7axfwiLQLeETaBTwi7QIeUYiIjki7gEekXcAj0i7gEWkX6JcRXbsAF0Dbol3AI9Iu4BFpF/CItAt4RCEi9tK9LdoFPCLtAh6RdgGPSLuAR6RdoCMq2gU8Iu0CHpF2AY9IuwC/jNhKiAgugIp2AY9Iu4BHpF3AI9Iu4BFpF+hLd9Uu0Jfuql2gf9BV7QIekXYBjyhEREekXcAj0i7gl27tAn7p1i7gP+i0C3RETbuAR6RdwCPSLuARaRfoS3cLEdERaRfwiLQLeETahdMRxf30yx/3j4i0C3hE2oUvIWrL7XRtex2KaOtL+fP01stPiB687Bq3N3nUrX7gGaqIuXjqLebiqeSYi6dGZC6eIc+peOpa5uKpmJmLpxZnLp4qn7l46oem4rnqh+biqR+ai6d+aC6e+qG5eIY8p+KpH5qLp35oLp76obl46ofm4qkfmornph+ai6d+aC6e+qG5eOqH5uIZ8pyKp35oLp76obl46ofm4qkfmounfmgqnrt+aC6e+qG5eOqH5uKpH5qLZ8jzZJ7PHnK1q3zwiLQ4eESKmfMRff4EpV3XgkekPqEjOjQieERKDjwivQUekSoCjyhEBO9Fh3YBj0i7gEekXcAj0i7gEWkX6Btd1y7gEWkX8Ii0C3hE2gU8ohARHZF2AY9Iu3A6oif/VdyuXaBX165dwCPSLsAR7Yt2AY9Iu4BHpF2AL937ol3AIwoR0RFpF/CItAt4RNoFPCLtAh6RdoGOqGgX8Ii0C/DLiL1oF+gCqGgX8IhCRHRE2gU8Iu0CHpF2Ab90axfwiLQLdERVu4BHpF3AI9Iu4BFpF/CIQkR0RNoFPCLtAv0yomoX6AKoahfwiLQLdERNu4BHpF3AI9Iu0Jfupl3AIwoR0RFpF/CItAt4RNoFPCLtAh6RdoGOKLQLeETaBfplRGgX6AIotAt4RCEiOiLtAh6RdgGPSLuAX7q1C3hE2gU6olW7gEekXcAj0i7gEWkX8IhCRHRE2gU8Iu0C/TJi1S7QBdCqXcAj0i7QEW3aBTwi7QIekXaBvnRv2gU8ohARHZF2AY9Iu4BHpF3AI9Iu4BFpF+iIdu0CHpF2gX4ZsWsX6AJo1y7gEYWI6Ii0C3hE2gU8Iu0CfunWLuARaRfoiA7tAh6RdgGPSLuAR6RdwCMKEdERaRfwiLQL9MuIQ7tAF0CHdgGPSLtAR9S1C3hE2gU8Iu0Cfenu2gU8ohARHZF2AY9Iu4BHpF3AI9Iu4BFpF+CIjkW7gEekXYBfRhyLdgEugI5Fu4BHFCKiI9Iu4BFpF/CItAv4pVu7gEekXaAjKtoFPCLtAh6RdgGPSLuARxQioiPSLuARaRfolxFFu0AXQEW7gEekXaAjqtoFPCLtAh6RdoG+dFftAh5RiIiOSLuAR6RdwCPSLuARaRfwiLQLdERNu4BHpF2gX0Y07QJdADXtAh5RiIiOSLuAR6RdwCPSLuCXbu0CHpF2gY4otAt4RNoFPCLtAh6RdgGPKERER6RdwCPSLtAvI0K7QBdAoV3AI9Iu0BGt2gU8Iu0CHpF2gb50r9oFPKIQER2RdgGPSLuAR6RdwCPSLuARaRfoiDbtAh6RdoF+GbFpF+gCaNMu4BGFiOiItAt4RNoFPCLtAn7p1i7gEWkX6Ih27QIekXYBj0i7gEekXcAjChHREWkX8Ii0C/TLiF27QBdAu3YBj0i7QEd0aBfwiLQLeETaBfrSfWgX8IhCRHRE2gU8Iu0CHpF2AY9Iu4BHpF2gI+raBTwi7QL9MqJrF+gCqGsX8IhCRHRE2gU8Iu0CHpF2Ab90axfwiLQLcER90S7gEWkX8Ii0C3hE2gU8ohARHZF2AY9IuwC/jOiLdgEugPqiXcAj0i7QERXtAh6RdgGPSLtAX7qLdgGPKERER6RdwCPSLuARaRfwiLQLeETaBTqiql3AI9Iu0C8jqnaBLoCqdgGPKERER6RdwCPSLuARaRfwS7d2AY9Iu0BH1LQLeETaBTwi7QIekXYBjyhEREekXcAj0i7QLyOadoEugJp2AY9Iu0BHFNoFPCLtAh6RdoG+dId2AY8oRERHpF3AI9Iu4BFpF/CItAt4RNoFOqJVu4BHpF2gX0as2gW6AFq1C3hEISI6Iu0CHpF2AY9Iu4BfurULeETaBTqiTbuAR6RdwCPSLuARaRfwiEJEdETaBTwi7QL9MmLTLtAF0KZdwCPSLtAR7doFPCLtAh6RdoG+dO/aBTyiEBEdkXYBj0i7gEekXcAj0i7gEWkX6IgO7QIekXaBfhlxaBfoAujQLuARhYjoiLQLeETaBTwi7QJ+6dYu4BFpF+iIunYBj0i7gEekXcAj0i7gEYWI6Ii0C3hE2gX6ZUTXLtAFUNcu4BFpF9iIjmXRLuARaRfwiLQL7KX7BZF2AY8oRERHpF3AI9Iu4BFpF/CItAt4RNoFOqKiXcAj0i6wLyNeEGkX6AKoaBfwiEJEdETaBTwi7QIekXYBv3RrF/CItAt0RFW7gEekXcAj0i7gEWkX8IhCRHRE2gU8Iu0C/TKiahfoAqhqF/CItAt0RE27gEekXcAj0i7Ql+6mXcAjChHREWkX8Ii0C3hE2gU8Iu0CHpF2gY4otAt4RNoF+mVEaBfoAii0C3hEISI6Iu0CHpF2AY9Iu4BfurULeETaBTqiVbuAR6RdwCPSLuARaRfwiEJEdETaBTwi7QL9MmLVLtAF0KpdwCPSLtARbdoFPCLtAh6RdoG+dG/aBTyiEBEdkXYBj0i7gEekXcAj0i7gEWkX6Ih27QIekXaBfhmxaxfoAmjXLuARhYjoiLQLeETaBTwi7QJ+6dYu4BFpF+iIDu0CHpF2AY9Iu4BHpF3AIwoR0RFpF/CItAv0y4hDu0AXQId2AY9Iu0BH1LULeETaBTwi7QJ96e7aBTyiEBEdkXYBj0i7gEekXcAj0i7gEWkX4IjKol3AI9IuwC8jyqJdgAugsmgX8IhCRHRE2gU8Iu0CHpF2Ab90axfwS7d2gf5BV7QLeETaBTwi7QIekXYBjyhEBF+6i3aBvnQX7QL+g067gEekXcAj0i7QEVXtAh6RdoG+dFftAh6RdgGPKERER6RdOB1R3E+//HH/iEi7gEekXfgaol5u7zGW/tPp1xxVAGNytKcPybFZpsfkaOMdk6O1dEyOdscv5fjyYu85tuPJ6d6O2yvpsfy0JH083Npx6yWt9XeH90eHl7rfwbT2/vArzhDnTDjtpFPhtL9OhdOu+1vhLOvtdbSy9484rdxT4bT5z4QzFBC/F85+x1lL+/xw3eq9pW7tyeHSW3mY9W1QNCwOyo/Dy3IDU5f65PC634ivvb9/e68zpW1ypkbPlObNmRo9U+FMOVM/Ziq2+0xt/ZdmSgfpTI2eKUWoM/Xj8Fvrr+WIj2VOxeqgfGlQlLcOypcGRS3soLxSvL+M2urx+eGXu74b8peLhfJhqlbttFM1fqpU2U7V96dqLbfDZY36Kz1t1Xs7gKcOoJLcATx1AMMBdAC/P4Db/TsK688l9NsDqH53AE8dQF39xAO47vcBfHal8+yLV6uu3kH5cXjcFxpWtb4zNXqmvAFwpl5natgXGjb9vzM1eqa0/87Uj8NPrrQ3Lb2D8qVB0aY7KF8alHBQHJRvS8cnX2fYVNlO1fip0k87Vd+fqnFXxJve2wE8dQCV5A7gqQOoUXcA/8IADvuOwq5+dwBPHUBd/bwDuLfbI+/rvv1iW9119Q7KlwZFV++gDN7T93CmnKnBM6XUd6ZGz5RK35ka3dC09M7U6JlSvP9WM1X3uM/U8cwkjXwm8a4gd1B+HB73awyHztuZGj1TamxnavRMabydqdeZGvarMYdy3JkaPVPhTDlTfxx+8ssRh8bbQfnSoKixHZQvDYpu2kF5pTjwF2MO7bRTNX6qVNlO1fenatyXA7re2wE8dQCV5A7gqQOoUXcA/8IADvveS1e/O4CnDmA4gPMO4MBnEnddvYPy4/C4LzR0tb4zNXqmvAFwpl5natgXGrr+35kaPVPaf2fqx+HPr7Rf/ml0UByUrwyKNt1B+dKgaL0dlO9Lx8+/zlAXVbZTNX6qwqlyqr49VcOuiOui93YATx1AJbkDeOoAatQdwL8wgKO+o1AX9bsDeOoA6urnHcCBj5qtRVfvoHxpUHT1DsrgPb2o9Z2p0TOl1HemRs9UOFPO1NiGVrT0ztTomVK8f2mmtuUuZbZSfzr9mqP+eEyOl9Wga7v97GNbypPT63L/Sx3L29kWj/I4yv3z8OVH30+3/ug9HvV4x3N/errcPraOur7xfPkhD07vPW6n997bk9PtjUx7+4yry6O32Ep7c6bb54dLa2/a4v1rfnh4idurKMu7D/GXw6/zellr6rz+wrzu96mq+/rkcNnfKB5l+7V5rZeVt87rbzmvl3XIf9u8tuW+g7Xl3at+PIGlrPcFr5TtKE7sk4m9rKH+3sRu9x/djycTG295vLzFd323lT8zv6zBPTHzMPP0zC9rAL+V+bHc/wna27PtrdW7eIsoT/4F8l+3y/rCb01gvz8Vqa/rkwlcl7snXsvSHvytv6xbPDFzPeSXPmmPu0pblu3ZR23Z7h+1te1+1D75qFUtpo7gj9DbZf3Y9vbXbVuXZ5+1+35zXn3vbz97qw9Dj/X+RJESx0/HX1O/rOU5NfXLmopTU7+sqzg19TD1E1K/rK84NfXLdvTvpX7c70H68e7bng9T34719kK2Y3/bSbc/I79sRT8v8ss29PMiv2wjPS3ysI+mR24ZTY/cJpoeuTV0fOT9fvG49bp/iDyMPDtyC2h65LbP9Mhtn+mR2z7TI7d9Zke+2j7TI7d9pkdu+0yP3PaZHnkYeXbkts/0yG2f6ZHbPtMjt32mR277zI58s32mR277TI/c9pkeue0zPfIw8uzIbZ/pkds+0yO3faZHbvtMj9z2mR35bvtMj9z2mR657TM9cttneuRh5NmR2z7TI7d9pkdu+0yP3PaZHrntMzvyw/aZHrntMz1y22d65LbP9MjDyLMjt32mR277TI/c9pkeue3zb4g87k+q6OvHyG2f2ZF322d65LbP9Mhtn+mR2z7TIw8jz47c9pkeue0zPXLbZ3rkts/0yG2fyZG3xfaZHrntMz1y22d65LbP9MjDyLMjt32mR277TI/c9pkeue0zPXLbZ3bkxfaZHrntMz1y22d65LbP9MjDyLMjt32mR277TI/c9pkeue0zPXLbZ3bk1faZHrntMz1y22d65LbP9MjjspH3eot8X44npz//jatWr1soR6Z43Y44MsXr1r6RKV63yY1M8brlbGCK7bp9a2SK161QI1O8bisameJ1i87IFMMUB6RodxmRot1lRIp2lxEp2l1GpGh3GZBi2F1GpGh3GZGi3WVEinaXESmGKQ5I0e7ytRQ/vQMMu8uIFO0uI1K0u4xI0e4yIMXV7jIiRbvLiBTtLiNStLuMSDFMcUCKdpcRKdpdRqRodxmRot1lRIp2lwEpbnaXESletrss2+0tHqXGT6dfk7lsH3mpYrdkojw7Xety3N/j/mwaS6k3213KXp7O7lLus1veZrc8fNn1PuhH3er7w688L9uMJuUZ8pyK52Xb4qQ8L9tbJ+V52QY9Kc/LdvlJeV7WKszJc7+s35iU52VNy6Q89UNz8dQPzcUz5DkVT/3QXDz1Q3Px1A/NxVM/NBdP/dBUPA/90Fw89UNz8dQPzcVTPzQXz5DnVDz1Q3Px1A/NxVM/NBdP/dBcPPVDU/Hs+qG5eOqH5uKpH5qLp35oLp4hz6l46ofm4qkfmounfmgunvqhuXjqh2biGYt+aC6e+qG5eOqH5uKpH5qLZ8hzKp76obl46ofm4qkfOpvnXuP2s/e6xUdEKh88Ii0OHVFRzJyPqPcbolYeINK14BGpT/CINCJ4RCEiOiK9BR6RKgKPSLuA70XaBTwi7QIdUdUu4BFpF/CItAv0ja5qF/CIQkR0RNoFPCLtAh6RdgGPSLuAR6RdOB1R6bfTL3/cPiBq2gV6dW3aBTwi7QIekXYBjyhEREekXaAv3U27gEekXcAj0i7gEWkX6IhCu4BHpF3AI9Iu4BFpF/CIQkTwy4jQLtAFUGgX8Ii0C3hE2gU8Iu0CHdGqXaAv3at2AY9Iu4BHpF3AIwoR0RFpF/CItAt4RNoFPCLtAh6RdoF+GbFpF+gCaNMu4BFpF/CItAt4RCEiOiLtAn3p3rQLeETaBTwi7QIekXaBjmjXLuARaRfwiLQLeETaBTyiEBH8MmLXLtAF0K5dwCPSLuARaRfwiLQLdESHdoG+dB/aBTwi7QIekXYBjyhEREekXcAj0i7gEWkX8Ii0C3hE2gX6ZUTXLtAFUNcu4BFpF/CItAt4RCEiOiLtAn3p7toFPCLtAh6RdgGPSLsAR7Qu2gU8Iu0CHpF2AY9Iu4BHFCJiX0asi3YBLoDWRbuAR6RdwCPSLuARaRfoiIp2gb50F+0CHpF2AY9Iu4BHFCKiI9Iu4BFpF/CItAt4RNoFPCLtAv0yomoX6AKoahfwiLQLeETaBTyiEBEdkXaBvnRX7QIekXYBj0i7gEekXaAjatoFPCLtAh6RdgGPSLuARxQigl9GNO0CXQA17QIekXYBj0i7gEekXaAjCu0CfekO7QIekXYBj0i7gEcUIqIj0i7gEWkX8Ii0C3hE2gU8Iu0C/TJi1S7QBdCqXcAj0i7gEWkX8IhCRHRE2gX60r1qF/CItAt4RNoFPCLtAh3Rpl3AI9Iu4BFpF/CItAt4RCEi+GXEpl2gC6BNu4BHpF3AI9Iu4BFpF+iIdu0CfenetQt4RNoFPCLtAh5RiIiOSLuAR6RdwCPSLuARaRfwiLQL9MuIQ7tAF0CHdgGPSLuAR6RdwCMKEdERaRfoS/ehXcAj0i7gEWkX8Ii0C3REXbuAR6RdwCPSLuARaRfwiEJE8MuIrl2gC6CuXcAj0i7gEWkX8Ii0C3BE26JdgC/d26JdwCPSLuARaRfwiEJEdETaBTwi7QIekXYBj0i7gEekXYBfRmxFu0AXQEW7gEekXcAj0i7gEYWI6Ii0C/Slu2gX8Ii0C3hE2gU8Iu0CHVHVLuARaRfwiLQLeETaBTyiEBH8MqJqF+gCqGoX8Ii0C3hE2gU8Iu0CHVHTLtCX7qZdwCPSLuARaRfwiEJEdETaBTwi7QIekXYBj0i7gEekXaBfRoR2gS6AQruAR6RdwCPSLuARhYjoiLQL/z97d5QcN44sUHRLBJAEiH29/cfTyCpKDle4Sm0YdQ3e+eoPhkPKm10NHMoa+qE71AV8InUBn0hdwCdSF+iJdnUBn0hdwCdSF/CJ1AV8ojAR/GXEri7QAWhXF/CJ1AV8InUBn0hdoCeq6gL90F3VBXwidQGfSF3AJwoT0ROpC/hE6gI+kbqAT6Qu4BOpC/SXEU1doANQUxfwidQFfCJ1AZ8oTERPpC7QD91NXcAnUhfwidQFfCJ1gZ7oUBfwidQFfCJ1AZ9IXcAnChPBX0Yc6gIdgA51AZ9IXcAnUhfwidQFeqKuLtAP3V1dwCdSF/CJ1AV8ojARPZG6gE+kLuATqQv4ROoCPpG6AH8Z0TZ1AQ5AbVMX8InUBXwidQGfKExET6QuwA/dbVMX8InUBXwidQGfSF2gJ0rqAj6RuoBPpC7gE6kL+ERhIvjLiKQu0AEoqQv4ROoCPpG6gE+kLtATZXWBfujO6gI+kbqAT6Qu4BOFieiJ1AV8InUBn0hdwCdSF/CJ1AX6y4iiLtABqKgL+ETqAj6RuoBPFCaiJ1IX6Ifuoi7gE6kL+ETqAj6RukBPFOoCPpG6gE+kLuATqQv4RGEi+MuIUBfoABTqAj6RuoBPpC7gE6kL9ES7ukA/dO/qAj6RuoBPpC7gE4WJ6InUBXwidQGfSF3AJ1IX8InUBfrLiKou0AGoqgv4ROoCPpG6gE8UJqInUhfoh+6qLuATqQv4ROoCPpG6QE/U1AV8InUBn0hdwCdSF/CJwkTwlxFNXaADUFMX8InUBXwidQGfSF2gJzrUBfqh+1AX8InUBXwidQGfKExET6Qu4BOpC/hE6gI+kbqAT6Qu0F9GdHWBDkBdXcAnUhfwidQFfKIwET2RukA/dHd1AZ9IXcAnUhfwidQFeKJjUxfwidQFfCJ1AZ9IXcAnChOxX0Ycm7oAB6BjUxfwidQFfCJ1AZ9IXaAnSuoC/dCd1AV8InUBn0hdwCcKE9ETqQv4ROoCPpG6gE+kLuATqQv0lxFZXaADUFYX8InUBXwidQGfKExET6Qu0A/dWV3AJ1IX8InUBXwidYGeqKgL+ETqAj6RuoBPpC7gE4WJ4C8jirpAB6CiLuATqQv4ROoCPpG6QE8U6gL90B3qAv3QHeoC/oNOXcAnChPRE6kL+ETqAj6RuoA/dKsL+EO3ukD/oNvVBXwidQGfSF3AJ1IX8InCRPBD964u4BOpC/hE6gI+kbrw8kRxPv32j+3XROoCPVFVF55KVLbb07m0PDRR7Vv6eLr29FOiO192jts3eeSaf+0pRazVU7dYq6fIsVbPsOdSPeWTtXpqLWv1FGbW6qnirNVT8lmqZ9OH1uqpD63VUx9aq6c+tFbPsOdSPfWhtXrqQ2v11IfW6qkPrdVTH1qq56EPrdVTH1qrpz60Vk99aK2eYc+leupDa/XUh9bqqQ+t1VMfWqunPrRUz64PrdVTH1qrpz60Vk99aK2eYc+leupDr+756JdcdckHn0jFwScSZl6f6Pe/QalrLfBEfZNP8IkUEXwikQOfSLfAJwoT0ROpC/B7Ud/UBXwidQGfSF3AJ1IX6ImSukA/0SV1AZ9IXcAnUhfwicJE9ETqAj6RuoBPpC68PNHv/19xe1IX8FdXdYGeKKsL+ETqAj6RuoBPpC7QD905TERPpC7gE6kL+ETqAj6RuoBPpC7QExV1AZ9IXcAnUhfoLyOKukAHoBImoidSF/CJ1AV8InUBn0hdwB+61QV6olAX8InUBXwidQGfSF3AJwoT0ROpC/hE6gI+kbpAfxkR6gIdgEJdoCfa1QV8InUBn0hdwCdSF+iH7j1MRE+kLuATqQv4ROoCPpG6gE+kLtATVXUBn0hdwCdSF+gvI6q6QAegGiaiJ1IX8InUBXwidQGfSF3AH7rVBXqipi7gE6kL+ETqAj6RuoBPFCaiJ1IX8InUBXwidYH+MqKpC3QAauoCPdGhLuATqQv4ROoCPpG6QD90H2EieiJ1AZ9IXcAnUhfwidQFfCJ1gZ6oqwv4ROoCPpG6QH8Z0dUFOgD1MBE9kbqAT6Qu4BOpC/hE6gL+0K0usBP1bVMX8InUBXwidQGfSF3AJwoT0ROpC/hE6gI+kbrAfhnxlkhdYAPQWyJ1gZ4oqQv4ROoCPpG6gE+kLtAP3SlMRE+kLuATqQv4ROoCPpG6gE+kLtATZXUBn0hdwCdSF+gvI7K6QAegHCaiJ1IX8InUBXwidQGfSF3AH7rVBXqioi7gE6kL+ETqAj6RuoBPFCaiJ1IX8InUBXwidYH+MqKoC3QAKuoCPVGoC/hE6gI+kbqAT6Qu0A/dESaiJ1IX8InUBXwidQGfSF3AJ1IX6Il2dQGfSF3AJ1IX6C8jdnWBDkB7mIieSF3AJ1IX8InUBXwidQF/6FYX6ImquoBPpC7gE6kL+ETqAj5RmIieSF3AJ1IX8InUBfrLiKou0AGoqgv0RE1dwCdSF/CJ1AV8InWBfuhuYSJ6InUBn0hdwCdSF/CJ1AV8InWBnuhQF/CJ1AV8InWB/jLiUBfoAHSEieiJ1AV8InUBn0hdwCdSF/CHbnWBnqirC/hE6gI+kbqAT6Qu4BOFieiJ1AV8InUBn0hdoL+M6OoCHYC6ugBPlDZ1AZ9IXcAnUhfwidQF+KE7bWEieiJ1AZ9IXcAnUhfwidQFfCJ1gZ4oqQv4ROoCPpG6AH8ZkZK6QAegFCaiJ1IX8InUBXwidQGfSF3AH7rVBXqirC7gE6kL+ETqAj6RuoBPFCaiJ1IX8InUBXwidYH+MiKrC3QAyuoCPVFRF/CJ1AV8InUBn0hdoB+6S5iInkhdwCdSF/CJ1AV8InUBn0hdoCcKdQGfSF3AJ1IX6C8jQl2gA1CEieiJ1AV8InUBn0hdwCdSF/CHbnWBnmhXF/CJ1AV8InUBn0hdwCcKE9ETqQv4ROoCPpG6QH8ZsasLdADa1QV6oqou4BOpC/hE6gI+kbpAP3TXMBE9kbqAT6Qu4BOpC/hE6gI+kbpAT9TUBXwidQGfSF2gv4xo6gIdgFqYiJ5IXcAnUhfwidQFfCJ1AX/oVhfoiQ51AZ9IXcAnUhfwidQFfKIwET2RuoBPpC7gE6kL9JcRh7pAB6BDXaAn6uoCPpG6gE+kLuATqQv0Q3cPE9ETqQv4ROoCPpG6gE+kLuATqQvwRHlTF/CJ1AV8InUB/jIib+oCHIDyFiaiJ1IX8InUBXwidQGfSF3AH7rVBXqipC7gE6kL+ETqAj6RuoBPFCaiJ1IX8InUBXwidYH+MiKpC3QASuoCPVFWF/CJ1AV8InUBn0hdoB+6c5iInkhdwCdSF/CJ1AV8InUBn0hdoCcq6gI+kbqAT6Qu0F9GFHWBDkAlTERPpC7gE6kL+ETqAj6RuoA/dKsL9EShLuATqQv4ROoCPpG6gE8UJqInUhfwidQFfCJ1gf4yItQFOgCFukBPtKsL+ETqAj6RuoBPpC7QD917mIieSF3AJ1IX8InUBXwidQGfSF2gJ6rqAj6RuoBPpC7QX0ZUdYEOQDVMRE+kLuATqQv4ROoCPpG6gD90qwv0RE1dwCdSF/CJ1AV8InUBnyhMRE+kLuATqQv4ROoC/WVEUxfoANTUBXqiQ13AJ1IX8InUBXwidYF+6D7CRPRE6gI+kbqAT6Qu4BOpC/hE6gI9UVcX8InUBXwidYH+MqKrC3QA6mEieiJ1AZ9IXcAnUhfwidQF/KFbXYAnKpu6gE+kLuATqQv4ROoCPlGYiJ5IXcAnUhfwidQF+MuIsqkLcAAqm7pAT5TUBXwidQGfSF3AJ1IX6IfuFCaiJ1IX8InUBXwidQGfSF3AJ1IX6ImyuoBPpC7gE6kL9JcRWV2gA1AOE9ETqQv4ROoCPpG6gE+kLuAP3eoC/dBd1AX6B11RF/CJ1AV8InUBnyhMRE+kLtAP3UVdwB+61QX8B526gE+kLtAThbqAT6Qu4BOpC/RDd6gL+ERhInoidQGfSF14eaI4n377x/ZrInUBn0hdeC5RT7fvMbb+09M/5igBDJnj7j19zBy9TI+ZozfeMXP0WjpmjuEcn5nj2xd7zrEcD57u5bh9JT22nw5Jvz789kLmdi95g/8vD7d7D2+5nWFK+frwj5zeM5fK6Z10qZzeX5fK6V33n8qZ9tvXUVLrv+b0yr1SzurNf6mcAsS/lbOfOXMqv38413zeUmt58HDqJd2d9W1RFBYX5f3hbbuFyVt+8PDebsX33r9+ez92Sm1yp0bvVLhT7tTgnZL/3KkfOxX13Kna/2inNEh3avROCaHu1PvDn7f+nI749TInsbooTy2KeOuiPLMoTRZ2UX5UPL+MXPLx+4dTOc8zqfT061ap027V+K2Sst2q72/Vnm4Ppz3yn9zTmu7tAr50AcMFdAFfuYCKugv4Hxawnj+jsP98Cf32AsrvLuBLF1CrX3gB93Yu4KNXOo9+8Kpp9S7K+8PjfqChyfru1OCdOnwD4E792KlhP9Bw6P/u1OidUv/dqfeHH7zSPlR6F+WpRQkXxUV5ZlFUbxfl++j44McZDinbrRq/Vfq0W/X9rRr3ivjQvV3Aly6gSO4CvnIBu6LuAv6HBRz2MwpdfncBX7qAWv26C9jK7Vfe51b/8LbatXoX5alFCRfFRRl8Tpf13anROyXqu1Ojd0rSd6dG39BUendq9E4J7//UTuUW504djyRp4O8kjk0gd1HeHx721xhi07zdqdE7JWO7U6N3SvF2p37s1Ki/GhNbuFPu1OCdEsfdqfeHf/+XI2JTvF2UpxZFxnZRnloUbdpF+VFx3F+MiU2ddquGb1WSst2q72/VsB8OiKR7u4AvXUCR3AV86QIq6i7gf1jAUT/3EilcQBfwlQuo1S+8gON+J3Ekrd5FeX943A80JFnfnRq9U74BcKd+7NSwH2hI+r87NXinsvrvTr0//OCVdlbpXZSnFkVNd1GeWhTV20X5Pjo++HGGHG6VWzV8q/Rpt+r7WzXuFXHWvV3Aly6gSO4CvnQBFXUX8D8s4LCfUcjyuwv4ygUsWv26CzjwV81G0epdlKcWRat3UQaf04us706N3qlwp9ypwTsl6btTo29oKr07NXqnhPendqpuJ8rUlH96+scc9eMxc7wsg+7l9mcfdUsPnt6381/q2D6fLXFvHkc6Pw/f/ujz6dLvfY9HPr70bA+fTrePrSPvnz3f/pA7T7cet6db7+XB0+WzTPn8jMvbvW+xpPJppvX3D6dSPtni69d89+Etbl9F2r58iL89/L6vcVk1dV//YF/buVW57Q8eTu2z4pHqH+7rZfHWff0n9/WyhvzX9rVs5xmsbF++6vsbmNJ+HvBSqkdyYx9s7GWF+nsbW88/uh8PNjY+5/H2LX6575b0MfNw5tNnflnhfOHMLyuA35r5sZ3/CWrl0emt5BPe3k7HD/4L5H/dLuuF39rAfv5WpL7vDzZw304n3tNW7vxbf1lbfOHMdcinPmmPk9K2rT76qE31/KjNpflR+/uP2l1anLqCP4Z+WR+rn/+61X179Fnb2s28euuff3bNd4ce+/kbRVIcPz3+Y+qXVZ6XTv2yUvHSqYdTf8HUL6sVL536Zb3ipVO/7B39e1M/zvcg/fjy0553p16P/faF1KN9nknrx8gve0V/3cgve0N/2cjrZW+krxu599HpI/cyOn3k3kSnjzwc+fCR9/PFY+25/TJy76DTR+4FdPrIvX1OH7m3z+kj9/Y5e+TN2+f0kXv7nD5yb5/TR+7tc/rIw5HPHrm3z+kj9/Y5feTePqeP3Nvn9JF7+5w98sPb5/SRe/ucPnJvn9NH7u1z+sjDkc8eubfP6SP39jl95N4+p4/c2+f0kXv7nD3y7u1z+si9fU4fubfP6SP39jl95OHIZ4/c2+f0kXv7nD5yb5/TR+7tc/rIvX1OHvm+efucPnJvn9NH7u1z+si9fU4feTjy2SP39jl95N4+p4/c2+f0kXv7nD5yb59/YeRx/qaKvv8y8uTtc/rIvX1OH7m3z+kj9/Y5feThyGeP3Nvn9JF7+5w+cm+f00fu7XP6yL19zh559vY5feTePqeP3Nvn9JF7+5w+8nDks0fu7XP6yL19Th+5t8/pI/f2OX3k3j5nj7x4+5w+cm+f00fu7XP6yL19Th95OPLZI/f2OX3k3j6nj9zb5/SRe/ucPnJvn7NHHt4+p4/c2+f0kXv7nD5yb5/TRx6OfPbIr3v77Pk28rYdD55+8Deu4roXypFTvO4dceQUr3vtGznF697kBk5xv+7lbOQUr3vfGjnF616hRk7xureikVMMpzhgit5dRkzRu8uIKXp3GTFF7y4jpujdZcAUq3eXEVP07jJiit5dRkzRu8uIKYZTHDBF7y4jpujd5bkp/vYdYPXuMmKK3l1GTNG7y4ApNu8uI6bo3WXEFL27jJiid5cRUwynOGCK3l1GTNG7y4gpencZMUXvLiOm6N1lwBQP7y4jpujdZcQUL3t32ertWzxSjp+e/jGZy95Hyn7uV6RHT+e8Hef32B5tY0r5pt0ptfRwd7d07m763N1098vO56IfueavD//oGfZcqudl72iL9rzsbXHRnpe9ty7a87I36EV7XvYuv2bPfllVWLTnZX1j0Z6XlZZFe+pDa/UMey7VUx9aq6c+tFZPfWitnvrQWj31oZV61k0fWqunPrRWT31orZ760Fo9w55L9dSH1uqpD63VUx9aq6c+tFZPfWipnkkfWqunPrRWT31orZ760Fo9w55L9dSH1uqpD63VUx9aq6c+tFZPfWipnlkfWqunPrRWT31orZ760Fo9w55L9dSH1uqpD63VUx9aq6c+9OqeLcftz265xq+JJB96oqLi4BMJM69P1PstUUl3Emkt+ETyCT5RmIieSOTAJ9It8ImkCHwidQF/L1IX6IlCXcAnUhfwidQFfCJ1gX6iizARPZG6gE+kLuATqQv4ROoCPpG6QE+0qwsvT5T67em3f6y/JlIX6FfXXV3AJ1IX8InCRPRE6gI+kbqAP3SrC/hE6gI+kbpAT1TVBXwidQGfSF3AJ1IX8InCRPRE6gL9ZURVF+gAVNUFfCJ1AZ9IXaAnauoCPpG6QD90N3UBn0hdwCcKE9ETqQv4ROoCPpG6gE+kLuATqQv0RIe6QH8ZcagLdAA61AV8InUBnyhMRE+kLuATqQv4Q7e6gE+kLuATqQv0RF1dwCdSF/CJ1AV8InUBnyhMRE+kLtBfRnR1gQ5AXV3AJ1IX8InUBXiitqkL+ETqAvzQ3TZ1AZ9IXcAnChPRE6kL+ETqAj6RuoBPpC7gE6kL9ERJXYC/jGhJXaADUFIX8InUBXyiMBE9kbqAT6Qu4A/d6gI+kbqAT6Qu0BNldQGfSF3AJ1IX8InUBXyiMBE9kbpAfxmR1QU6AGV1AZ9IXcAnUhfoiYq6gE+kLtAP3UVdwCdSF/CJwkT0ROoCPpG6gE+kLuATqQv4ROoCPVGoC/SXEaEu0AEo1AV8InUBnyhMRE+kLuATqQv4Q7e6gE+kLuATqQv0RLu6gE+kLuATqQv4ROoCPlGYiJ5IXaC/jNjVBToA7eoCPpG6gE+kLtATVXUBn0hdoB+6q7qAT6Qu4BOFieiJ1AV8InUBn0hdwCdSF/CJ1AV6oqYu0F9GNHWBDkBNXcAnUhfwicJE9ETqAj6RuoA/dKsL+ETqAj6RukBPdKgL+ETqAj6RuoBPpC7gE4WJ6InUBfrLiENdoAPQoS7gE6kL+ETqAj1RVxfwidQF+qG7qwv4ROoCPlGYiJ5IXcAnUhfwidQFfCJ1AZ9IXYAnOjZ1Af4y4tjUBTgAHZu6gE+kLuAThYnoidQFfCJ1AX/oVhfwidQFfCJ1gZ4oqQv4ROoCPpG6gE+kLuAThYnoidQF+suIpC7QASipC/hE6gI+kbpAT5TVBXwidYF+6M7qAj6RuoBPFCaiJ1IX8InUBXwidQGfSF3AJ1IX6ImKukB/GVHUBToAFXUBn0hdwCcKE9ETqQv4ROoC/tCtLuATqQv4ROoCPVGoC/hE6gI+kbqAT6Qu4BOFieiJ1AX6y4hQF+gAFOoCPpG6gE+kLtAT7eoCPpG6QD907+oCPpG6gE8UJqInUhfwidQFfCJ1AZ9IXcAnUhfoiaq6QH8ZUdUFOgBVdQGfSF3AJwoT0ROpC/hE6gL+0K0u4BOpC/hE6gI9UVMX8InUBXwidQGfSF3AJwoT0ROpC/SXEU1doANQUxfwidQFfCJ1gZ7oUBfwidQF+qH7UBfwidQFfKIwET2RuoBPpC7gE6kL+ETqAj6RukBP1NUF+suIri7QAairC/hE6gI+UZiInkhdwCdSF/CHbnUBn0hdwCdSF+CJ+qYu4BOpC/hE6gI+kbqATxQmoidSF+AvI/qmLsABqG/qAj6RuoBPpC7QEyV1AZ9IXaAfupO6gE+kLuAThYnoidQFfCJ1AZ9IXcAnUhfwidQFeqKsLtBfRmR1gQ5AWV3AJ1IX8InCRPRE6gI+kbqAP3SrC/hE6gI+kbpAT1TUBXwidQGfSF3AJ1IX8InCRPRE6gL9ZURRF+gAVNQFfCJ1AZ9IXaAnCnUBn0hdoB+6Q13AJ1IX8InCRPRE6gI+kbqAT6Qu4BOpC/hE6gI90a4u0F9G7OoCHYB2dQGfSF3AJwoT0ROpC/hE6gL+0K0u4BOpC/hE6gI9UVUX8InUBXwidQGfSF3AJwoT0ROpC/SXEVVdoANQVRfwidQFfCJ1gZ6oqQv4ROoC/dDd1AV8InUBnyhMRE+kLuATqQv4ROoCPpG6gE+kLtATHeoC/WXEoS7QAehQF/CJ1AV8ojARPZG6gE+kLuAP3eoCPpG6gE+kLtATdXUBn0hdwCdSF/CJ1AV8ojARPZG6QH8Z0dUFOgB1dQGfSF3AJ1IX2InS9vY/G+Eb6QvsY/f/GgkM/EYKA79R2AjfSGPgNxIZ+I1UBn4jmYHfSGfAN0o6A/u9xP8a6Qx4C0o6A7+RzsBvFDbCN9IZ+I10Bv7ZW2fgN9IZ+I10BnyjrDPwG+kM/EY6A7+RzsBvFDbCN9IZ8O8mss6At6CsM/Ab6Qz8RjoDvlHRGfiNdAb82bvoDPxGOgO/UdgI30hn4DfSGfiNdAZ+I52B30hnwDcKnQH/biJ0BrwFhc7Ab6Qz8BuFjfCNdAZ+I52Bf/bWGfiNdAZ+I50B32jXGfiNdAZ+I52B30hn4DcKG+Eb6Qz4dxO7zoC3oF1n4DfSGfiNdAZ8o6oz8BvpDPizd9UZ8GfvqjPwP+vCRvhGOgO/kc7Ab6Qz8BvpDPyzt86AP3s3nQH/Wdd0Bn4jnYHfSGfgNwob4RvpDPizd9MZ+I10Bn4jnYHfSGd4eaM4n377x/Zro0Nn4DfSGZ5qVLbb07m0PLRR7Vv6eLr29FOjO192jts3eeSa7wQVJRYLqmAsFjQMulZQbWSxoELKYkFVl8WCSjSLBdVz1graxZ/FgipFiwVVihYLqhQtFjQMulZQpWixoErRYkGVosWCKkWLBVWKlgr6ltSgawVVihYLqhQtFlQpWixoGHStoErRYkGVosWCKkWLBVWKFguqFK0VNClFiwVVihYLqhQtFlQpWixoGHStoErRYkGVolcHffTrsN7+CBvhG+k5/EYSzesb/f5XLaWsuvAbCSn8RtoIv5HcwW8UNsI3EiX4jXQG/P0o6wz8RjoDv5HOgG9UdAZ+I50Bf64rOgO/kc7AbxQ2wjfSGfiNdAZ+I52B30hneHmjB//XuqnoDPg7bOgM/EY6A7+RzsBvpDPwG4WN6Gfv0Bn4jXQGfiOdgd9IZ+A30hnwjXadgd9IZ+A30hn4jXQG/LuJPWxEt6BdZ+A30hn4jXQGfiOdgd9IZ8CfvavOwG+kM/Ab6Qz8RjoDv1HYCN9IZ+A30hn4jXQGfiOdAf9uouoMeAtqOgO/kc7Ab6Qz8BvpDPxGYSP62bvpDPxGOgO/kc7Ab6Qz8BvpDPhGh87Ab6Qz8BvpDPxGOgP+3cQRNqJb0KEz8BvpDPxGOgO/kc7Ab6Qz4M/eXWfgN9IZ+I10Bn4jnYHfKGyEb6Qz8BvpDPxGOgO/kc6AfzfRdQa6BeVNZ+A30hn4jXQGfiOdgd8obAQ/e+dNZ+A30hn4jXQGfiOdgd9IZ8A3SjoDv5HOwG+kM/Ab6Qz0dxM5hY3oFpR0Bn4jnYHfSGfgN9IZ+I10BvzZO+sM/EY6A7+RzsBvpDPwG4WN8I10Bn4jnYHfSGfgN9IZ8O8mss6At6CiM/Ab6Qz8RjoDv5HOwG8UNqKfvYvOwG+kM/Ab6Qz8RjoDv5HOgG8UOgO/kc7Ab6Qz8BvpDPh3ExE2oltQ6Az8RjoDv5HOwG+kM/Ab6Qz4s/euM/Ab6Qz8RjoDv5HOwG8UNsI30hn4jXQGfiOdgd9IZ8C/m9h1BrwFVZ2B30hn4DfSGfiNdAZ+o7AR/exddQZ+I52B30hn4DfSGfiNdAZ8o6Yz8BvpDPxGOgO/kc6AfzfRwkZ0C2o6A7+RzsBvpDPwG+kM/EY6A/7sfegM/EY6A7+RzsBvpDPwG4WN8I10Bn4jnYHfSGfgN9IZ8O8mDp0Bb0FdZ+A30hn4jXQGfiOdgd8obEQ/e3edgd9IZ+A30hn4jXQGfiOdgd6obDoDv5HOwG+kM/Ab6Qz0dxNlCxvBLahsOgO/kc7Ab6Qz8BvpDPxGOgP+7J10Bn4jnYHfSGfgN9IZ+I3CRvhGOgO/kc7Ab6Qz8BvpDPh3E0lnwFtQ1hn4jXQGfiOdgd9IZ+A3ChvRz95ZZ+A30hn4jXQGfiOdgd9IZ8A3KjoDv5HOwG+kM/Ab6Qz4dxMlbES3oKIz8BvpDPxGOgO/kc7Ab6Qz4M/eoTPwG+kM/EY6A7+RzsBvFDbCN9IZ+I10Bn4jnYHfSGfAv5sInQFvQbvOwG+kM/Ab6Qz8RjoDv1HYiH723nUGfiOdgd9IZ+A30hn4jXQGfKOqM/Ab6Qz8RjoDv5HOgH83UcNGdAuqOgO/kc7Ab6Qz8BvpDPxGOgP+7N10Bn4jnYHfSGfgN9IZ+I3CRvhGOgO/kc7Ab6Qz8BvpDPh3E01nwFvQoTPwG+kM/EY6A7+RzsBvFDain70PnYHfSGfgN9IZ+I10Bn4jnQHfqOsM/EY6A7+RzsBvpDPg3030sBHdgrrOwG+kM/Ab6Qz8RjoDv5HOQD97x6Yz8BvpDPxGOgO/kc7AbxQ2wjfSGfiNdAZ+I52B30hnoL+biE1noFtQJJ2B30hn4DfSGfiNdAZ+o7AR/eyddAZ+I52B30hn4DfSGfiNdAZ8o6wz8BvpDPxGOgO/kc6AfzeRw0Z0C8o6A7+RzsBvpDPwG+kM/EY6A/7sXXQGfiOdgd9IZ+A30hn4jcJG+EY6A7+RzsBvpDPwG+kM+HcTRWfAW1DoDPxGOgO/kc7Ab6Qz8BuFjehn79AZ+I10Bn4jnYHfSGfgN9IZ8I12nYHfSGfgN9IZ+I10Bvy7iT1sRLegXWfgN9IZ+I10Bn4jnYHfSGfAn72rzsBvpDPwG+kM/EY6A79R2AjfSGfgN9IZ+I10Bn4jnQH/bqLqDHgLajoDv5HOwG+kM/Ab6Qz8RmEj+tm76Qz8RjoDv5HOwG+kM/Ab6Qz4RofOwG+kM/Ab6Qz8RjoD/t3EETaiW9ChM/Ab6Qz8RjoDv5HOwG+kM+DP3l1n4DfSGfiNdAZ+I52B3yhshG+kM/Ab6Qz8RjoDv5HOgH830XUGugXtm87Ab6Qz8BvpDPxGOgO/UdgIfvbeN52B30hn4DfSGfiNdAZ+I50B3yjpDPxGOgO/kc7Ab6Qz0N9N7ClsRLegpDPwG+kM/EY6A7+RzsBvpDPgz95ZZ+A30hn4jXQGfiOdgd8obIRvpDPwG+kM/EY6A7+RzoB/N5F1BrwFFZ2B30hn4DfSGfiNdAZ+o7AR/exddAZ+I52B30hn4DfSGfiNdAZ8o9AZ+I10Bn4jnYHfSGfAv5uIsBHdgkJn4DfSGfiNdAZ+I52B30hnwJ+9d50Bf/bedQb8Z92uM/Ab6Qz8RmEjfCOdgd9IZ+CfvXUG/tlbZ+B/1ukM+EZVZ+A30hn4jXQGfiOdAX/2rmEjfCOdgd9IZ+A30hle3ijOp9/+sd1ppDPwG+kMzzXq6fY9xtZ/evrHIJsYMGiQ3tgHDdJr9aBBevcdNMhwkGMG6S3yqUG+fbHnIMvx4OlejttX0mP76az068OlHLcLSin9y8Pt3sNbbmeYUr4+/NHTG+daPb2drtXTm+xaPb31/lM90377Okpq/deeh5fvtXpqAGv1lCL+rZ797JlT+f3DuebztlrLg4dTL+nurM9N0VrclPeHt+0WJm/5wcNvRHebdO9fv72PpQqXyqUavVQanEs1fKmEQJfqx1JFPZeq9j9bKjXSpRq+VJKoS/X+8OflP6cj7lzpxFY35alN6TKum/LcpgjEbsqPiueXkUs+fv9wKueZJpWe7qyVTu1a/YW1ErVdq++v1Z5uD6c98h/d1nq4gW7gSzdQLncDX7uB2rob+B82sJ4/sbD/fBX9/gYK8W7gazdQtV94A/d2buCjtzsPfxCrq/ZuyvvD4368oW4Cv0s1fKl8F+BS/ViqYT/eUDffBLhUw5fK9wAu1fvDD95v1y3cFDflqU3R1d2U5zZF/3ZTvq+PD364oW6itmv1F9ZKqXatvr9W494X100BdwNfuoFJLncDX7uB2rob+B82cNhPLNQkxLuBr91A1X7dDWzl9vvxc6t/emdN4aa4KU9timrvpgw/rAv8LtXwpZL3XarhSyXuu1TD72l6vUs1eqmyBP9PLVVucS7V8UiURv7m4rc/y01xU/738MC/25DVb5dq+FIJ2i7V8KUKl8qlel+qcX9hJsvkLtXwpZLJXar3hx/9jYmsfbspz22KoO2mPLcpKrWb8qPiyL8uU3Rq1+ovrJWo7Vp9f60G/qhAUcDdwNduoFzuBr52A8MNdAO/v4HjfgymCPFu4Gs3ULVfeAMH/ubiWlR7N+X94YE/3lAEfpdq+FL5LsCl+rFU4368IXwT4FINXyrfA7hU7w8/er8der2b8tym6OpuynObEm6Km/JtfXz0ww0hartWf2GtlGrX6vtrNfB9cSjgbuBrN1AudwNfu4Hauhv4HzZw3E8s7EK8G/jaDVTt193Aob+Pdlft3ZTnNkW1d1NGH9b3cKlcqtFLJe+7VMOXStx3qYbf0/R6l2r4UknwTy1V3U6cqSn/9PTHIJXkMYOslwXRvdz+7KNu6cHT+3b+ex3b57Ml7s3jSOdH4tsffT5d+r3v8cjHl6Dt4dPp9sl15P0z6Nsfcufp1uP2dOu9PHi6fJYpnx9zebv3LZZUPvW0/v7hVMonX3z9mu8+vMXtq0jbl8/xt4c/FvayfurC/sHCtnOtctsfPJzaZ8Uj1T9d2Msyrgv7by7sZTX5ry1s2c5zWNm+fNX3VzCl/TzkpVSP5Mo+WtlwZZ9Z2Xr+0f14sLLxOY+3b/HLtbek29Ava7mvHPplrfOVQ7+sBX5r6Md2/meolUdHuJJPgotID/4r5H/h6mXl8Fsr2M9fm9T3/cEK7ttJxnvayr1/7y+rjC8celMkn/qwPU5U27b66NM21fPTNpfmp+2DT9smMk7dwY+pX1bK6ue/cHXfHn3ctnbTr976559d892px37+xpEUx0+Pf4z9st7z2rGHY3/F2C+rFq8d+2Xd4rVjv6xcvHbsl72tf2/sx/lapB9ffgj07tjrsd++kHq0z6Npvc38spf11838uOxd/YUzv+zd9IUz92Y6f+ZeS+fPPJz59Jl7IR0/836+iqw9t19n7m10/sy9is6fuffQ+TP3Hjp95t176PyZew+dP3PvofNn7j10/szDmU+fuffQ+TP3Hjp/5t5D58/ce+j8mXsPnT3ztnkPnT9z76HzZ+49dP7MvYfOn3k48+kz9x46f+beQ+fP3Hvo/Jl7D50/c++h02eevIfOn7n30Pkz9x46f+beQ+fPPJz59Jl7D50/c++h82fuPXT+zL2Hzp+599DpM8/eQ+fP3Hvo/Jl7D50/c++h82ceznz6zL2Hzp+599D5M/ceOn/m3kPnz9x76PSZF++hf2Hmcf5ei77fmbn30Pkz9x46f+beQ+fPPJz59Jl7D50/c++h82fuPXT+zL2Hzp+599DpMw/vofNn7j10/sy9h86fuffQ+TMPZz595t5D58/ce+j8mXsPnT9z76HzZ+49dPrMd++h82fuPXT+zL2Hzp+599D5Mw9nPn3m3kPnz9x76PyZew+dP3PvofNn7j10+syr99D5M/ceOn/m3kPnz9x76PyZhzOfPnPvofNnft17aM+3mbftePD0o7+WVa97tRw6xuveFoeO8boXwJFjbNe90w0d43WvaUPHeN2b19AxXvcyNXSM4RhHjPG6V56hY/QWM2SM3mKGjNFbzJAxeosZMcbDW8yQMXqLGTJGbzFDxugtZsgYwzGOGKO3mCFj9BYzZIzeYp4b4+/fDB7eYoaM0VvMiDF2bzFDxugtZsgYvcUMGaO3mCFjDMc4YozeYoaM0VvMkDF6ixkyRm8xQ8boLWbAGI/NW8yQMXqLGTJGbzFDxnjZW8xWb9/ikXL89PTHaOKqoyn7uWGRHj2d83ac32N7tI8p5Zt/p9TSw+3d0rm96XN7090vO5+rfuSavz78EfSyd6RVg172trZq0MveG1cNetkb7KpBL3uXXjRouuytftWgl/WFVYNeVjpWDXpZc1k1aBh0raBK0WJBlaLFgipFiwVVihYLqhStFTQrRYsFVYoWC6oULRZUKVosaBh0raBK0WJBlaLFgipFiwVVihYLqhStFbQoRYsFVYoWC6oULRZUKVosaBh0raBK0WJBlaLFgipFiwVVihYLqhStFTSUosWCKkWLBVWKFguqFC0WNAy6VlClaLGgStFiQZWixYIqRYsFVYpeHbTluP3ZLdf4tdEu/vAb6Tn8RhLN6xv1fmtU0r1Gqgu/UdgI30gb4TeSO/iNFAx+I1GC30hnwN+Pqs7Ab6Qz8BvpDPxGOgO/UdiIfq6rOgO/kc7Ab6Qz8BvpDPxGOgO+UdMZ+I10hpc3Sv329Ns/1juNdAb8HbbpDPxGYSN8I52B30hn4DfSGfhnb52B30hnwDc6dAZ+I52B30hn4DfSGfiNwkb4RjoDv5HOgH83cegMeAs6dAZ+I50B36jrDPxGOgO/kc6AP3t3nYHfKGyEb6Qz8BvpDPxGOgO/kc7Ab6Qz0Bv1TWfgN9IZ6O8m+qYz0C2obzoDv1HYCN9IZ+A30hn4jXQG/tlbZ+A30hnwjZLOwG+kM/Ab6Qz8RjoDv1HYCN9IZ+A30hnw7yaSzoC3oKQz8BvpDPhGWWfgN9IZ+I10BvzZO+sM/EZhI3wjnYHfSGfgN9IZ+I10Bn4jnQHfqOgM/EY6A/7dRNEZ8BZUdAZ+o7ARvpHOwG+kM/Ab6Qz8s7fOwG+kM+Abhc7Ab6Qz8BvpDPxGOgO/UdgI30hn4DfSGfDvJkJnwFtQ6Az8RjoDvtGuM/Ab6Qz8RjoD/uy96wz8RmEjfCOdgd9IZ+A30hn4jXQGfiOdAd+o6gz8RjoD/t1E1RnwFlR1Bn6jsBG+kc7Ab6Qz8BvpDPyzt87Ab6Qz4Bs1nYHfSGfgN9IZ+I10Bn6jsBG+kc7Ab6Qz4N9NNJ0Bb0FNZ+A30hnwjQ6dgd9IZ+A30hnwZ+9DZ+A3ChvhG+kM/EY6A7+RzsBvpDPwG+kM+EZdZ+A30hnw7ya6zoC3oK4z8BuFjfCNdAZ+I52B30hn4J+9dQZ+I50B3ihtm87Ab6Qz8BvpDPxGOgO/UdgI30hn4DfSGeDvJt4a6QxwC3prpDPwG+kM+EZJZ+A30hn4jXQG/Nk76Qz8RmEjfCOdgd9IZ+A30hn4jXQGfiOdAd8o6wz8RjoD/t1E1hnwFpR1Bn6jsBG+kc7Ab6Qz8BvpDPyzt87Ab6Qz4BsVnYHfSGfgN9IZ+I10Bn6jsBG+kc7Ab6Qz4N9NFJ0Bb0FFZ+A30hnwjUJn4DfSGfiNdAb82Tt0Bn6jsBG+kc7Ab6Qz8BvpDPxGOgO/kc6Ab7TrDPxGOgP+3cSuM+AtaNcZ+I3CRvhGOgO/kc7Ab6Qz8M/eOgO/kc6Ab1R1Bn4jnYHfSGfgN9IZ+I3CRvhGOgO/kc6AfzdRdQa8BVWdgd9IZ8A3ajoDv5HOwG+kM+DP3k1n4DcKG+Eb6Qz8RjoDv5HOwG+kM/Ab6Qz4RofOwG+kM+DfTRw6A96CDp2B3yhshG+kM/Ab6Qz8RjoD/+ytM/Ab6Qz4Rl1n4DfSGfiNdAZ+I52B3yhshG+kM/Ab6Qz4dxNdZ8BbUNcZ+I10BnqjtOkM/EY6A7+RzkA/e6dNZ+A3ChvhG+kM/EY6A7+RzsBvpDPwG+kM+EZJZ+A30hno7ybe/jQb0S0o6Qz8RmEjfCOdgd9IZ+A30hn4Z2+dgd9IZ8A3yjoDv5HOwG+kM/Ab6Qz8RmEjfCOdgd9IZ8C/m8g6A96Css7Ab6Qz4BsVnYHfSGfgN9IZ8GfvojPwG4WN8I10Bn4jnYHfSGfgN9IZ+I10Bnyj0Bn4jXQG/LuJ0BnwFhQ6A79R2AjfSGfgN9IZ+I10Bv7ZW2fgN9IZ8I12nYHfSGfgN9IZ+I10Bn6jsBG+kc7Ab6Qz4N9N7DoD3oJ2nYHfSGfAN6o6A7+RzsBvpDPgz95VZ+A3ChvhG+kM/EY6A7+RzsBvpDPwG+kM+EZNZ+A30hnw7yaazoC3oKYz8BuFjfCNdAZ+I52B30hn4J+9dQZ+I50B3+jQGfiNdAZ+I52B30hn4DcKG+Eb6Qz8RjoD/t3EoTPgLejQGfiNdAZ8o64z8BvpDPxGOgP+7N11Bn6jsBG+kc7Ab6Qz8BvpDPxGOgO/kc5Ab5Q3nYHfSGegv5vIm85At6C86Qz8RmEjfCOdgd9IZ+A30hn4Z2+dgd9IZ8A3SjoDv5HOwG+kM/Ab6Qz8RmEjfCOdgd9IZ8C/m0g6A96Cks7Ab6Qz4BtlnYHfSGfgN9IZ8GfvrDPwG4WN8I10Bn4jnYHfSGfgN9IZ+I10BnyjojPwG+kM+HcTRWfAW1DRGfiNwkb4RjoDv5HOwG+kM/DP3joDv5HOgG8UOgO/kc7Ab6Qz8BvpDPxGYSN8I52B30hnwL+bCJ0Bb0GhM/Ab6Qz4RrvOwG+kM/Ab6Qz4s/euM/AbhY3wjXQGfiOdgd9IZ+A30hn4jXQGfKOqM/Ab6Qz4dxNVZ8BbUNUZ+I3CRvhGOgO/kc7Ab6Qz8M/eOgO/kc6Ab9R0Bn4jnYHfSGfgN9IZ+I3CRvhGOgO/kc6AfzfRdAa8BTWdgd9IZ8A3OnQGfiOdgd9IZ8CfvQ+dAX/2PsJG+M86nYHfSGfgN9IZ+I10Bn4jnQF/9u46A/7s3XUG/Gdd1xn4jXQGfqOwEb6RzsBvpDPwz946A7+RzsBvpDPQG5VNZ3h5oziffvvHdqeRzsBvpDM81ehtULfvsbQ8tFHtW/p4uvb0U6M7X3aO2zd55JrvBBUlFgsaBl0rqNyxWFBtZLGgQspiQVWXxYJKNGsFTXrOYkHFn8WCKkWLBVWKFgsaBl0rqFK0WFClaLGgStFiQZWixYIqRWsFzUrRYkGVosWCKkWLBVWKFgsaBl0rqFK0WFClaLGgStFiQZWixYIqRWsFLUrRYkGVosWCKkWLBVWKFgsaBl0rqFK0WFClaLGgStGrgz76dViliD/8RnoOvlFINK9v9OBXLYXqwm8kpPAbaSP8RmEjfCMFg99IlOA30hn49yOdgd9IZ8A32nUGfiOdgd9IZ8Cf63adgd8obIRvpDPwG+kM/EY6A7+RzsBvpDO8vNGD/2vdUnUG/B226gz8RjoDv5HOwG8UNsI30hnwZ++qM/Ab6Qz8RjoDv5HOgG/UdAZ+I52B30hn4DfSGfiNwkb0dxNNZ8BbUNMZ+I10Bn4jnYHfSGfANzp0BvzZ+9AZ+I10Bn4jnYHfKGyEb6Qz8BvpDPxGOgO/kc7Ab6Qz4N9NdJ0Bb0FdZ+A30hn4jXQGfqOwEb6RzoA/e3edgd9IZ+A30hn4jXQGeqPYdAZ+I52B30hn4DfSGfiNwkbwdxOx6Qx0C4pNZ+A30hn4jXQGfiOdAd8o6Qz4s3fSGfiNdAZ+I52B3yhshG+kM/Ab6Qz8RjoDv5HOwG+kM+DfTWSdAW9BWWfgN9IZ+I10Bn6jsBG+kc6AP3tnnYHfSGfgN9IZ+I10BnyjojPwG+kM/EY6A7+RzsBvFDaiv5soOgPegorOwG+kM/Ab6Qz8RjoDvlHoDPizd+gM/EY6A7+RzsBvFDbCN9IZ+I10Bn4jnYHfSGfgN9IZ8O8mdp0Bb0G7zsBvpDPwG+kM/EZhI3wjnQF/9t51Bn4jnYHfSGfgN9IZ8I2qzsBvpDPwG+kM/EY6A79R2Ij+bqLqDHgLqjoDv5HOwG+kM/Ab6Qz4Rk1nwJ+9m87Ab6Qz8BvpDPxGYSN8I52B30hn4DfSGfiNdAZ+I50B/27i0BnwFnToDPxGOgO/kc7AbxQ2wjfSGfBn70Nn4DfSGfiNdAZ+I50B36jrDPxGOgO/kc7Ab6Qz8BuFjejvJrrOgLegrjPwG+kM/EY6A7+RzkBvtG86A/3svW86A7+RzsBvpDPwG4WN8I10Bn4jnYHfSGfgN9IZ+I10Bvq7iT3pDHgLSjoDv5HOwG+kM/AbhY3wjXQG/Nk76Qz8RjoDv5HOwG+kM+AbZZ2B30hn4DfSGfiNdAZ+o7AR/d1E1hnwFpR1Bn4jnYHfSGfgN9IZ8I2KzoA/exedgd9IZ+A30hn4jcJG+EY6A7+RzsBvpDPwG+kM/EY6A/7dROgMeAsKnYHfSGfgN9IZ+I3CRvhGOgP+7B06A7+RzsBvpDPwG+kM+Ea7zsBvpDPwG+kM/EY6A79R2Ij+bmLXGfAWtOsM/EY6A7+RzsBvpDPgG1WdAX/2rjoDv5HOwG+kM/AbhY3wjXQGfiOdgd9IZ+A30hn4jXQG/LuJpjPgLajpDPxGOgO/kc7AbxQ2wjfSGfBn76Yz8BvpDPxGOgO/kc6Ab3ToDPxGOgO/kc7Ab6Qz8BuFjejvJg6dAW9Bh87Ab6Qz8BvpDPxGOgO+UdcZ8GfvrjPwG+kM/EY6A79R2AjfSGfgN9IZ+I10Bn4jnYHfSGegv5uom85At6C66Qz8RjoDv5HOwG8UNsI30hnoZ++66Qz8RjoDv5HOwG+kM+AbJZ2B30hn4DfSGfiNdAZ+o7AR/d1E0hnwFpR0Bn4jnYHfSGfgN9IZ8I2yzoA/e2edgd9IZ+A30hn4jcJG+EY6A7+RzsBvpDPwG+kM/EY6A/7dRNEZ8BZUdAZ+I52B30hn4DcKG+Eb6Qz4s3fRGfiNdAZ+I52B30hnwDcKnYHfSGfgN9IZ+I10Bn6jsBH93UToDHgLCp2B30hn4DfSGfiNdAZ8o11nwJ+9d52B30hn4DfSGfiNwkb4RjoDv5HOwG+kM/Ab6Qz8RjoD/t1E1RnwFlR1Bn4jnYHfSGfgNwob4RvpDPizd9UZ+I10Bn4jnYHfSGfAN2o6A7+RzsBvpDPwG+kM/EZhI/q7iaYz4C2o6Qz8RjoDv5HOwG+kM+AbHToD/ux96Az8RjoDv5HOwG8UNsI30hn4jXQGfiOdgd9IZ+A30hnw7ya6zoC3oK4z8BvpDPxGOgO/UdgI30hnwJ+9u87Ab6Qz8BvpDPxGOgO9Udt0Bn4jnYHfSGfgN9IZ+I3CRvB3E23TGegW1Dadgd9IZ+A30hn4jXQGfKOkM+DP3kln4DfSGfiNdAZ+o7ARvpHOwG+kM/Ab6Qz8RjoDv5HOgH83kXUGvAVlnYHfSGfgN9IZ+I3CRvhGOgP+7J11Bn4jnYHfSGfgN9IZ8I2KzsBvpDPwG+kM/EY6A79R2Ij+bqLoDHgLKjoDv5HOwG+kM/Ab6Qz4RqEz4M/eoTPwG+kM/EY6A79R2AjfSGfgN9IZ+I10Bn4jnYHfSGfAv5vYdQa8Be06A7+RzsBvpDPwG4WN8I10BvzZe9cZ+I10Bn4jnYHfSGfAN6o6A7+RzsBvpDPwG+kM/EZhI/q7iaoz4C2o6gz8RjoDv5HOwG+kM+AbNZ0Bf/ZuOgP+7N10Bv5nnc7AbxQ2wjfSGfiNdAZ+I52Bf/bWGfhnb50B/1l36Az8RjoDv5HOwG+kM/AbhY3oZ+9DZ+A30hn4jXQGfiOd4eWN4nz67R/bnUY6A75R1xmea9TT7XuMrf/09McgxYBBg/TGPmiQXqsHDTIc5JhBekEdNEhvkU8N8u2LPQdZjgdP93LcvpIe209npV8fLuW4XVBK6V8ebvce3nI7w5Ty9eGPnt441+rp7XStnt5kV+p5bN56/6meab99HeXtX8Y7Pb18r9VTA1irpxTxb/XsZ8+cyu8fzjWft9VaHjycekl3Z31uSrgpbsr/Ht62W5i85QcP7+1WfO/967f3sVS6k0s1fKk0OJdq+FIJgS7Vj6WKei5V7X+2VGqkSzV8qSRRl+r94c/Lf05H/HqlS2Krm/Lcpsi4bspzmyIQuyk/Kp5fRi75+P3DqZxnmlR6urNWOrVr9RfWKlwr1+rba7Wn28Npj/xHt7WkgLuBr91AudwNfO0Gautu4H/YwHr+xML+81X0+xsoxLuBr91A1X7hDdzbuYGP3u48/EGsrNq7Ke8PD/zxhizwu1TDl8p3AS7Vj6Ua9+MN2TcBLtXwpQqXyqX6vyfeb2e93k15blN0dTfluU3Rv92U7+vjox9uyKK2a/UX1kqpdq2+v1YD3xcXBdwNfO0GyuVu4Gs3UFt3A//DBo77iYUixLuBr93AcAOX3cBWbr8fP7f6p3fWotq7Kc9timrvpgw/rAv8LtXwpZL3XarhSyXuu1Sj72mh17tUw5dKgv+nliq3OJfqeCRKQ39zcUjlbsr7wwP/bkOo3y7V8KUKl8qlGr1U2rdL9WOpxv2FmZDJXarhSyWTu1TvDz/6GxOhfbspz22KoO2mPLUpu0rtpvyoOPKvy+w6tWv1F9ZK1Hatvr9WA39UYFfA3cDXbmC4gW7gSzdQW3cD/8MGjvsxmF2IdwNfu4Gq/cIbOPI3F++qvZvy/vDAH2/YBX6XavRSVd8FuFQ/lmrcjzdU3wS4VMOXyvcALtX7w4/eb1e93k15blPCTXFTntoU/dtN+b4+Pvrhhipqu1Z/Ya2Uatfq+2s18H1xVcDdwNduoFzuBr50A5u27gb+hw0c9xMLTYh3A1+7gar9uhs49PfRNtXeTXluU8JNcVNGH9YFfpdq+FLJ+y7V8KUS912q4fc0vd6lGr5UEvxTS1W3E2dqyj89/WOQh5I8aJCXBdG93P7so27pwdP7dv57HdvnsyXuzeNI50fi2x99Pl36ve/xyMeXoO3h0+n2yXXk/TPo2x9y5+nW4/Z06708eLp8limfH3N5u/ctllQ+9bT+/uFUyidffP2a7z68xe2rSNuXz/G3hz8W9rJ+6sL+wcK2c61y2x88nNpnxSPVP13YyzKuC/tvLmy4sIMXtmznOaxsX77q+yuY0n4e8lKqR3JlH63sZa36eytbzz+6Hw9WNj7n8fYtfrn2lnQb+mUt95VDv6x1vnLol7XAbw392M7/DLXy6AhX8klwEenBf4X8L9xxWTn81gr289cm9X1/sIL7dpLxnrZy59/7flllfOXQFcmnPmyPE9W2rT76tE31/LTNpflp++DTtouMU3fwY+qXlbL6+S9c3bdHH7et3fSrt/75Z9d8d+qxn79xJMXx0+MfYw/H/oqxX9YsXjv2y6rFa8d+Wbd47dgvKxevHftlb+vfG/txvhbpx5cfAr079nrsty+kHu3zaFp/zLxvl72sv3Dml72rv3Dml72bvnDm3kznzzyc+fSZeyedP3MvpONn3s9XkbXn9uvMvY3On7lX0fkz9x46febJe+j8mXsPnT9z76HzZ+49dP7Mw5lPn7n30Pkz9x46f+beQ+fP3Hvo/Jl7D50+8+w9dP7MvYfOn7n30Pkz9x46f+bhzKfP3Hvo/Jl7D50/c++h82fuPXT+zL2HTp958R46f+beQ+fP3Hvo/Jl7D50/83Dm02fuPXT+zL2Hzp+599D5M/ceOn/m3kOnzzy8h86fuffQ+TP3Hjp/5t5D5888nPn0mXsPnT9z76HzZ+49dP7MvYfOn7n30Okz372Hzp+599C/MPM4f69F3+/M3Hvo/Jl7D50/83Dm02fuPXT+zL2Hzp+599D5M/ceOn/m3kOnz7x6D50/c++h82fuPXT+zL2Hzp95OPPpM/ceOn/m3kPnz9x76PyZew+dP3PvodNn3ryHzp+599D5M/ceOn/m3kPnzzyc+fSZew+dP3PvofNn7j10/sy9h86fuffQ6TM/vIfOn7n30Pkz9x46f+beQ+fPPJz59Jl7D50/c++h82d+3Xtoz7eZt+148PSjv5Z1XPdqOXSM170tjhxjv+4FcOgYr3unGzrG617Tho7xujevoWMMxzhijNe9Hw0d43WvPEPH6C1myBi9xQwZo7eYPx9j3jZvMUPG6C1myBi9xQwZo7eYIWMMxzhijN5ihozRW8yQMXqLGTJGbzHPjfF3bwbfxugtZsQYk7eYIWP0FjNkjN5ihozRW8yQMYZjHDFGbzFDxugtZsgYvcUMGaO3mCFj9BYzYozZW8yQMXqLGTJGbzFDxugtZsgY46pj3OrtWzxSjp+e/hjNZW8mZT83LNKjp3PejvN7bI/2MaV88++UWnq4vVs6tzd9bm+6+2Xnc9WPXPPXhz+CXvaOtGrQy97WVg162XvjqkEve4NdNGi57F161aCXvdWvGvSyvrBq0MtKx6pBw6BrBVWKFguqFC0WVClaLKhStFhQpWitoKEULRZUKVosqFK0WFClaLGgYdC1gipFiwVVihYLqhQtFlQpWiyoUrRW0F0pWiyoUrRYUKVosaBK0WJBw6BrBVWKFguqFC0WVClaLKhStFhQpWitoFUpWiyoUrRYUKVosaBK0WJBw6BrBVWKFguqFC0WVClaLKhStFhQpWitoE0penXQluP2Z7dc404j8YffSM/hN5JoXt+o91ujku41ChvhGwkp/EbaCL+R3MFvpGDwG4kS+EaHzoC/Hx06A7+RzsBvpDPwG4WN8I10Bv65TmfgN9IZ+I10Bn4jnQHfqOsM/EY6A7+RzvDyRqnfnn77x3qnkc6Av8P2sBG+kc7Ab6Qz8BvpDPxGOgP/7K0z0BulTWfgN9IZ+I10Bn4jnYHfKGyEb6Qz8BvpDPxGOgP93UTadAa6BaVNZ8A3SjoDv5HOwG+kM/Ab6Qz4s3cKG+Eb6Qz8RjoDv5HOwG+kM/Ab6Qz4Rlln4DfSGfiNdAb8u4msM+AtKIeN8I10Bn4jnYHfSGfgN9IZ+GdvnQHfqOgM/EY6A7+RzsBvpDPwG4WN8I10Bn4jnYHfSGfAv5soOgPegorOgG8UOgO/kc7Ab6Qz8BvpDPizd4SN8I10Bn4jnYHfSGfgN9IZ+I10BnyjXWfgN9IZ+I10Bvy7iV1nwFvQHjbCN9IZ+I10Bn4jnYHfSGfgn711BnyjqjPwG+kM/EY6A7+RzsBvFDbCN9IZ+I10Bn4jnQH/bqLqDHgLqjoDvlHTGfiNdAZ+I52B30hnwJ+9W9gI30hn4DfSGfiNdAZ+I52B30hnwDc6dAZ+I52B30hnwL+bOHQGvAUdYSN8I52B30hn4DfSGfiNdAb+2VtnwDfqOgO/kc7Ab6Qz8BvpDPxGYSN8I52B30hn4DfSGfDvJrrOgLegrjPQG+VNZ+A30hn4jXQGfiOdgX72zlvYCN9IZ+A30hn4jXQGfiOdgd9IZ8A3SjoDv5HOwG+kM9DfTeSkM+AtKIWN8I10Bn4jnYHfSGfgN9IZ+GdvnQHfKOsM/EY6A7+RzsBvpDPwG4WN8I10Bn4jnYHfSGfAv5vIOgPegrLOgG9UdAZ+I52B30hn4DfSGfBn7xI2wjfSGfiNdAZ+I52B30hn4DfSGfCNQmfgN9IZ+I10Bvy7idAZ8BYUYSN8I52B30hn4DfSGfiNdAb+2VtnwDfadQZ+I52B30hn4DfSGfiNwkb4RjoDv5HOwG+kM+DfTew6A96Cdp0B36jqDPxGOgO/kc7Ab6Qz4M/eNWyEb6Qz8BvpDPxGOgO/kc7Ab6Qz4Bs1nYHfSGfgN9IZ8O8mms6At6AWNsI30hn4jXQGfiOdgd9IZ+CfvXUGfKNDZ+A30hn4jXQGfiOdgd8obIRvpDPwG+kM/EY6A/7dxKEz4C3o0BnwjbrOwG+kM/Ab6Qz8RjoD/uzdw0b4RjoDv5HOwG+kM/Ab6Qz8RjoDvVHZdAZ+I52B30hnoL+bKJvOQLegsoWN8I10Bn4jnYHfSGfgN9IZ+GdvnQHfKOkM/EY6A7+RzsBvpDPwG4WN8I10Bn4jnYHfSGfAv5tIOgPegpLOgG+UdQZ+I52B30hn4DfSGfBn7xw2wjfSGfiNdAZ+I52B30hn4DfSGfCNis7Ab6Qz8BvpDPh3E0VnwFtQCRvhG+kM/EY6A7+RzsBvpDPwz946A75R6Az8RjoDv5HOwG+kM/AbhY3wjXQGfiOdgd9IZ8C/mwidAW9BoTPgG+06A7+RzsBvpDPwG+kM+LP3HjbCN9IZ+I10Bn4jnYHfSGfgN9IZ8I2qzsBvpDPwG+kM+HcTVWfAW1ANG+Eb6Qz8RjoDv5HOwG+kM/DP3joDvlHTGfiNdAZ+I52B30hn4DcKG+Eb6Qz8RjoDv5HOgH830XQGvAU1nQHf6NAZ+I10Bn4jnYHfSGfAn72PsBG+kc7Ab6Qz8BvpDPxGOgO/kc6Ab9R1Bn4jnYHfSGfAv5voOgPegnrYCN9IZ+A30hn4jXQGfiOdgX/21hnojWLTGfiNdAZ+I52B30hn4DcKG+Eb6Qz8RjoDv5HOQH83EZvOQLeg2HQGfKOkM/Ab6Qz8RjoDv5HOgD97p7ARvpHOwG+kM/Ab6Qz8RjoDv5HOgG+UdQZ+I52B30hnwL+byDoD3oJy2AjfSGfgN9IZ+I10Bn4jnYF/9tYZ8I2KzsBvpDPwG+kM/EY6A79R2AjfSGfgN9IZ+I10Bvy7iaIz4C2o6Az4RqEz8BvpDPxGOgO/kc6AP3tH2AjfSGfgN9IZ+I10Bn4jnYHfSGfAN9p1Bn4jnYHfSGfAv5vYdQa8Be1hI3wjnYHfSGfgN9IZ+I10Bv7ZW2fAN6o6A7+RzsBvpDPwG+kM/EZhI3wjnYHfSGfgN9IZ8O8mqs6At6CqM+AbNZ2B30hn4DfSGfiNdAb82buFjfCNdAZ+I52B30hn4DfSGfiNdAZ8o0Nn4DfSGfiNdAb8u4lDZ8Bb0BE2wjfSGfiNdAZ+I52B30hn4J+9dQZ8o64z8BvpDPxGOgO/kc7AbxQ2wjfSGfiNdAZ+I50B/26i6wx4C+o6A73RvukM/EY6A7+RzsBvpDPQz977FjaCn733TWfgf9bpDPxGOgO/kc7Ab6Qz4BslnQF/9k46A/7snXQG/medzsBvFDbCN9IZ+I10Bn4jnYF/9tYZ+I10BnyjrDPwG+kML28U59Nv/9juNNIZ+I10hqcale32dC4tD21U+5Y+nq49/dTozped4/ZNHrnmO0HDoGsFVTAWCyp3LBZUG1ksqJCyWFDVZa2gRaJZLKies1hQ8WexoErRYkHDoGsFVYoWC6oULRZUKVosqFK0WFClaK2goRQtFlQpWiyoUrRYUKVosaBh0LWCKkWLBVWKFguqFC0WVClaLKhStFbQXSlaLKhStFhQpWixoErRYkHDoGsFVYoWC6oULRZUKVosqFL06qAPfx3WLv7gG1U9h99Ionl9owe/aqmqLvxGQgq/UdgI30ju4DdSMPiNRAl+I52Bfz/SGfCNms7Ab6Qz8BvpDPxGOgP+XNfCRvhGOgO/kc7Ab6Qz8BvpDPxGOgO+0aEzvLzRo/9r3UNnwN9hD52B30hn4DcKG+Eb6Qz8RjoD/+ytM/Ab6Qz8RjoDvlHXGfiNdAZ+I52B30hn4DcKG+Eb6Qz4dxNdZ8BbUNcZ+I10Bn4jnYHeqG46A7+RzkA/e9dNZ+A30hn4jcJG+EY6A7+RzsBvpDPwG+kM/EY6A75R0hno7yZq0hnwFpR0Bn4jnYHfKGyEb6Qz8BvpDPyzt87Ab6Qz8BvpDPhGWWfgN9IZ+I10Bn4jnYHfKGyEb6Qz4N9NZJ0Bb0FZZ+A30hn4jXQGfKOiM/Ab6Qz4s3fRGfiNdAZ+o7ARvpHOwG+kM/Ab6Qz8RjoDv5HOgG8UOgP+3UToDHgLCp2B30hn4DcKG+Eb6Qz8RjoD/+ytM/Ab6Qz8RjoDvtGuM/Ab6Qz8RjoDv5HOwG8UNsI30hnw7yZ2nQFvQbvOwG+kM/Ab6Qz4RlVn4DfSGfBn76oz8BvpDPxGYSN8I52B30hn4DfSGfiNdAZ+I50B36jpDPh3E01nwFtQ0xn4jXQGfqOwEb6RzsBvpDPwz946A7+RzsBvpDPgGx06A7+RzsBvpDPwG+kM/EZhI3wjnQH/buLQGfAWdOgM/EY6A7+RzoBv1HUGfiOdAX/27joDv5HOwG8UNsI30hn4jXQGfiOdgd9IZ+A30hnojdqmM9DfTbRNZ6BbUNt0Bn4jnYHfKGyEb6Qz8BvpDPyzt87Ab6Qz8BvpDPhGSWfgN9IZ+I10Bn4jnYHfKGyEb6Qz4N9NJJ0Bb0FJZ+A30hn4jXQGfKOsM/Ab6Qz4s3fWGfiNdAZ+o7ARvpHOwG+kM/Ab6Qz8RjoDv5HOgG9UdAb8u4miM+AtqOgM/EY6A79R2AjfSGfgN9IZ+GdvnYHfSGfgN9IZ8I1CZ+A30hn4jXQGfiOdgd8obIRvpDPg302EzoC3oNAZ+I10Bn4jnQHfaNcZ+I10BvzZe9cZ+I10Bn6jsBG+kc7Ab6Qz8BvpDPxGOgO/kc6Ab1R1Bvy7iaoz4C2o6gz8RjoDv1HYCN9IZ+A30hn4Z2+dgd9IZ+A30hnwjZrOwG+kM/Ab6Qz8RjoDv1HYCN9IZ8C/m2g6A96Cms7Ab6Qz8BvpDPhGh87Ab6Qz4M/eh87Ab6Qz8BuFjfCNdAZ+I52B30hn4DfSGfiNdAZ8o64z4N9NdJ0Bb0FdZ+A30hn4jcJG+EY6A7+RzsA/e+sM/EY6A7+RzkBvdGw6A7+RzsBvpDPwG+kM/EZhI3wjnYH+buLYdAa6BR2bzsBvpDPwG+kM+EZJZ+A30hnwZ++kM/Ab6Qz8RmEjfCOdgd9IZ+A30hn4jXQGfiOdAd8o6wz4dxNZZ8BbUNYZ+I10Bn6jsBG+kc7Ab6Qz8M/eOgO/kc7Ab6Qz4BsVnYHfSGfgN9IZ+I10Bn6jsBG+kc6AfzdRdAa8BRWdgd9IZ+A30hnwjUJn4DfSGfBn79AZ+I10Bn6jsBG+kc7Ab6Qz8BvpDPxGOgO/kc6Ab7TrDPh3E7vOgLegXWfgN9IZ+I3CRvhGOgO/kc7AP3vrDPxGOgO/kc6Ab1R1Bn4jnYHfSGfgN9IZ+I3CRvhGOgP+3UTVGfAWVHUGfiOdgd9IZ8A3ajoDv5HOgD97N52B30hn4DcKG+Eb6Qz8RjoDv5HOwG+kM/Ab6Qz4RofOgH83cegMeAs6dAZ+I52B3yhshG+kM/Ab6Qz8s7fOwG+kM/Ab6Qz4Rl1n4DfSGfiNdAZ+I52B3yhshG+kM+DfTXSdAW9BXWfgN9IZ+I10BnqjvukM/EY6A/3s3Tedgd9IZ+A3ChvhG+kM/EY6A7+RzsBvpDPwG+kM+EZJZ6C/m+hJZ8BbUNIZ+I10Bn6jsBG+kc7Ab6Qz8M/eOgO/kc7Ab6Qz4BtlnYHfSGfgN9IZ+I10Bn6jsBG+kc6AfzeRdQa8BWWdgd9IZ+A30hnwjYrOwG+kM+DP3kVn4DfSGfiNwkb4RjoDv5HOwG+kM/Ab6Qz8RjoDvlHoDPh3E6Ez4C0odAZ+I52B3yhshG+kM/Ab6Qz8s7fOwG+kM/Ab6Qz4RrvOwG+kM/Ab6Qz8RjoDv1HYCN9IZ8C/m9h1BrwF7ToDv5HOwG+kM+AbVZ2B30hnwJ+9q87Ab6Qz8BuFjfCNdAZ+I52B30hn4DfSGfiNdAZ8o6Yz4N9NNJ0Bb0FNZ+A30hn4jcJG+EY6A7+RzsA/e+sM/EY6A7+RzoBvdOgM/EY6A7+RzsBvpDPwG4WN8I10Bvy7iUNnwFvQoTPwG+kM/EY6A75R1xn4jXQG/Nm76wz4s3fXGfifdWEjfCOdgd9IZ+A30hn4jXQG/tlbZ4Cfvcu26Qzwz7q3RjoDv5HOwG+kM/AbhY3wjXQG+Nn7rZHOwG+kM/Ab6Qz8RjrDyxvF+fTbP7ZfGyWdgd9IZ3iuUU+37zG2/tPTH4MUAwYN0hv7oEGGgxwzSO++gwbpBXXQIL1FPjXIty/2HGQ5Hjzdy3H7SnpsP52Vfn24lON2QSmlf3m43Xt4y+0MU8rXhz96euNcq6e306V6Zm+ya/X01vtP9Uz77esoqfU7Pb18r9VTA1irZ9jzn+rZz545ld8/nGs+b6u1PHg49ZLuzvrcFK3FTXl/eNtuYfLbfw9+//DebsX33r9+ex9LpTu5VMOXSoNzqYYvlRDoUv1YqqjnUtX+Z0ulRrpUo5eqSKIu1fvDn5f/nI749UpXxFY35blNkXHdlOc2RSB2U35UPL+MXPLx+4dTOc80qfR0Z63CtXKtxq+VqO1afX+t9nR7OO2R/+y2poC7ga/dQLncDXztBmrrbuB/2MB6/sTC/vNV9PsbKMS7gS/dwFDtF97AvZ0b+OjtzsMfxArV3k15f3jgjzeEwO9SDV8q3wW4VD+WatyPN0S4VC7V6KXyPYBL9f7wo/fbode7Kc9tiq7upjy3Kfq3m/J9fXz0ww0hartW49dqV6pdq++v1cD3xbsC7ga+dgPlcjfwtRuorbuB/2EDx/3Ewh5uoBv40g1U7dfdwFZuvx8/t/rHd1bV3k15blNUezdl+GFd4Hephi+VvO9SjV6qKu67VKPvaVWvd6mGL5UE/08tVW5xLtXxSJSG/ubiKpW7Ke8PD/y7DTVcKpdq9FIJ2i7V8KXSvl2qH0s17i/MVJncpRq+VDK5S/X+8KO/MVG1bzflqU1pgrab8tymqNRuyo+KI/+6TNOpXau/sFaitmv1/bUa+KMCLdxAN/ClGyiXu4Gv3UBt3Q38Dxs47sdgmhDvBr52A1X7hTdw5G8ubqq9m/L+8MAfbzgEfpdq+FL5LsCl+rFU43684fBNgEs1fKl8D+BSvT/86P32EW6Km/LUpujqbspzm6J/uynf18dHP9xwiNqu1V9YK6Xatfr+Wg18X3wo4G7gSzewy+Vu4Gs3UFt3A//DBo77iYUuxLuBr91A1X7dDRz6+2h7uCluylObotq7KcMP6wK/SzV8qeR9l2r4Uon7LtXwe5pe71INXqq0SfBPLVXdTpypKf/09McgleRBg7wsiO7l9mcfdUsPnt6389/r2D6fLXFvHkc6PxLf/ujz6dLvfY9HPr4EbQ+fTrdPriPvn0Hf/pA7T7cet6db7+XB0+WzTPn8mMvbvW+xpPKpp/X3D6dSPvni69d89+Etbl9F2r58jr89/LGwl/VTF/YPFrada5Xb/uDh1D4rHqn+6cKGC+vC/ksLe1lN/msLW7bzHFa2L1/1/RVMaT8PeSnVI7myj1b2slb9vZWt5x/djwcrG5/zePsWv1x7S7oN/bKW+8qhX9Y6Xzn0y1rgt4Z+bOd/hlp5dIQr+SS4iPTgv0L+Fy5dVg6/tYL9/LVJfd8frOC+nWS8v7HCnX/v02WV8ZVDVySf+rA9TlTbtvro0zbV89M2l+an7aNPW5Fx6g5+TD2uOvX6+S9c3bdHH7et3fSrt/75Z9d8d+qxn79xJMXx0+MfY7+s97x27Jc1i9eO/bJq8dqxX9YtXjv2y8rFS8eeL3tb/97Yj/O1SD++/BDo3bHXY799IfVon0fTepv5ZS/rL5z5Ze/qL5z5Ze+mL5x5OPPpM/daOn/m3knnz9wL6fiZ9/NVZO25/Tpzb6PzZ+5VdPrMi/fQ+TP3Hjp/5t5D58/ce+j8mYcznz5z76HzZ+49dP7MvYfOn7n30Pkz9x46febhPXT+zL2Hzp+599D5M/ceOn/m4cynz9x76PyZew+dP3PvofNn7j10/sy9h06f+e49dP7MvYfOn7n30Pkz9x46f+bhzKfP3Hvo/Jl7D50/c++h82fuPXT+zL2HTp959R46f+beQ+fP3Hvo/Jl7D50/83Dm02fuPXT+zL2Hzp+599D5M/ceOn/m3kOnz7x5D50/c++h82fuPfQvzDzO32vR9zsz9x46f+bhzKfP3Hvo/Jl7D50/c++h82fuPXT+zL2HTp/54T10/sy9h86fuffQ+TP3Hjp/5uHMp8/ce+j8mXsPnT9z76HzZ+49dP7MvYdOn3n3Hjp/5t5D58/ce+j8mXsPnT/zcObTZ+49dP7MvYfOn7n30Pkz9x46f+beQ2fPPG/eQ+fP3Hvo/Jl7D50/c++h82ceznz6zL2Hzp+599D5M/ceOn/m172H9nybeduOB08/+GtZebvu1XLkGNN1b4tDx3jdC+DQMV73Tjd0jNe9pg0dYzjGEWO87mVq6Bivez8aOsbrXnmGjtFbzJAxeosZMcbsLWbIGL3FDBmjt5ghY/QWM2SM4RhHjNFbzJAxeosZMkZvMUPG6C1myBi9xTw3xt+/GSzeYoaM0VvMkDF6ixkyRm8xQ8YYjnHEGL3FDBmjt5ghY/QWM2SM3mKGjNFbzIgxhreYIWP0FjNkjN5ihozRW8yQMYZjHDHGy95itnr7Fo+U46enP0Zz2ZtJ2c8Ni/To6Zy34/we26N9TCnf/Dullh5u75bO7U2f25vuftn5XPUj1/z14Y+gl70jrRr0sre1VYNe9t64aND9sjfYVYNe9i69atDL3upXDXpZX1g1aBh0raCXNZdVgypFiwVVihYLqhQtFlQpWitoVYoWC6oULRZUKVosqFK0WNAw6FpBlaLFgipFiwVVihYLqhQtFlQpWitoU4oWC6oULRZUKVosqFK0WNAw6FpBlaLFgipFiwVVihYLqhQtFlQpWivooRQtFlQpWiyoUrRYUKVosaBh0LWCKkWLBVWKFguqFC0WVClaLKhStFbQrhQtFlQpenXQluP2Z7dc404j8YffSM/hNwobvbxR77dGJd1rpLrwGwkp/EbaCL+R3MFvpGDQG5VNlOA30hno96Oy6Qz8RjoDv1HYCN9IZ+A30hn45zqdgd9IZ+A30hnwjZLOwG+kM/Ab6Qz8RjrDyxulfnv67R/rnUZhI/odNukM/EY6A7+RzsBvpDPwG+kM+LN31hn4jXQGfiOdgd9IZ+A3ChvhG+kM/EY6A7+RzsBvpDPg301knQFvQUVn4DfSGfiNdAZ+I52B3yhsRD97F52B30hn4DfSGfiNdAZ+I50B3yh0Bn4jnYHfSGfgN9IZ8O8mImxEt6DQGfiNdAZ+I52B30hn4DfSGfBn711n4DfSGfiNdAZ+I52B3yhshG+kM/Ab6Qz8RjoDv5HOgH83sesMeAuqOgO/kc7Ab6Qz8BvpDPxGYSP62bvqDPxGOgO/kc7Ab6Qz8BvpDPhGTWfgN9IZ+I10Bn4jnQH/bqKFjegW1HQGfiOdgd9IZ+A30hn4jXQG/Nn70Bn4jXQGfiOdgd9IZ+A3ChvhG+kM/EY6A7+RzsBvpDPg300cOgPegrrOwG+kM/Ab6Qz8RjoDv1HYiH727joDv5HOwG+kM/Ab6Qz8RjoDvVFsOgO/kc7Ab6Qz8BvpDPR3E7GFjeAWFJvOwG+kM/Ab6Qz8RjoDv5HOgD97J52B30hn4DfSGfiNdAZ+o7ARvpHOwG+kM/Ab6Qz8RjoD/t1E0hnwFpR1Bn4jnYHfSGfgN9IZ+I3CRvSzd9YZ+I10Bn4jnYHfSGfgN9IZ8I2KzsBvpDPwG+kM/EY6A/7dRAkb0S2o6Az8RjoDv5HOwG+kM/Ab6Qz4s3foDPxGOgO/kc7Ab6Qz8BuFjfCNdAZ+I52B30hn4DfSGfDvJkJnwFvQrjPwG+kM/EY6A7+RzsBvFDain713nYHfSGfgN9IZ+I10Bn4jnQHfqOoM/EY6A7+RzsBvpDPg303UsBHdgqrOwG+kM/Ab6Qz8RjoDv5HOgD97N52B30hn4DfSGfiNdAZ+o7ARvpHOwG+kM/Ab6Qz8RjoD/t1E0xnwFnToDPxGOgO/kc7Ab6Qz8BuFjehn70Nn4DfSGfiNdAZ+I52B30hnwDfqOgO/kc7Ab6Qz8BvpDPh3Ez1sRLegrjPwG+kM/EY6A7+RzsBvpDPQz977pjPwG+kM/EY6A7+RzsBvFDbCN9IZ+I10Bn4jnYHfSGegv5vYN52BbkF70hn4jXQGfiOdgd9IZ+A3ChvRz95JZ+A30hn4jXQGfiOdgd9IZ8A3yjoDv5HOwG+kM/Ab6Qz4dxM5bES3oKwz8BvpDPxGOgO/kc7Ab6Qz4M/eRWfgN9IZ+I10Bn4jnYHfKGyEb6Qz8BvpDPxGOgO/kc6AfzdRdAa8BYXOwG+kM/Ab6Qz8RjoDv1HYiH72Dp2B30hn4DfSGfiNdAZ+I50B32jXGfiNdAZ+I52B30hnwL+b2MNGdAvadQZ+I52B30hn4DfSGfiNdAb82bvqDPxGOgO/kc7Ab6Qz8BuFjfCNdAZ+I52B30hn4DfSGfDvJqrOgLegpjPwG+kM/EY6A7+RzsBvFDain72bzsBvpDPwG+kM/EY6A7+RzoBvdOgM/EY6A7+RzsBvpDPg300cYSO6BR06A7+RzsBvpDPwG+kM/EY6A/7s3XUGfiOdgd9IZ+A30hn4jcJG+EY6A7+RzsBvpDPwG+kM+HcTXWegW1DddAZ+I52B30hn4DfSGfiNwkbws3fddAZ+I52B30hn4DfSGfiNdAZ8o6Qz8BvpDPxGOgO/kc5AfzdRU9iIbkFJZ+A30hn4jXQGfiOdgd9IZ8CfvbPOwG+kM/Ab6Qz8RjoDv1HYCN9IZ+A30hn4jXQGfiOdAf9uIusMeAsqOgO/kc7Ab6Qz8BvpDPxGYSP62bvoDPxGOgO/kc7Ab6Qz8BvpDPhGoTPwG+kM/EY6A7+RzoB/NxFhI7oFhc7Ab6Qz8BvpDPxGOgO/kc6AP3vvOgO/kc7Ab6Qz8BvpDPxGYSN8I52B30hn4DfSGfiNdAb8u4ldZ8BbUNUZ+I10Bn4jnYHfSGfgNwob0c/eVWfgN9IZ+I10Bn4jnYHfSGfAN2o6A7+RzsBvpDPwG+kM+HcTLWxEt6CmM/Ab6Qz8RjoDv5HOwG+kM+DP3ofOwG+kM/Ab6Qz8RjoDv1HYCN9IZ+A30hn4jXQGfiOdAf9u4tAZ8BbUdQZ+I52B30hn4DfSGfiNwkb0s3fXGfiNdAZ+I52B30hn4DfSGeiN2qYz8BvpDPxGOgO/kc5AfzfRtrAR3ILapjPwG+kM/EY6A7+RzsBvpDPgz95JZ+A30hn4jXQGfiOdgd8obIRvpDPwG+kM/EY6A7+RzoB/N5F0BrwFZZ2B30hn4DfSGfiNdAZ+o7AR/eyddQb82TvrDPzPOp2B30hn4DfSGfCNis7Ab6Qz4M/eRWfAn72LzsD/rAsb4RvpDPxGOgO/kc7Ab6Qz8M/eOgO+UegM/EY6A7+RzvDyRnE+/faP7U4jnYHfKGz0TKOy3Z7Oby90hjaqfUsfT9eefmp058vOcfsmj1zznaCixGJBFYzFgsodiwXVRhYLKqSsFXRXXRYLKtEsFlTPWSyo+LNY0DDoWkGVosWCKkWLBVWKFguqFC0WVClaK2hVihYLqhQtFlQpWiyoUrRY0DDoWkGVosWCKkWLBVWKFguqFC0WVClaK2hTihYLqhQtFlQpWiyoUrRY0DDoWkGVosWCKkWLBVWKFguqFC0WVCl6ddCHvw7rEH/4jfQcfiOJ5vWNHvyqpUN14TcKG+EbaSP8RnIHv5GCwW8kSvAb6Qz4+1HXGfiNdAZ+I52B30hn4DcKG9HPdV1n4DfSGfiNdAZ+I52B30hnoDc6Np2B30hneHmjB//XusemM9DvsMemM/AbhY3wjXQGfiOdgd9IZ+CfvXUGfiOdAd8o6Qz8RjoDv5HOwG+kM/AbhY3wjXQGfiOdAf9uIukMeAtKOgO/kc6Ab5R1Bn4jnYHfSGfAn72zzsBvFDbCN9IZ+I10Bn4jnYHfSGfgN9IZ8I2KzsBvpDPg300UnQFvQUVn4DcKG+Eb6Qz8RjoDv5HOwD976wz8RjoDvlHoDPxGOgO/kc7Ab6Qz8BuFjfCNdAZ+I50B/24idAa8BYXOwG+kM+Ab7ToDv5HOwG+kM+DP3rvOwG8UNsI30hn4jXQGfiOdgd9IZ+A30hnwjarOwG+kM+DfTVSdAW9BVWfgNwob4RvpDPxGOgO/kc7AP3vrDPxGOgO+UdMZ+I10Bn4jnYHfSGfgNwob4RvpDPxGOgP+3UTTGfAW1HQGfiOdAd/o0Bn4jXQGfiOdAX/2PnQGfqOwEb6RzsBvpDPwG+kM/EY6A7+RzoBv1HUGfiOdAf9uousMeAvqOgO/UdgI30hn4DfSGfiNdAb+2Vtn4DfSGeiN+qYz8BvpDPxGOgO/kc7AbxQ2wjfSGfiNdAb6u4m+6Qx0C+qbzsBvpDPgGyWdgd9IZ+A30hnwZ++kM/AbhY3wjXQGfiOdgd9IZ+A30hn4jXQGfKOsM/Ab6Qz4dxNZZ8BbUNYZ+I3CRvhGOgO/kc7Ab6Qz8M/eOgO/kc6Ab1R0Bn4jnYHfSGfgN9IZ+I3CRvhGOgO/kc6AfzdRdAa8BRWdgd9IZ8A3Cp2B30hn4DfSGfBn79AZ+I3CRvhGOgO/kc7Ab6Qz8BvpDPxGOgO+0a4z8BvpDPh3E7vOgLegXWfgNwob4RvpDPxGOgO/kc7AP3vrDPxGOgO+UdUZ+I10Bn4jnYHfSGfgNwob4RvpDPxGOgP+3UTVGfAWVHUGfiOdAd+o6Qz8RjoDv5HOgD97N52B3yhshG+kM/Ab6Qz8RjoDv5HOwG+kM+AbHToDv5HOgH83cegMeAs6dAZ+o7ARvpHOwG+kM/Ab6Qz8s7fOwG+kM+AbdZ2B30hn4DfSGfiNdAZ+o7ARvpHOwG+kM+DfTXSdAW9BXWfgN9IZ4I1i23QGfiOdgd9IZ4Cfvd8a6Qz8RmEjfCOdgd9IZ+A30hn4jXQGfiOdAd8o6Qz8RjoD/N3EWyOdAW9BSWfgNwob4RvpDPxGOgO/kc7AP3vrDPxGOgO+UdYZ+I10Bn4jnYHfSGfgNwob4RvpDPxGOgP+3UTWGfAWlHUGfiOdAd+o6Az8RjoDv5HOgD97F52B3yhshG+kM/Ab6Qz8RjoDv5HOwG+kM+Abhc7Ab6Qz4N9NhM6At6DQGfiNwkb4RjoDv5HOwG+kM/DP3joDv5HOgG+06wz8RjoDv5HOwG+kM/AbhY3wjXQGfiOdAf9uYtcZ8Ba06wz8RjoDvlHVGfiNdAZ+I50Bf/auOgO/UdgI30hn4DfSGfiNdAZ+I52B30hnwDdqOgO/kc6AfzfRdAa8BTWdgd8obIRvpDPwG+kM/EY6A//srTPwG+kM+EaHzsBvpDPwG+kM/EY6A79R2AjfSGfgN9IZ8O8mDp0Bb0GHzsBvpDPgG3Wdgd9IZ+A30hnwZ++uM/AbhY3wjXQGfiOdgd9IZ+A30hn4jXQGeqO06Qz8RjoD/d1E2nQGugWlTWfgNwob4RvpDPxGOgO/kc7AP3vrDPxGOgO+UdIZ+I10Bn4jnYHfSGfgNwob4RvpDPxGOgP+3UTSGfAWlHQGfiOdAd8o6wz8RjoDv5HOgD97Z52B3yhshG+kM/Ab6Qz8RjoDv5HOwG+kM+AbFZ2B30hnwL+bKDoD3oKKzsBvFDbCN9IZ+I10Bn4jnYF/9tYZ+I10Bnyj0Bn4jXQGfiOdgd9IZ+A3ChvhG+kM/EY6A/7dROgMeAsKnYHfSGfAN9p1Bn4jnYHfSGfAn713nYHfKGyEb6Qz8BvpDPxGOgO/kc7Ab6Qz4BtVnYHfSGfAv5uoOgPegqrOwG8UNsI30hn4jXQGfiOdgX/21hn4jXQGfKOmM/Ab6Qz8RjoDv5HOwG8UNsI30hn4jXQG/LuJpjPgLajpDPxGOgO+0aEz8BvpDPxGOgP+7H3oDPxGYSN8I52B30hn4DfSGfiNdAZ+I50B36jrDPxGOgP+3UTXGfAW1HUGfqOwEb6RzsBvpDPwG+kM/LO3zsBvpDPQG+VNZ+A30hn4jXQGfiOdgd8obIRvpDPwG+kM9HcTedMZ6BaUN52B30hnwDdKOgO/kc7Ab6Qz4M/eSWfAn71T2Aj/Wacz8BvpDPxGOgO/kc7Ab6Qz4M/eWWfAn72zzoD/rMs6A7+RzsBvFDbCN9IZ+I10Bv7ZW2fgN9IZ+I10BnyjojO8vFGcT7/9Y7vTSGfgN9IZnmvU0+17jK3/9PTHIMWAQYMMBzlmkF6rBw3Su++gQXpBHTRIb5FPDfLtiz0HWY4HT/dy3L6SHttPZ6VfHy7luF1QSulfHm73Ht5yO8OU8vXhj57eOJfqGd5O1+rpTXatnt56/6meab99HSW1fqenl++1eoY9l+opRfxbPfvZM6fy+4dzzedttZYHD6de0t1Zn5uitbgp7w9v2y1M3vKDh/d2K773/vXb+1gq3cmlGr5UGpxLNXyphECX6sdSRT2XqvY/WqpdjXSphi+VJOpSvT/8efnP6Yhfr3S72OqmPLcpMq6b8tymhJviprxXPL+MXPLx+4dTOc80qfR0Z610atfqL6yVqO1afX+t9nR7OO2R/+y2poC7ga/dQLncDXztBmrrbuB/2MB6/sTC/vNV9NsbWIV4N/C1G6jaL7yBezs38NHbnYc/iFVVezfl/eGBP95QBX6XavhShUvlUv3f2B9vqL4JcKmGL5XvAVyq94cfvd+uer2b8tym6OpuynObon+7Kd/Xx0c/3NBEbdfqL6yVUu1afX+tBr4vbgq4G/jaDZTL3cDXbmC4gW7g9zdw3E8sNCHeDXztBqr2625gK7ffj//W+Y/vrKq9m/Lcpqj2bsrww7rA71KNXqpD3nephi+VuO9Sjb6nHXq9SzV8qST4f2qp3sT6XKrjkSgN/c3FR7gpbsr/Hh74dxsO9dulGr5UgrZLNXyptG+X6sdSjfsLM4dM7lINXyqZ3KV6f/jR35jo2reb8tymCNpuynObolK7KT8qjvzrMl2ndq3+wlqFa+VafXutBv6oQFfA3cDXbqBc7ga+dgO1dTfwP2zguB+D6UK8G/jaDVTtF97Agb+5uGyqvZvy/vC4H294WxmXyqUavVS+C3CpfizVsB9vKJtvAlyq4UsVLpVL9X+P32+XTa93U57bFF3dTXluU/RvN+X7+vjghxvKJmq7Vn9hrZRq1+r7azXufXFJCrgb+NoNlMvdwNduoLbuBv6HDRz2EwslCfFu4Gs3MNzAZTdw5O+jLUm1d1Oe2xTV3k0ZflgX+F2q4Usl77tUw5dK3HepRt/Tsl7vUg1fKgn+qaWq24kzNeWfnv4YpJI8aJCXBdG93P7so27pwdP7dv57HdvnsyXuzeNI50fi2x99Pl36ve/xyMeXoO3h0+n2yXXk/TPo2x9y5+nW4/Z06708eLp8limfH3N5u/ctvkH6p57W3z+cSvnki69f892Ht7h9FWn78jn+9vDHwoYL68J+e2HbuVa57Q8eTu2z4pHqny7sZRnXhf03F/aymvzXFrZs5zmsbF++6vsrmNJ+HvJSqkdyZR+t7GWt+nsrW88/uh8PVjY+5/G//x+VL0+n29Ava7mvHPplrfOFQy+XtcBvDf3Yzv8MtfLoCPd2Lj7dMNKD/wr5X7hyWTn81gr289cm9X1/sIL7dpLxnrZy79/7yyrjK4euSD71YXucqLZt9dGnbarnp20uzU/bR5+24Q7O3MGPqV9Wyurnv3B13x593LZ206/e+uefXfPdqcd+/saRFMdPj3+M/bLe89qxX9YsXjv2y6rFa8d+Wbd46djjsnLx2rFf9rb+vbEf52uRfnz5IdC7Y6/HfvtC6tE+j6b1NvPLXtZfOPPL3tVfOPNw5tNn7s10/sy9ls6fuXfS+TP3Qjp+5v18FVl7br/O3Nvo9JnvXkXnz9x76PyZew+dP3PvofNnHs58+sy9h86fuffQ+TP3Hjp/5t5D58/ce+j0mVfvofNn7j10/sy9h86fuffQ+TMPZz595t5D58/ce+j8mXsPnT9z76HzZ+49dPrMm/fQ+TP3Hjp/5t5D58/ce+j8mYcznz5z76HzZ+49dP7MvYfOn7n30Pkz9x46feaH99D5M/ceOn/m3kPnz9x76PyZhzOfPnPvofNn7j10/sy9h86fuffQ+TP3Hjp95t176PyZew+dP3PvofNn7j30L8w8zt9r0fc7Mw9nPn3m3kPnz9x76PyZew+dP3PvofNn7j109sxj8x46f+beQ+fP3Hvo/Jl7D50/83Dm02fuPXT+zL2Hzp+599D5M/ceOn/m3kOnzzx5D50/c++h82fuPXT+zL2Hzp95OPPpM/ceOn/m3kPnz9x76PyZew+dP3PvodNnnr2Hzp+599D5M/ceOn/m3kPnzzyc+fSZew+dP3PvofNn7j10/sy9h86f+XXvoT3fZt6248HTD/5aVpTrXi2HjvG6t8WhY7zuBXDoGK97pxs6xnCMI8Z43ZvX0DFe9zI1dIzXvR8NHeN1rzxDx+gtZsQYw1vMkDF6ixkyRm8xQ8boLWbIGMMxjhijt5ghY/QWM2SM3mKGjNFbzJAxeosZMcbdW8xzY/z9m8HdW8yQMXqLGTJGbzFDxhiOccQYvcUMGaO3mCFj9BYzZIzeYoaM0VvMiDFWbzFDxugtZsgYvcUMGaO3mCFjDMc4YozeYoaM8bK3mK3evsUj5fjp6Y/RXPZmUvZzwyI9ejrn7Ti/x/ZoH1PKN/9OqaWH27ulc3vT5/amu192Plf9yDV/ffgj6GXvSKsGvextbdGg7bL3xlWDXvYGu2rQy96lVw162Vv9qkHDoGsFvax0rBr0suayalClaLGgStFiQZWitYIeStFiQZWixYIqRYsFVYoWCxoGXSuoUrRYUKVosaBK0WJBlaLFgipFawXtStFiQZWixYIqRYsFVYoWCxoGXSuoUrRYUKVosaBK0WJBlaLFgipFSwXdN6VosaBK0WJBlaLFgipFiwUNg64VVClaLKhStFhQpWixoErRYkGVorWCJqVosaBK0WJBlaJXB205bn92yzXuNBJ/+I3CRvhGEs3rG/V+a1TSvUaqC7+RkMJvpI3wG8kd+EZZweA3EiX4jXQG/P0o6wz8RmEjfCOdgd9IZ+A30hn45zqdgd9IZ8A3KjoDv5HOwG+kM/Ab6Qz8RmGjVzdK/fb02z/WO410BvwdtugM/EY6A7+RzsBvpDPgG4XOgD97h87Ab6Qz8BvpDPxGYSN8I52B30hn4DfSGfiNdAZ+I50B/25i1xnwFrTrDPxGOgO/kc7AbxQ2wjfSGfBn711n4DfSGfiNdAZ+I50B36jqDPxGOgO/kc7Ab6Qz8BuFjejvJqrOgLegqjPwG+kM/EY6A7+RzoBv1HQG/Nm76Qz8RjoDv5HOwG8UNsI30hn4jXQGfiOdgd9IZ+A30hnw7yYOnQFvQYfOwG+kM/Ab6Qz8RmEjfCOdAX/2PnQGfiOdgd9IZ+A30hnwjbrOwG+kM/Ab6Qz8RjoDv1HYiP5uousMeAvqOgO/kc7Ab6Qz8BvpDPRGddMZ6GfvuukM/EY6A7+RzsBvFDbCN9IZ+I10Bn4jnYHfSGfgN9IZ6O8matIZ8BaUdAZ+I52B30hn4DcKG+Eb6Qz4s3fSGfiNdAZ+I52B30hnwDfKOgO/kc7Ab6Qz8BvpDPxGYSP6u4msM+AtKOsM/EY6A7+RzsBvpDPgGxWdAX/2LjoDv5HOwG+kM/AbhY3wjXQGfiOdgd9IZ+A30hn4jXQG/LuJ0BnwFhQ6A7+RzsBvpDPwG4WN8I10BvzZO3QGfiOdgd9IZ+A30hnwjXadgd9IZ+A30hn4jXQGfqOwEf3dxK4z4C1o1xn4jXQGfiOdgd9IZ8A3qjoD/uxddQZ+I52B30hn4DcKG+Eb6Qz8RjoDv5HOwG+kM/Ab6Qz4dxNNZ8BbUNMZ+I10Bn4jnYHfKGyEb6Qz4M/eTWfgN9IZ+I10Bn4jnQHf6NAZ+I10Bn4jnYHfSGfgNwob0d9NHDoD3oIOnYHfSGfgN9IZ+I10BnyjrjPgz95dZ+A30hn4jXQGfqOwEb6RzsBvpDPwG+kM/EY6A7+RzkB/N9E2nYFuQW3TGfiNdAZ+I52B3yhshG+kM9DP3m3TGfiNdAZ+I52B30hnwDdKOgO/kc7Ab6Qz8BvpDPxGYSP6u4mkM+AtKOkM/EY6A7+RzsBvpDPgG2WdAX/2zjoDv5HOwG+kM/AbhY3wjXQGfiOdgd9IZ+A30hn4jXQG/LuJojPgLajoDPxGOgO/kc7AbxQ2wjfSGfBn76Iz8BvpDPxGOgO/kc6AbxQ6A7+RzsBvpDPwG+kM/EZhI/q7idAZ8BYUOgO/kc7Ab6Qz8BvpDPhGu86AP3vvOgO/kc7Ab6Qz8BuFjfCNdAZ+I52B30hn4DfSGfiNdAb8u4mqM+AtqOoM/EY6A7+RzsBvFDbCN9IZ8GfvqjPwG+kM/EY6A7+RzoBv1HQGfiOdgd9IZ+A30hn4jcJG9HcTTWfAW1DTGfiNdAZ+I52B30hnwDc6dAb82fvQGfiNdAZ+I52B3yhshG+kM/Ab6Qz8RjoDv5HOwG+kM+DfTXSdAW9BXWfgN9IZ+I10Bn6jsBG+kc6AP3t3nYHfSGfgN9IZ+I10BnqjY9MZ+I10Bn4jnYHfSGfgNwobwd9NHJvOQLegY9MZ+I10Bn4jnYHfSGfAN0o6A/7snXQGfiOdgd9IZ+A3ChvhG+kM/EY6A7+RzsBvpDPwG+kM+HcTWWfAW1DWGfiNdAZ+I52B3yhshG+kM+DP3lln4DfSGfiNdAZ+I50B36joDPxGOgO/kc7Ab6Qz8BuFjejvJorOgLegojPwG+kM/EY6A7+RzoBvFDoD/uwdOgO/kc7Ab6Qz8BuFjfCNdAZ+I52B30hn4DfSGfiNdAb8u4ldZ8Bb0K4z8BvpDPxGOgO/UdgI30hnwJ+9d52B30hn4DfSGfiNdAZ8o6oz8BvpDPxGOgO/kc7AbxQ2or+bqDoD3oKqzsBvpDPwG+kM/EY6A75R0xnwZ++mM/Ab6Qz8RjoDv1HYCN9IZ+A30hn4jXQGfiOdgd9IZ8C/mzh0BrwFHToDv5HOwG+kM/AbhY3wjXQG/Nn70Bn4jXQGfiOdgd9IZ8A36joDv5HOwG+kM/Ab6Qz8RmEj+ruJrjPgLajrDPxGOgO/kc7Ab6Qz0Bv1TWegn737pjPwG+kM/EY6A79R2AjfSGfgN9IZ+I10Bn4jnYHfSGegv5voSWfAW1DSGfiNdAZ+I52B3yhshG+kM+DP3kln4DfSGfiNdAZ+I50B3yjrDPxGOgO/kc7Ab6Qz8BuFjejvJrLOgLegrDPwG+kM/EY6A7+RzoBvVHQG/Nm76Az8RjoDv5HOwG8UNsI30hn4jXQGfiOdgd9IZ+A30hnw7yZCZ8BbUOgM/EY6A7+RzsBvFDbCN9IZ8Gfv0Bn4Z2+dgf9ZpzPwG+kM+Ea7zsBvpDPwG+kM+LP3rjPgz9572Aj/Wacz8BvpDPxGOgO/kc7Ab6Qz4M/eVWfgN9IZ+I10Bn4jneHljeJ8+u0f251GYSN8I53hqUZluz2dS8tDG9W+pY+na08/NbrzZee4fZNHrvlOUFFisaAKxmJB5Y7FgmojawVtQspiQVWXxYJKNIsF1XMWCxoGXSuoUrRYUKVosaBK0WJBlaLFgipFawU9lKLFgipFiwVVihYLqhQtFjQMulZQpWixoErRYkGVosWCKkWLBVWK1gralaLFgipFiwVVihYLqhQtFjQMulZQpWixoErRYkGVosWCKkWLBVWKVgq6b5tS9OqgD34d1lsj8YffSM/hN5JoXt/ot79q6a1R2AjfSEjhN9JG+I3kDn4jBYPfSJTAN0o6A/5+lHQGfiOdgd9IZ+A3ChvhG+kM/HOdzsBvpDPwG+kM/EY6A75R1hn4jXQGfiOd4eWNfv9/rfvWSGfA32Fz2AjfSGfgN9IZ+I10Bn4jnYF/9tYZ8I2KzsBvpDPwG+kM/EY6A79R2AjfSGfgN9IZ+I10Bvy7iaIz4C2o6Az4RqEz8BvpDPxGOgO/kc6AP3tH2AjfSGfgN9IZ+I10Bn4jnYHfSGfAN9p1Bn4jnYHfSGfAv5vYdQa8Be1hI3wjnYHfSGfgN9IZ+I10Bv7ZW2fAN6o6A7+RzsBvpDPwG+kM/EZhI3wjnYHfSGfgN9IZ8O8mqs6At6CqM+AbNZ2B30hn4DfSGfiNdAb82buFjfCNdAZ+I52B30hn4DfSGfiNdAZ8o0Nn4DfSGfiNdAb8u4lDZ8Bb0BE2wjfSGfiNdAZ+I52B30hn4J+9dQZ8o64z8BvpDPxGOgO/kc7AbxQ2wjfSGfiNdAZ+I50B/26i6wx4C+o6A71R2nQGfiOdgd9IZ+A30hnoZ++0hY3wjXQGfiOdgd9IZ+A30hn4jXQGfKOkM/Ab6Qz8RjoD/d1ESjoD3oJS2AjfSGfgN9IZ+I10Bn4jnYF/9tYZ8I2yzsBvpDPwG+kM/EY6A79R2AjfSGfgN9IZ+I10Bvy7iawz4C0o6wz4RkVn4DfSGfiNdAZ+I50Bf/YuYSN8I52B30hn4DfSGfiNdAZ+I50B3yh0Bn4jnYHfSGfAv5sInQFvQRE2wjfSGfiNdAZ+I52B30hn4J+9dQZ8o11n4DfSGfiNdAZ+I52B3yhshG+kM/Ab6Qz8RjoD/t3ErjPgLWjXGfCNqs7Ab6Qz8BvpDPxGOgP+7F3DRvhGOgO/kc7Ab6Qz8BvpDPxGOgO+UdMZ+I10Bn4jnQH/bqLpDHgLamEjfCOdgd9IZ+A30hn4jXQG/tlbZ8A3OnQGfiOdgd9IZ+A30hn4jcJG+EY6A7+RzsBvpDPg300cOgPegg6dAd+o6wz8RjoDv5HOwG+kM+DP3j1shG+kM/Ab6Qz8RjoDv5HOwG+kM9Ab5U1n4DfSGfiNdAb6u4m86Qx0C8pb2AjfSGfgN9IZ+I10Bn4jnYF/9tYZ8I2SzsBvpDPwG+kM/EY6A79R2AjfSGfgN9IZ+I10Bvy7iaQz4C0o6Qz4Rlln4DfSGfiNdAZ+I50Bf/bOYSN8I52B30hn4DfSGfiNdAZ+I50B36joDPxGOgO/kc6AfzdRdAa8BZWwEb6RzsBvpDPwG+kM/EY6A//srTPgG4XOwG+kM/Ab6Qz8RjoDv1HYCN9IZ+A30hn4jXQG/LuJ0BnwFhQ6A77RrjPwG+kM/EY6A7+RzoA/e+9hI3wjnYHfSGfgN9IZ+I10Bn4jnQHfqOoM/EY6A7+RzoB/N1F1BrwF1bARvpHOwG+kM/Ab6Qz8RjoD/+ytM+AbNZ2B30hn4DfSGfiNdAZ+o7ARvpHOwG+kM/Ab6Qz4dxNNZ8BbUNMZ8I0OnYHfSGfgN9IZ+I10BvzZ+wgb4RvpDPxGOgO/kc7Ab6Qz8BvpDPhGXWfgN9IZ+I10Bvy7ia4z4C2oh43wjXQGfiOdgd9IZ+A30hn4Z2+dgd6obDoDv5HOwG+kM/Ab6Qz8RmEjfCOdgd9IZ+A30hno7ybKpjPQLahsOgO+UdIZ+I10Bn4jnYHfSGfAn71T2AjfSGfgN9IZ+I10Bn4jnYHfSGfAN8o6A7+RzsBvpDPg301knQFvQTlshG+kM/Ab6Qz8RjoDv5HOwD976wz4RkVn4DfSGfiNdAZ+I52B3yhshG+kM/Ab6Qz8RjoD/t1E0RnwFlR0Bnyj0Bn4jXQGfiOdgd9IZ8CfvSNshG+kM/Ab6Qz8RjoDv5HOwG+kM+Ab7ToDv5HOwG+kM+DfTew6A96C9rARvpHOwG+kM/Ab6Qz8RjoD/+ytM+AbVZ2B30hn4DfSGfiNdAZ+o7ARvpHOwG+kM/Ab6Qz4dxNVZ8BbUNUZ8I2azsBvpDPwG+kM/EY6A/7s3cJG+EY6A7+RzsBvpDPwG+kM/EY6A77RoTPwG+kM/EY6A/7dxKEz4C3oCBvhG+kM/EY6A7+RzsBvpDPwz946A75R1xn4jXQGfiOdgd9IZ+A3ChvhG+kM/EY6A7+RzoB/N9F1BrwFdZ2B3ig2nYHfSGfgN9IZ+I10BvrZO7awEb6RzsBvpDPwG+kM/EY6A7+RzoBvlHQGfiOdgd9IZ6C/m4ikM+AtKIWN8I10Bn4jnYHfSGfgN9IZ+GdvnQHfKOsM/EY6A7+RzsBvpDPwG4WN8I10Bn4jnYHfSGfAv5vIOgPegrLOgG9UdAZ+I52B30hn4DfSGfBn7xI2op+9i87A/6zTGfiNdAZ+I52B30hnwDcKnQF/9g6dAX/2Dp2B/1mnM/AbhY3wjXQGfiOdgd9IZ+CfvXUGfiOdAd9o1xn4jXSGlzeK8+m3f2x3GukM/EY6w3ONerp9j7H1n57+GGQ4yDGD9MY+aJBeqwcN0rvvoEF6QR00SG+RTw3y7Ys9B1mOB0/3cty+kh7bT2elXx8u5bhdUErpXx5u9x7ecjvDlPL14R89qzfOtXp6O12rpzfZtXp66/2neqb99nWU1PqdnmHPpXpqAGv1lCL+rZ797JlT+f3DuebztlrLg4dTL+nurM9N0VrclPeHt+0WJm/5wcN7uxXfe//67X0sle7kUg1fKg3OpRq9VE0IdKl+LFXUc6lq/7OlUiNdquFLJYm6VO8Pf17+czri1ytdE1vdlOc2JdwUN+WpTRGI3ZQfFc8vI5d8/P7hVM4zTSo93Vkrndq1+gtrJWq7Vt9fqz3dHv7fL8L9s9uaAu4GvnYD5XI38KUbeGjrbuB/2MB6/sTC/vNV9PsbKMS7ga/dQNV+4Q3c27mBj97uPPxBrEO1d1PeHx744w1HuFQu1eil8l2AS/Vjqcb9eMPhmwCXavhS+R7ApXp/+NH77UOvd1Oe2xRd3U15alO6/u2mfF8fH/1wQxe1Xau/sFZKtWv1/bUa+L64K+Bu4Gs3MNxAN/ClG6itu4H/YQPH/cRCF+LdwNduoGq/7ga2cvv9+LnVP76zqvZuynObotq7KYMP6/sm8LtUw5dK3nephi+VuO9SDb6n7Zte71INX6pwqf6lpcotzqU6HonSyN9cvG9SuZvy/vC4v9uwb+q3SzV8qQRtl2r4UmnfLtWPpRr2F2b2TSZ3qUYvVZLJXar3hx/8jYk9ad9uynObImi7Kc9tikrtpvyoOPCvy+wpXCvXavxaidqu1ffXauCPCiQF3A187QbK5W7gazdQW3cD/8MGjvsxmCTEu4Ev3cCs2i+8gQN/c/GeVXs35f3hgT/ekAV+l2r4UvkuwKX6sVTjfrwhh0vlUo1eKt8DuFTvDz96v531ejfluU3R1d2U5zZF/3ZTvq+Pj364IYvartX4tSpKtWv1/bUa+L64KOBu4Gs3UC53A1+7gdq6G/gfNnDcTyyUcAPdwJduoGq/7gaO/H20e1Ht3ZTnNkW1d1OGH9YFfpdq+FLJ+y7V6KUKcd+lGn1PC73epRq+VBL8U0tVtxNnaso/Pf0xSCV50CDjqoN8uzXfBlm39ODpfTv/vY7t89kS9+ZxpPMj8e2PPp8u/d73eOTjS9D28Ol0++Q68v4Z9O0PufN063F7uvVeHjxdPsuUz4+5vN37Fksqn3paf/9wKuWTL75+zXcf3uL2VaTty+f428MfC3tZP3Vh/2Bh27lWue0PHk7ts+KR6p8u7GUZ14X9Nxf2spr81xa2bOc5rGxfvur7K5j+93Owt28y1SO5so9W9rJW/b2Vrecf3Y8HKxuf83j7Fr9ce0u6Df2ylvvCoe+Xtc5XDv2yFvitoR/b+Z+hVh4d4Uo+CS4iPfivkP+F2y8rh99awX7+2qS+7w9WcN9OMt7TVu79e39ZZXzl0MOhP/Nhe5yotm310adtquenbS7NT9tHn7Yi49Qd/Jj6ZaWsfv4LV/ft0cdtazf96q1//tk135167OdvHElx/PT4x9gv6z2vHftlzeK1Y7+sWrx07PWybvHasV9WLl479sve1r839uN8LdKPLz8Eenfs9dhvX0g92ufRtN5mftnL+gtnHs58+swvezd94cy9mc6fudfS+TP3Tjp/5l5Ix8+8n68ia8/tl5k3b6PzZ+5VdP7MvYfOn7n30PkzD2c+febeQ+fP3Hvo/Jl7D50/c++h82fuPXT6zA/vofNn7j10/sy9h86fuffQ+TMPZz595t5D58/ce+j8mXsPnT9z76HzZ+49dPrMu/fQ+TP3Hjp/5t5D58/ce+j8mYcznz5z76HzZ+49dP7MvYfOn7n30Pkz9x46e+Z18x46f+beQ+fP3Hvo/Jl7D50/83Dm02fuPXT+zL2Hzp+599D5M/ceOn/m3kOnzzx5D50/c++h82fuPXT+zL2Hzp95OPPxM4/z91r0/c7MvYfOn7n30Pkz9x46f+beQ+fP3Hvo9Jln76HzZ+49dP7MvYfOn7n30PkzD2c+febeQ+fP3Hvo/Jl7D50/c++h82fuPXT6zIv30Pkz9x46f+beQ+fP3Hvo/JmHM58+c++h82fuPXT+zL2Hzp+599D5M/ceOn3m4T10/sy9h86fuffQ+TP3Hjp/5uHMp8/ce+j8mXsPnT9z76HzZ+49dP7MvYdOn/l+3Xtoz7eZt+148PSjv5a1X/dqOXSM170tDh3jdS+AQ8cYjnHEGK97TRs6xuvevIaO8bqXqaFjvO79aOgYr3vlGTnG6i1myBi9xQwZo7eYIWP0FjNkjOEYR4zRW8yQMXqLGTJGbzFDxugtZsgYvcWMGGPzFjNkjN5inhvj798MNm8xQ8boLWbIGMMxjhijt5ghY/QWM2SM3mKGjNFbzJAxeosZMcbDW8yQMXqLGTJGbzFDxugtZsgYwzGOGKO3mCFj9BYzZIyXvcVs9fYtHinHT09/jOayN5OynxsW6dHTOW/H+T22R/uYUr75d0otPdzeLZ3bmz63N939svO56keu+evDH0Eve0daNGi/7G1t1aCXvTeuGvSyN9hVg172Lr1q0DDoWkEv6wurBr2sdKwa9LLmsmpQpWixoErRUkHbphQtFlQpWiyoUrRYUKVosaBh0LWCKkWLBVWKFguqFC0WVClaLKhStFbQpBQtFlQpWiyoUrRYUKVosaBh0LWCKkWLBVWKFguqFC0WVClaLKhStFbQrBQtFlQpWiyoUrRYUKVosaBh0LWCKkWLBVWKFguqFC0WVClaLKhStFbQohQtFlQpWiyoUrRYUKXo1UHfcOf2Z7/dIuNOo7ARvpGew28k0by+Ue+3RiXda6S68BsJKfxG2gi+Ucgd/EYKBr+RKMFvpDPg70cRNsI30hn4jXQGfiOdgd9IZ+Cf63QGfKNdZ+A30hn4jXQGfiOdgd8obIRvpDO8vFHqt6ff/rHeaaQz4O+wu87Ab6Qz8BvpDPhGVWfgN9IZ8GfvqjPwG+kM/EZhI3wjnYHfSGfgN9IZ+I10Bn4jnQHfqOkM+HcTTWfAW1DTGfiNdAZ+o7ARvpHOwG+kM/DP3joDv5HOwG+kM+AbHToDv5HOwG+kM/Ab6Qz8RmEjfCOdAf9u4tAZ8BZ06Az8RjoDv5HOgG/UdQZ+I50Bf/buOgO/kc7AbxQ2wjfSGfiNdAZ+I52B30hn4DfSGeiNjk1noL+bODadgW5Bx6Yz8BvpDPxGYSN8I52B30hn4J+9dQZ+I52B30hnwDdKOgO/kc7Ab6Qz8BvpDPxGYSN8I50B/24i6Qx4C0o6A7+RzsBvpDPgG2Wdgd9IZ8CfvbPOwG+kM/AbhY3wjXQGfiOdgd9IZ+A30hn4jXQGfKOiM+DfTRSdAW9BRWfgN9IZ+I3CRvhGOgO/kc7AP3vrDPxGOgO/kc6AbxQ6A7+RzsBvpDPwG+kM/EZhI3wjnQH/biJ0BrwFhc7Ab6Qz8BvpDPhGu87Ab6Qz4M/eu87Ab6Qz8BuFjfCNdAZ+I52B30hn4DfSGfiNdAZ8o6oz4N9NVJ0Bb0FVZ+A30hn4jcJG+EY6A7+RzsA/e+sM/EY6A7+RzoBv1HQGfiOdgd9IZ+A30hn4jcJG+EY6A/7dRNMZ8BbUdAZ+I52B30hnwDc6dAZ+I50Bf/Y+dAZ+I52B3yhshG+kM/Ab6Qz8RjoDv5HOwG+kM+AbdZ0B/26i6wx4C+o6A7+RzsBvFDbCN9IZ+I10Bv7ZW2fgN9IZ+I10BnqjvukM/EY6A7+RzsBvpDPwG4WN8I10Bvq7ib7pDHQL6pvOwG+kM/Ab6Qz4Rkln4DfSGfBn76Qz8BvpDPxGYSN8I52B30hn4DfSGfiNdAZ+I50B3yjrDPh3E1lnwFtQ1hn4jXQGfqOwEb6RzsBvpDPwz946A7+RzsBvpDPgGxWdgd9IZ+A30hn4jXQGfqOwEb6RzoB/N1F0BrwFFZ2B30hn4DfSGfCNQmfgN9IZ8Gfv0Bn4jXQGfqOwEb6RzsBvpDPwG+kM/EY6A7+RzoBvtOsM+HcTu86At6BdZ+A30hn4jcJG+EY6A7+RzsA/e+sM/EY6A7+RzoBvVHUGfiOdgd9IZ+A30hn4jcJG+EY6A/7dRNUZ8BZUdQZ+I52B30hnwDdqOgO/kc6AP3s3nYHfSGfgNwob4RvpDPxGOgO/kc7Ab6Qz8BvpDPhGh86Afzdx6Ax4Czp0Bn4jnYHfKGyEb6Qz8BvpDPyzt87Ab6Qz8BvpDPhGXWfgN9IZ+I10Bn4jnYHfKGyEb6Qz4N9NdJ0Bb0FdZ+A30hn4jXQGeKO6bToDv5HOAD97vzXSGfiNdAZ+o7ARvpHOwG+kM/Ab6Qz8RjoDv5HOgG+UdAb4u4m3RjoD3oKSzsBvpDPwG4WN8I10Bn4jnYF/9tYZ+I10Bn4jnQHfKOsM/EY6A7+RzsBvpDPwG4WN8I10Bvy7iawz4C0o6wz8RjoDv5HOgG9UdAZ+I50Bf/YuOgO/kc7AbxQ2wjfSGfiNdAZ+I52B30hn4DfSGfCNQmfAv5sInQFvQaEz8BvpDPxGYSN8I52B30hn4J+9dQZ+I52B30hnwDfadQZ+I52B30hn4DfSGfiNwkb4RjoD/t3ErjPgLWjXGfiNdAZ+I50B36jqDPxGOgP+7F11Bn4jnYHfKGyEb6Qz8BvpDPxGOgO/kc7Ab6Qz4Bs1nQH/bqLpDHgLajoDv5HOwG8UNsI30hn4jXQG/tlbZ+A30hn4jXQGfKNDZ+A30hn4jXQGfiOdgd8obIRvpDPg300cOgPegg6dgd9IZ+A30hnwjbrOwG+kM+DP3l1n4DfSGfiNwkb4RjoDv5HOwG+kM/Ab6Qz8RjoDvVHadAb6u4m06Qx0C0qbzsBvpDPwG4WN8I10Bn4jnYF/9tYZ+I10Bn4jnQHfKOkM/EY6A7+RzsBvpDPwG4WN8I10Bvy7iaQz4C0o6Qz8RjoDv5HOgG+UdQZ+I50Bf/bOOgO/kc7AbxQ2wjfSGfiNdAZ+I52B30hn4DfSGfCNis6AfzdRdAa8BRWdgd9IZ+A3ChvhG+kM/EY6A//srTPwG+kM/EY6A75R6Az8RjoDv5HOwG+kM/AbhY3wjXQG/LuJ0BnwFhQ6A7+RzsBvpDPgG+06A7+RzoA/e+86A7+RzsBvFDbCN9IZ+I10Bn4jnYHfSGfgN9IZ8I2qzoB/N1F1BrwFVZ2B30hn4DcKG+Eb6Qz8RjoD/+ytM/DP3joD/7NOZ8A3ajoDv5HOwG+kM/Ab6Qz4s3cLG9HP3k1n4H/W6Qz8RjoDv5HOwG+kM+AbHToD/ux96Az8RjoDv5HOwG8UNnp1oziffvvHdqeRzsBvpDM81ahst6dzaXloo9q39PF07emnRne+7By3b/LINd8JKkosFlTBWCyo3LFW0K6NLBZUSFksqOqyWFCJZrGgYdC1goo/iwVVihYLqhQtFlQpWiyoUrRU0LwpRYsFVYoWC6oULRZUKVosaBh0raBK0WJBlaLFgipFiwVVihYLqhStFTQpRYsFVYoWC6oULRZUKVosaBh0raBK0WJBlaLFgipFiwVVihYLqhStFTQrRYsFVYpeHfTRr8PKWfzhN9Jz+I3CRi9v9PtftfQ2XxvhGwkp/EbaCL+R3MFvpGDgGxVRgt9IZ8Dfj4rOwG+kM/AbhY3wjXQGfiOdgX+u0xn4jXQGfiOdAd8odAZ+I52B30hn4DfSGV7e6MH/tW6OsBH9Dhs6A7+RzsBvpDPwG+kM/EY6A/7svesM/EY6A7+RzsBvpDPwG4WN8I10Bn4jnYHfSGfgN9IZ8O8mdp0Bb0FVZ+A30hn4jXQGfiOdgd8obEQ/e1edgd9IZ+A30hn4jXQGfiOdAd+o6Qz8RjoDv5HOwG+kM+DfTbSwEd2Cms7Ab6Qz8BvpDPxGOgO/kc6AP3sfOgO/kc7Ab6Qz8BvpDPxGYSN8I52B30hn4DfSGfiNdAb8u4lDZ8BbUNcZ+I10Bn4jnYHfSGfgNwob0c/eXWfgN9IZ+I10Bn4jnYHfSGegNyqbzsBvpDPwG+kM/EY6A/3dRNnCRnALKpvOwG+kM/Ab6Qz8RjoDv5HOgD97J52B30hn4DfSGfiNdAZ+o7ARvpHOwG+kM/Ab6Qz8RjoD/t1E0hnwFpR1Bn4jnYHfSGfgN9IZ+I3CRvSzd9YZ+I10Bn4jnYHfSGfgN9IZ8I2KzsBvpDPwG+kM/EY6A/7dRAkb0S2o6Az8RjoDv5HOwG+kM/Ab6Qz4s3foDPxGOgO/kc7Ab6Qz8BuFjfCNdAZ+I52B30hn4DfSGfDvJkJnwFvQrjPwG+kM/EY6A7+RzsBvFDain713nYHfSGfgN9IZ+I10Bn4jnQHfqOoM/EY6A7+RzsBvpDPg303UsBHdgqrOwG+kM/Ab6Qz8RjoDv5HOgD97N52B30hn4DfSGfiNdAZ+o7ARvpHOwG+kM/Ab6Qz8RjoD/t1E0xnwFnToDPxGOgO/kc7Ab6Qz8BuFjehn70Nn4DfSGfiNdAZ+I52B30hnwDfqOgO/kc7Ab6Qz8BvpDPh3Ez1sRLegrjPwG+kM/EY6A7+RzsBvpDPQz96x6Qz8RjoDv5HOwG+kM/AbhY3wjXQGfiOdgd9IZ+A30hno7yZi0xnoFhRJZ+A30hn4jXQGfiOdgd8obEQ/eyedgd9IZ+A30hn4jXQGfiOdAd8o6wz8RjoDv5HOwG+kM+DfTeSwEd2Css7Ab6Qz8BvpDPxGOgO/kc6AP3sXnYHfSGfgN9IZ+I10Bn6jsBG+kc7Ab6Qz8BvpDPxGOgP+3UTRGfAWFDoDv5HOwG+kM/Ab6Qz8RmEj+tk7dAZ+I52B30hn4DfSGfiNdAZ8o11n4DfSGfiNdAZ+I50B/25iDxvRLWjXGfiNdAZ+I52B30hn4DfSGfBn76oz8BvpDPxGOgO/kc7AbxQ2wjfSGfiNdAZ+I52B30hnwL+bqDoD3oKazsBvpDPwG+kM/EY6A79R2Ih+9m46A7+RzsBvpDPwG+kM/EY6A77RoTPwG+kM/EY6A7+RzoB/N3GEjegWdOgM/EY6A7+RzsBvpDPwG+kM+LN31xn4jXQGfiOdgd9IZ+A3ChvhG+kM/EY6A7+RzsBvpDPg3010nYFuQfumM/Ab6Qz8RjoDv5HOwG8UNoKfvfdNZ+A30hn4jXQGfiOdgd9IZ8A3SjoDv5HOwG+kM/Ab6Qz0dxN7ChvRLSjpDPxGOgO/kc7Ab6Qz8BvpDPizd9YZ+I10Bn4jnYHfSGfgNwob4RvpDPxGOgO/kc7Ab6Qz4N9NZJ0Bb0FFZ+A30hn4jXQGfiOdgd8obEQ/exedgd9IZ+A30hn4jXQGfiOdAd8odAZ+I52B30hn4DfSGfDvJiJsRLeg0Bn4jXQGfiOdgd9IZ+A30hnwZ+9dZ+A30hn4jXQGfiOdgd8obIRvpDPwG+kM/EY6A7+RzoB/N7HrDHgLqjoDv5HOwG+kM/Ab6Qz8RmEj+tm76gz8RjoDv5HOwG+kM/Ab6Qz4Rk1n4DfSGfiNdAZ+I50B/26ihY3oFtR0Bn4jnYHfSGfgN9IZ+I10BvzZ+9AZ+I10Bn4jnYHfSGfgNwob4RvpDPxGOgO/kc7Ab6Qz4N9NHDoD3oK6zsBvpDPwG+kM/EY6A79R2Ih+9u46A7+RzsBvpDPwG+kM/EY6A71R3XQGfiOdgd9IZ+A30hno7ybqFjaCW1DddAZ+I52B30hn4DfSGfiNdAb82TvpDPxGOgO/kc7Ab6Qz8BuFjfCNdAZ+I52B30hn4DfSGfDvJpLOgLegrDPwG+kM/EY6A7+RzsBvFDain72zzsBvpDPwG+kM/EY6A7+RzoBvVHQGfiOdgd9IZ+A30hnw7yZK2IhuQUVn4DfSGfiNdAZ+I52B30hnwJ+9Q2fgN9IZ+I10Bn4jnYHfKGyEb6Qz8BvpDPxGOgO/kc6AfzcROgPegnadgd9IZ+A30hn4jXQGfqOwEf3svesM+LP3rjPwP+t0Bn4jnYHfSGfAN6o6A7+RzoA/e1edAX/2rjoD/7MubIRvpDPwG+kM/EY6A7+RzsA/e+sM+EZNZ+A30hn4jXSGlzeK8+m3f2x3GukM/EZho6ca9XT7HmPrPz39MUgxYNAgvbEPGqTX6kGD9O47aJBeUMcM8vAW+dQg377Yc5DlePB0L8ftK+mx/XRW+vXhUo7bBaWU/uXhdu/hLbczTClfH/7o6Y1zrZ7eTtfq6U12rZ5hz3+pZ9pvX0dJrd/p6eV7rZ4awFo9pYh/q2c/e+ZUfv9wrvm8rdby4OHUS7o763NTtBY35f3hbbuFyVt+8PDebsX33r9+ex9LpTu5VKOXqmtwLtXwpRICXaofSxX1XKra/2yp1EiXavhSSaIu1fvDn5f/nI749UrXw01xU57aFBnXTXluUwRiN+VHxfPLyCUfv384lfNMk0pPd9ZKp3at/sJaidqu1ffXak+3h9Me+c9uawq4G/jKDWybXO4GvnYDtXU38D9sYD1/YmH/+Sr6/Q0U4t3A126gar/wBu7t3MBHb3ce/SBW28JNcVP+b+iPN7RN4Hephi+V7wJcqh9LNezHG9rmmwCXavhS+R7ApXp/+MH77bbp9W7KU5uSdHU35blN0b/dlO/r44MfbmhJ1Hat/sJaKdWu1ffXauD74hRuoBv40g2Uy93A126gtu4G/ocNHPcTC0mIdwNfu4Gq/bob2Mrt9+PnVv/4zqrauylPbUpW7d2U0Yf1LPC7VMOXSt53qYYvlbjvUo2+p+VwqVyq0Uslwf9TS5VbnEt1PBKlkb+5uGWp3E15f3jg323I6rdLNXypBG2XavhSad8u1Y+lGvcXZopM7lINXyqZ3KV6f/jR35go2reb8tymCNpuynObEm6Km/JeceRflyk6tWv1F9ZK1Hatvr9WA39UoCjgbuBrN1AudwNfu4Hauhv4HzZw3I/BhBDvBr52A1X7hTdw5G8uDtXeTXl/eOCPN4TA71INX6pwqVyq/xv74w3hmwCXavhS+R7ApXp/+NH77dDr3ZTnNkVXd1Oe2xT92035vj4++uGGXdR2rf7CWinVrtX312rg++JdAXcDX7uBcrkb+NoNDDfQDfz+Bo77iYVdiHcDX7uBqv26Gzj099Huqr2b8tymqPZuyvDDusDvUo1eqirvu1TDl0rcd6lG39OqXu9SDV8qCf6pparbiTM15Z+e/hhkOMgxg7wsiO7l9mcfdUsPnt6389/r2D6fLXFvHkc6PxLf/ujz6dLvfY9HPr4EbQ+fTrdPriPvn0Hf/pA7T7cet6db7+XB0+WzTPn8mMvbvW+xpPKpp/X3D6dSPvni69d89+Etbl9F2r58jr89/LGwl/VTF/YPFrada5XfXkM+2MH2WfFI9U8X9rKM68L+mwt7WU3+awtbtvMcVrYvX/X9FUxpPw95KdUjubKPVvayVv29la3nH92PBysbn/N4+xa/XHtL+hh6u6zlvnLol7XOVw79shb4raEf2/mfoVYeHeFKPgkuIj34r5D/hWuXlcNvrWA/f21S3/cHK7hvJxnvaSv3/r0Phz5/6IrkUx+2x4lq21Yffdqmen7a5tL8tH30aSsyTt3Bj6lfVsrq579wdd8efdy2dtOv3vrnn13z3anHfv7GkRTHT49/jP2y3vPasV/WLF469uOyavHasV/WLV479svKxWvHftnb+vfGfpyvRfrx5YdA7469HvvtC6lH+zya1tvMw5lPn/ll7+ovnPll76YvnLk30/kz91o6f+beSafPvHshHT/zfr6KrD23X2fubXT+zL2Kzp+599D5Mw9nPn3m3kPnz9x76PyZew+dP3PvofNn7j109syPzXvo/Jl7D50/c++h82fuPXT+zMOZT5+599D5M/ceOn/m3kPnz9x76PyZew+dPvPkPXT+zL2Hzp+599D5M/ceOn/m4cynz9x76PyZew+dP3PvofNn7j10/sy9h06fefYeOn/m3kPnz9x76PyZew+dP/Nw5tNn7j10/sy9h86fuffQ+TP3Hjp/5t5Dp8+8eA+dP3PvofNn7j10/sy9h86feTjz6TP3HvoXZh7n77Xo+52Zew+dP3PvofNn7j10/sy9h06feXgPnT9z76HzZ+49dP7MvYfOn3k48+kz9x46f+beQ+fP3Hvo/Jl7D50/c++h02e+ew+dP3PvofNn7j10/sy9h86feTjz6TP3Hjp/5t5D58/ce+j8mXsPnT9z76HTZ169h86fuffQ+TP3Hjp/5t5D5888nPn0mXsPnT9z76HzZ+49dP7MvYfOn7n30Okzb95D58/8uvfQnm8zb9vx4OlHfy2rXfdqOXSM170tDh1jOMYRY7zunW7oGK97TRs6xuvevIaO8bqXqaFjvO79aOQYj+teeYaO0VvMkDF6ixkyRm8xQ8YYjnHEGL3FDBmjt5ghY/QWM2SM3mKGjNFbzIgxdm8xQ8boLWbIGL3FPDfG378Z7N5ihowxHOOIMXqLGTJGbzFDxugtZsgYvcUMGaO3mAFj7Ju3mCFj9BYzZIzeYoaM0VvMkDGGYxwxRm8xQ8boLWbIGL3FDBnjZW8xW719i0fK8dPTH6O57M2k7OeGRXr0dM7bcX6P7dE+ppRv/p1SSw+3d0vn9qbP7U13v+x8rvqRa/768I+g6bJ3pFWDXva2tmrQy94bVw162RvsqkHDoGsFveytftWgl/WFVYNeVjpWDXpZc1k1qFK0VtCsFC0WVClaLKhStFhQpWixoGHQtYIqRYsFVYoWC6oULRZUKVosqFK0VtCiFC0WVClaLKhStFhQpWixoGHQtYIqRYsFVYoWC6oULRZUKVosqFK0VtBQihYLqhQtFlQpWiyoUrRY0DDoWkGVosWCKkWLBVWKFguqFC0WVClaK+iuFC0WVClaLKhStFhQpWixoGHQFwdtOW5/dss17jQSf/iN9Bx+I4nm9Y16vzUq6V4j1YXfSEjBN6raCL+R3MFvpGDwG4kS/EZhI/r9qOoM/EY6A7+RzsBvpDPwG+kM+HNd0xn4jXQGfiOdgd9IZ+A3ChvhG+kM/EY6w8sbpX57+u0f651GOgP+Dtt0Bn4jnQHf6NAZ+I10Bn4jnQF/9j50Bn6jsBG+kc7Ab6Qz8BvpDPxGOgO/kc6Ab9R1Bn4jnQH/bqLrDHgL6joDv1HYCN9IZ+A30hn4jXQG/tlbZ+A30hngjdq26Qz8RjoDv5HOwG+kM/AbhY3wjXQGfiOdAf5u4q2RzgC3oLdGOgO/kc6Ab5R0Bn4jnYHfSGfAn72TzsBvFDbCN9IZ+I10Bn4jnYHfSGfgN9IZ8I2yzsBvpDPg301knQFvQVln4DcKG+Eb6Qz8RjoDv5HOwD976wz8RjoDvlHRGfiNdAZ+I52B30hn4DcKG+Eb6Qz8RjoD/t1E0RnwFlR0Bn4jnQHfKHQGfiOdgd9IZ8CfvUNn4DcKG+Eb6Qz8RjoDv5HOwG+kM/Ab6Qz4RrvOwG+kM+DfTew6A96Cdp2B3yhshG+kM/Ab6Qz8RjoD/+ytM/Ab6Qz4RlVn4DfSGfiNdAZ+I52B3yhshG+kM/Ab6Qz4dxNVZ8BbUNUZ+I10BnyjpjPwG+kM/EY6A/7s3XQGfqOwEb6RzsBvpDPwG+kM/EY6A7+RzoBvdOgM/EY6A/7dxKEz4C3o0Bn4jcJG+EY6A7+RzsBvpDPwz946A7+RzoBv1HUGfiOdgd9IZ+A30hn4jcJG+EY6A7+RzoB/N9F1BrwFdZ2B30hnoDdKm87Ab6Qz8BvpDPSzd9p0Bn6jsBG+kc7Ab6Qz8BvpDPxGOgO/kc6Ab5R0Bn4jnYH+buLtT7MR3YKSzsBvFDbCN9IZ+I10Bn4jnYF/9tYZ+I10BnyjrDPwG+kM/EY6A7+RzsBvFDbCN9IZ+I10Bvy7iawz4C0o6wz8RjoDvlHRGfiNdAZ+I50Bf/YuOgO/UdgI30hn4DfSGfiNdAZ+I52B30hnwDcKnYHfSGfAv5sInQFvQaEz8BuFjfCNdAZ+I52B30hn4J+9dQZ+I50B32jXGfiNdAZ+I52B30hn4DcKG+Eb6Qz8RjoD/t3ErjPgLWjXGfiNdAZ8o6oz8BvpDPxGOgP+7F11Bn6jsBG+kc7Ab6Qz8BvpDPxGOgO/kc6Ab9R0Bn4jnQH/bqLpDHgLajoDv1HYCN9IZ+A30hn4jXQG/tlbZ+A30hnwjQ6dgd9IZ+A30hn4jXQGfqOwEb6RzsBvpDPg300cOgPegg6dgd9IZ8A36joDv5HOwG+kM+DP3l1n4DcKG+Eb6Qz8RjoDv5HOwG+kM/Ab6Qz0RnnTGfiNdAb6u4m86Qx0C8qbzsBvFDbCN9IZ+I10Bn4jnYF/9tYZ+I10BnyjpDPwG+kM/EY6A7+RzsBvFDbCN9IZ+I10Bvy7iaQz4C0o6Qz8RjoDvlHWGfiNdAZ+I50Bf/bOOgO/UdgI30hn4DfSGfiNdAZ+I52B30hnwDcqOgO/kc6AfzdRdAa8BRWdgd8obIRvpDPwG+kM/EY6A//srTPwG+kM+EahM/Ab6Qz8RjoDv5HOwG8UNsI30hn4jXQG/LuJ0BnwFhQ6A7+RzoBvtOsM/EY6A7+RzoA/e+86A79R2AjfSGfgN9IZ+I10Bn4jnYHfSGfAN6o6A7+RzoB/N1F1BrwFVZ2B3yhshG+kM/Ab6Qz8Rv/P3hslOa4jUbJbIoAACbxlPZv926j6JiHWJLOYWRVSRIDeX9esUTLJT4jCcUhMPIP/vTeewX9GeAb3GW14Bv8Z4Rn8Z4Rn8J8RnsF/RkJG7jPCM/jPCM/g/mxiwzO4d0EbnsF/RngG9xk1PIP/jPAM/jPCM7jfezc8g/+MhIzcZ4Rn8J8RnsF/RngG/xnhGfxnhGdwn1HHM/jPCM/g/myi4xncu6COZ/CfkZCR+4zwDP4zwjP4zwjP4H/vjWfwnxGewXtGZcEz+M8Iz+A/IzyD/4zwDP4zEjJynxGewX9GeAbvZxNlwTN4d0FlwTP4zwjP4D6jhGfwnxGewX9GeAb3e++EZ/CfkZCR+4zwDP4zwjP4zwjP4D8jPIP/jPAM7jPKeAb/GeEZ3J9NZDyDexeU8Qz+MxIycp8RnsF/RngG/xnhGfzvvfEM/jPCM7jPqOAZ/GeEZ/CfEZ7Bf0Z4Bv8ZCRm5zwjP4D8jPIP7s4mCZ3DvggqewX9GeAb3GQmewX9GeAb/GeEZ3O+9Bc/gPyMhI/cZ4Rn8Z4Rn8J8RnsF/RngG/xnhGdxnVPEM/jPCM7g/m6h4BvcuqOIZ/GckZOQ+IzyD/4zwDP4zwjP433vjGfxnhGdwn9GKZ/CfEZ7Bf0Z4Bv8Z4Rn8ZyRk5D4jPIP/jPAM7s8mVjyDexe04hn8Z4RncJ/RhmfwnxGewX9GeAb3e+8Nz+A/IyEj9xnhGfxnhGfwnxGewX9GeAb/GeEZ3GfU8Az+M8IzuD+baHgG9y6o4Rn8ZyRk5D4jPIP/jPAM/jPCM/jfe+MZ/O+98Qzur3Udz+A/IzyD/4zwDP4zwjP4z0jIyPveu+MZ3O+9O57B/7UOz+A/IzyD/4zwDN4zkgXP4D8jPIP3vbcseAb/GeEZ/GckZOQ+IzyDeUYyVj/+czvJCM/gPyM8w7cyKsu+Opctq2a09iV9rF57+i2jk6edZX+RLa/5JFCkxGSBYjDmCjShOyYLFDcyWaCIlMkCxbpMFqgQ6FyB4nMmCxT5M1mgmKLJAsUUTRYopmiuQDOmaLJAMUWTBYopmixQTNFkgQqBzhUopmiyQDFFkwWKKZosUEzRZIFiiuYKtGCKJgsUUzRZoJiiyQLFFE0WqBDoXIFiiiYLFFM0WaCYoskCxRRNFiimaK5ABVM0WaCYoskCxRRZB3p5OyxB/vjPSMjIfUYoGvuMLm61JFgX/xkhUvxnhBvxnxG6w31GFYPhPyOkhP+M8Azu+1HFM/jPSMjIfUZ4Bv8Z4Rn8Z4Rn8L+vwzP4zwjP4D6jFc/gPyM8g/+M8Az+M8Iz+M9IyMg6o4s/rft4LWTkvcOueAb/GeEZ/GeEZ/CfEZ7BfUYbnsH93nvDM/jPCM/gPyM8g/+MhIzcZ4Rn8J8RnsF/RngG/xnhGfxnhGdwfzbR8AzuXVDDM/jPCM/gPyM8g/+MhIzcZ4RncL/3bngG/xnhGfxnhGfwnxGewX1GHc/gPyM8g/+M8Az+M8Iz+M9IyMj72UTHM7h3QR3P4D8jPIP/jPAM/jPCM3jPqC54Bu9777rgGfxnhGfwnxGewX9GQkbuM8Iz+M8Iz+A/IzyD/4zwDP4zwjN4P5uoCc/g3gUlPIP/jPAM/jPCM/jPSMjIfUZ4Bvd774Rn8J8RnsF/RngG/xnhGdxnlPEM/jPCM/jPCM/gPyM8g/+MhIy8n01kPIN7F5TxDP4zwjP4zwjP4D8jPIP7jAqewf3eu+AZ/GeEZ/CfEZ7Bf0ZCRu4zwjP4zwjP4D8jPIP/jPAM/jPCM7g/mxA8g3sXJHgG/xnhGfxnhGfwn5GQkfuM8Azu996CZ/CfEZ7Bf0Z4Bv8Z4RncZ1TxDP4zwjP4zwjP4D8jPIP/jISMvJ9NVDyDexdU8Qz+M8Iz+M8Iz+A/IzyD+4xWPIP7vfeKZ/CfEZ7Bf0Z4Bv8ZCRm5zwjP4D8jPIP/jPAM/jPCM/jPCM/g/mxiwzO4d0EbnsF/RngG/xnhGfxnJGTkPiM8g/u994Zn8J8RnsF/RngG/xnhGdxn1PAM/jPCM/jPCM/gPyM8g/+MhIy8n000PIN7F9TwDP4zwjP4zwjP4D8jPIP7jDqewf3eu+MZ/GeEZ/CfEZ7Bf0ZCRu4zwjP4zwjP4D8jPIP/jPAM/jPCM3g/m1gXPIN3F7QueAb/GeEZ/GeEZ/CfkZCR+4zwDN733uuCZ/CfEZ7Bf0Z4Bv8Z4RncZ5TwDP4zwjP4zwjP4D8jPIP/jISMvJ9NJDyDexeU8Az+M8Iz+M8Iz+A/IzyD+4wynsH93jvjGfxnhGfwnxGewX9GQkbuM8Iz+M8Iz+A/IzyD/4zwDP4zwjO4P5soeAb3LqjgGfxnhGfwnxGewX9GQkbuM8IzuN97FzyD/4zwDP4zwjP4zwjP4D4jwTP4zwjP4D8jPMP/5z4jPIP/jISMvJ9NCJ7B/n104YIEz+A/IzyD/4zwDP4zwjO4z6jiGdzvvSuewX9GeAb/GeEZ/GckZOQ+IzyD/4zwDP4zwjP4zwjP4D8jPIP7s4kVz+DeBa14Bv8Z4Rn8Z4Rn8J+RkJH7jPAM7vfeK57Bf0Z4Bv8Z4Rn8Z4RncJ/RhmfwnxGewX9GeAb/GeEZ/GckZOT9bGLDM7h3QRuewX9GeAb/GeEZ/GeEZ3CfUcMzuN97NzyD/4zwDP4zwjP4z0jIyH1GeAb/GeEZ/GeEZ/CfEZ7Bf0Z4BvdnEx3P4N4FdTyD/4zwDP4zwjP4z0jIyH1GeAb3e++OZ/CfEZ7Bf0Z4Bv8Z4Rm8Z7QteAb/GeEZ/GeEZ/CfEZ7Bf0ZCRs7PJrYFz+DdBW0LnsF/RngG/xnhGfxnhGdwn1HCM7jfeyc8g/+M8Az+M8Iz+M9IyMh9RngG/xnhGfxnhGfwnxGewX9GeAb3ZxMZz+DeBWU8g/+M8Az+M8Iz+M9IyMh9RngG93vvjGfwnxGewX9GeAb/GeEZ3GdU8Az+M8Iz+M8Iz+A/IzyD/4yEjLyfTRQ8g3sXVPAM/jPCM/jPCM/gPyM8g/uMBM/gfu8teAb/GeEZ/GeEZ/CfkZCR+4zwDP4zwjP4zwjP4D8jPIP/jPAM7s8mKp7BvQuqeAb/GeEZ/GeEZ/CfkZCR+4zwDO733hXP4D8jPIP/jPAM/jPCM7jPaMUz+M8Iz+A/IzyD/4zwDP4zEjLyfjax4hncu6AVz+A/IzyD/4zwDP4zwjO4z2jDM7jfe294Bv8Z4Rn8Z4Rn8J+RkJH7jPAM/jPCM/jPCM/gPyM8g/+M8AzuzyYansG9C2p4Bv8Z4Rn8Z4Rn8J+RkJH7jPAM7vfeDc/gPyM8g/+M8Az+M8IzuM+o4xn8Z4Rn8J8RnsF/RngG/xkJGXk/m+h4BvcuqOMZ/GeEZ/CfEZ7Bf0Z4Bu8ZtQXP4H3v3RY8g/+M8Az+M8Iz+M9IyMh9RngG/xnhGfxnhGfwnxGewX9GeAbvZxMt4Rncu6CEZ/CfEZ7Bf0Z4Bv8ZCRm5zwjP4H7vnfAM/jPCM/jPCM/gPyM8g/uMMp7Bf0Z4Bv8Z4Rn8Z4Rn8J+RkJH3s4mMZ3DvgjKewX9GeAb/GeEZ/GeEZ3CfUcEzuN97FzyD/4zwDP4zwjP4z0jIyH1GeAb/GeEZ/GeEZ/CfEZ7Bf0Z4BvdnE4JncO+CBM/gPyM8g/+M8Az+MxIycp8RnsH93lvwDP4zwjP4zwjP4D8jPIP7jCqewX9GeAb/GeEZ/GeEZ/CfkZCR97OJimdw74IqnsF/RngG/xnhGfxnhGdwn9GKZ3C/917xDP4zwjP4zwjP4D8jISP3GeEZ/GeEZ/CfEZ7Bf0Z4Bv8Z4Rncn01seAb3LmjDM/jPCM/gPyM8g/+MhIzcZ4RncL/33vAM/vfeeAb/1zo8g/+M8AzuM2p4Bv8Z4Rn8Z4RncL/3bngG93vvJmTk/lqHZ/CfEZ7Bf0Z4Bv8Z4Rn8Z4RncL/37ngG/xnhGfxnhGfwnxGewTwjGasf/7mdZCRk5D4jPMP3Muppf42y9N9Wf4BEBiiBpLErgaRWK4Gk+6qA7AsFVQkkLfJbIB9PdoAs7WJ1L21/Jl2W3/ZKnxeX0vaCUko/LN7OFi95G8GUclz8kSeNc648aadz5SnkOVWetN5Qeaa6P4/ySO8kT8r3XHniAObKExURK88+8syp/HlxXvNoq2u5WJx6Saesx6TgWpiU/y1elj2YvOSLxXXbE6+9H1/ef0OV8E4MlfpQ4eAYKvWhQgQyVP8NlaxjqNb+b0OFjWSo1IdKGCqG6tfiZ/nPqcnnSpeQrUzK9yYFjcukfG9SEMRMyn8pjqeRS25/XpzK2NOk0tPJWOGpGasXjBVSm7H6+VjVtC9OVfI/tbWMAWcCbScQXc4E2k4gbp0J/IsJXMc3FurvVfTnE4iIZwJtJ1CYwHknsG5jAq9Ody6/iJWx9kzK/xYrfr0hI/gZKvWh4iyAofpvqPS+3pA5CWCo1IeKcwCG6n+Lr863C76eSfnepODVmZTvTQr+m0n5uX28+nJDQWozVi8YK2GsGKsfj5XieXHBgDOBthOILmcCbScQt84E/sUE6n1joSDimUDbCcTazzuBW9nvj5+39V87q2DtmZTvTQrWnknR3qwLgp+hUh8q9D5DpT5UwlAxVMo9TfD1DJX6UKHgQw1V3mQMVbsySqp3LhZUOZPyv8WKv20Q7DdDpT5UCG2GSnuoKu6bofpvqPR+MFPR5AyV+lChyRmq/y2++sVExX0zKd+bFGFSmJRvTQqWmkn5L0XNn8tUPDVj9YKxQmozVj8fK8WvClQMOBNoO4HocibQdAJX3DoT+BcTqPc1mBURzwTaTiDWfuIJ1Lxz8Yq1Z1L+t1jx6w2rMFQMlfZQcRbAUP03VHpfb1g5CWCo1IeKcwCG6n+Lr863V3w9k/K9ScGrMynfmpQN/82k/Nw+Xn25YUNqM1YvGCtMNWP187FSPC/eMOBMoO0EChPIBJpOIG6dCfyLCdT7xsKGiGcCbScQaz/vBKrej3bD2jMp35sUrD2Tor1Zbwh+hkp9qND7DJX6UCH3GSrtntbw9QyV+lAJQ/WdoVqXIWfWlH9b/QESk6wE8rZCtJb9sdu6pIvVdRnva1mea4uc8WhpXBIfDz1Wl372Gltuh0C3y9Vpv3K1XJ+BPh7kZPWv++9/rN56LxeryzOZ8rzM5eXsJZZUnvZ0/fPiVMpTXxyf8+niRfZnkZbDdfyx+GNgb+tPGdh/GNhtjFXe6sXiX0ZtT7Gl9V8H9rYal4GNObC3tckvG9iyjH1YWQ7P+nwEU6pjk5fS2hIjezGy/bau+mcju46H7u1iZOXJ4/ESD7W3pB36bV2uJfTbuk5L6Ld1gT+C3pbxMbSVqy1cyUPBiaSLTyE+4bowgt8YwT5um9RrvRjBugxlXNNSzt73t7WMltAxkt+62LYh1ZZlvbrapnVcbXPZuNpeXW2RjG+dwQ/qtzVl6/MNt9bl6nK7bbv96lt/PvaaT6lLHXccSdJ+W/6B/ba+xxB7W5bbOgtb7Le1FrbYb+stbLHf1lzYYhewfwd7G8civR2+BHqKfW11fyJr255b03Vnftuybsj8tl3dkPltu6khc5rp+5lTS9/OPNFJ38+cQqrPvI+jyLXn7TNz2uj7mVNF389cYP525vTQ9zOnh76fOT30/czpoe9nTg99O/NMD30/c3ro+5nTQ9/PnB76fuYC87czp4e+nzk99P3M6aHvZ04PfT9zeujbmRd66PuZ00Pfz5we+n7m9ND3MxeYv505PfT9zOmh72dOD30/c3ro+5nTQ9/OXOih72dOD30/c3ro+5nTQ9/PXGD+dub00Pczp4e+nzk99P3M6aHvZ04PfTvzSg99P3N66PuZ00Pfz5we+n7mAvO3M6eHvp85PfQFzGXc16LXE+b00Pczp4e+nzk99O3MV3ro+5nTQ9/PnB76fub00PczF5i/nTk99P3M6aHvZ04PfT9zeuj7mdND3858o4e+nzk99P3M6aHvZ04PfT9zgfnbmdND38+cHvp+5vTQ9zOnh76fOT307cwbPfT9zOmh72dOD30/c3ro+5kLzN/OnB76fub00Pczp4e+nzk99P3M6aFvZ97poe9nTg99P/P79tCed+bb0i5WX/0sq9+3WqpiFDBqYLxvAVTFeN9Op4rxvjVNFeN9m5cqxvuWKUWMablvP1LFeN/Ko4qRFqOCkRajglHAqIGRFqOCkRajgpEWo4KRFqOCkRajgTHRYlQw0mJUMNJiVDDSYr6H8Y8ngykJGDUw0mJUMNJiVDDSYlQw0mJUMNJiNDBmWowKRlqMCkZajApGWowKRgGjBkZajApGWowKRlqMCkZajArG27aYZd1f4q8P2t9W/4em3LaZlDomTNLV6pyXNl7jdjWPj3OC3X8/fE66nN4ljelNz+lNp087j1Fvec3HxR+B3rYjzRrobdvarIHetjfOGqgQ6FyB3rZLzxrobVv9rIHe1i/MGuhtTcesgd7WuUwaqGCKJgsUUzRZoJiiyQLFFE0WqBDoXIFiiiYLFFM0WaCYoskCxRRNFiimaK5AK6ZoskAxRZMFiimaLFBM0WSBCoHOFSimaLJAMUWTBYopmixQTNFkgWKK5gp0xRRNFiimaLJAMUWTBYopmixQIdC5AsUUTRYopmiyQDFFkwWKKZosUEzRXIFumKLJAsUUTRYopmiyQDFFkwUqBDpXoJgi60C3LPtjb3mVk4yQP/4zwuf4zwhFY59R73tGJZ1lhHVxn1FDpPjPCDfiPyN0h/+MMBj+MxIycp8RnsF9P2p4Bv8Z4Rn8Z4Rn8J8RnsF9Rh3P4H5f1/EM/jPCM/jPCM/gPyMhI/cZ4Rn8Z4Rn8J8RnsE8o8fFbM/o8Z45yQjP4L/D4hm8Z5QXPIP/jPAM/jPCM/jPCM/gfe+dFyEj9xnhGfxnhGfwnxGewX9GeAb/GeEZ3GeU8Az+M8Iz+M8Iz+D9bCInPIN7F5SEjNxnhGfwnxGewX9GeAb/GeEZ/O+98QzuM8p4Bv8Z4Rn8Z4Rn8J8RnsF/RkJG7jPCM/jPCM/gPyM8g/uziYxncO+CMp7BfUYFz+A/IzyD/4zwDP4zwjO433sXISP3GeEZ/GeEZ/CfEZ7Bf0Z4Bv8Z4RncZyR4Bv8Z4Rn8Z4RncH82IXgG9y5IhIzcZ4Rn8J8RnsF/RngG/xnhGfzvvfEM7jOqeAb/GeEZ/GeEZ/CfEZ7Bf0ZCRu4zwjP4zwjP4D8jPIP7s4mKZ3DvgiqewX1GK57Bf0Z4Bv8Z4Rn8Z4RncL/3XoWM3GeEZ/CfEZ7Bf0Z4Bv8Z4Rn8Z4RncJ/RhmfwnxGewX9GeAb3ZxMbnsG9C9qEjNxnhGfwnxGewX9GeAb/GeEZ/O+98QzuM2p4Bv8Z4Rn8Z4Rn8J8RnsF/RkJG7jPCM/jPCM/gPyM8g/uziYZncO+CGp7BfUYdz+A/IzyD/4zwDP4zwjO433t3ISP3GeEZ/GeEZ/CfEZ7Bf0Z4Bv8Z4Rm8Z1QWPIP/jPAM/jPCM3g/mygLnsG7CyqLkJH7jPAM/jPCM/jPCM/gPyM8g/+9N57BfUYJz+A/IzyD/4zwDP4zwjP4z0jIyH1GeAb/GeEZ/GeEZ3B/NpHwDO5dUMIzuM8o4xn8Z4Rn8J8RnsF/RngG93vvLGTkPiM8g/+M8Az+M8Iz+M8Iz+A/IzyD+4wKnsF/RngG/xnhGdyfTRQ8g3sXVISM3GeEZ/CfEZ7Bf0Z4Bv8Z4Rn8773xDO4zEjyD/4zwDP4zwjP4zwjP4D8jISP3GeEZ/GeEZ/CfEZ7B/dmE4BncuyDBM7jPqOIZ/GeEZ/CfEZ7Bf0Z4Bvd77ypk5D4jPIP/jPAM/jPCM/jPCM/gPyM8g/uMVjyD/4zwDP4zwjO4P5tY8QzuXdAqZOQ+IzyD/4zwDP4zwjP4zwjP4H/vjWdwn9GGZ/CfEZ7Bf0Z4Bv8Z4Rn8ZyRk5D4jPIP/jPAM/jPCM7g/m9jwDO5d0IZncJ9RwzP4zwjP4D8jPIP/jPAM7vfeTcjIfUZ4Bv8Z4Rn8Z4Rn8J8RnsF/RngG9xl1PIP/jPAM/jPCM7g/m+h4BvcuqAsZuc8Iz+A/IzyD/4zwDP4zwjP433vjGbxnJAuewX9GeAb/GeEZ/GeEZ/CfkZCR+4zwDP4zwjP4zwjP4P1sQhY8g3cXJAuewX1GCc/gPyM8g/+M8Az+M8IzuN97JyEj9xnhGfxnhGfwnxGewX9GeAb/GeEZ3GeU8Qz+M8Iz+M8Iz+D+bCLjGdy7oCxk5D4jPIP/jPAM/jPCM/jPCM/gf++NZ3CfUcEz+M8Iz+A/IzyD/4zwDP4zEjJynxGewX9GeAb/GeEZ3J9NFDyDexdU8AzuMxI8g/+M8Az+M8Iz+M8Iz+B+7y1CRu4zwjP4zwjP4D8jPIP/jPAM/jPCM7jPqOIZ/GeEZ/CfEZ7B/dlExTO4d0FVyMh9RngG/xnhGfxnhGfwnxGewf/eG8/gPqMVz+A/IzyD/4zwDP4zwjP4z0jIyH1GeAb/GeEZ/GeEZ3B/NrHiGdy7oBXP4D6jDc/gPyM8g/+M8Az+M8IzuN97b0JG7jPCM/jPCM/gPyM8g/+M8Az+M8IzuM+o4Rn8Z4Rn8J8RnsH92UTDM7h3QU3IyH1GeAb/GeEZ/GeEZ/CfEZ7B/94bz+A+o45n8J8RnsF/RngG/xnhGfxnJGTkPiM8g/+M8Az+M8IzuD+b6HgG9y6o4xm8Z1QXPIP/jPAM/jPCM/jPCM/gfe9dFyEj9xnhGfxnhGfwnxGewX9GeAb/GeEZ3GeU8Az+M8Iz+M8Iz+D9bKImPIN7F5SEjNxnhGfwnxGewX9GeAb/GeEZ/O+98QzuM8p4Bv8Z4Rn8Z4Rn8J8RnsF/RkJG7jPCM/jPCM/gPyM8g/uziYxncO+CMp7BfUYFz+A/IzyD/4zwDP4zwjO433sXISP3GeEZ/GeEZ/CfEZ7Bf0Z4Bv8Z4RncZyR4Bv8Z4Rn8Z4RncH82IXgG9y5IhIzcZ4Rn8J8RnsF/RngG/xnhGfzvvfEM7jOqeAb/GeEZ/GeEZ/CfEZ7Bf0ZCRu4zwjP4zwjP4D8jPIP7s4mKZ3DvgiqewX1GK57Bf0Z4Bv8Z4Rn8Z4RncL/3XoWM3GeEZ/CfEZ7Bf0Z4Bv8Z4Rn8Z4RncJ/RhmfwnxGewX9GeAb3ZxMbnsG9C9qEjNxnhGfwnxGewX9GeAb/GeEZ/O+98QzuM2p4Bv8Z4Rn8Z4Rn8J8RnsF/RkJG7jPCM/jPCM/gPyM8g/uziYZncO+CGp7BfUYdz+A/IzyD/4zwDP4zwjO433t3ISP3GeEZ/GeEZ/CfEZ7Bf0Z4Bv8Z4Rm8Z7QueAb/GeEZ/GeEZ/B+NrEueAbvLmhdhIzcZ4Rn8J8RnsF/RngG/xnhGfzvvfEM7vfeCc/g/lqX8Az+M8Iz+M8Iz+A/IyEj9xnhGdzvvROewf/eG8/g/1qHZ/CfEZ7BfUYZz+A/IzyD/4zwDO733hnP4D8jISP3GeEZ/GeEZzDPSMbqx39uJxnhGfxnhGf4VkZl2VfnsmXVjNa+pI/Va0+/ZXTytLPsL7LlNZ8EipSYK9CCwZgsUHTHZIHiRiYLFJEyWaBCoHMFiqKZLFB8zmSBIn8mCxRTNFmgmKK5AhVM0WSBYoomCxRTNFmgmKLJAhUCnStQTNFkgWKKJgsUUzRZoJiiyQLFFM0VaMUUTRYopmiyQDFFkwWKKZosUCHQuQLFFE0WKKZoskAxRZMFiimaLFBM0VyBrpiiyQLFFE0WKKZoskAxRdaBXt4OaxUycp8RPsd/Riga+4wubrW0Yl38Z4RI8Z8RbsR9Rhu6w39GGAz/GSEl/GeEZ3DfjzYhI/cZ4Rn8Z4Rn8J8RnsF/RngG//s6PIP7jBqewX9GeAb/GeEZ/GeEZ/CfkZCR+4zwDOYZXf1p3YZncN9hG57Bf0Z4Bv8Z4RncZ9TxDP4zwjO433t3PIP/jPAM/jMSMnKfEZ7Bf0Z4Bv8Z4Rn8Z4Rn8J8RnsF7RtuCZ/B+NrEteAbvLmhb8Az+M8Iz+M9IyMh9RngG/xnhGfzvvfEM/jPCM/jPCM/gPqOEZ/CfEZ7Bf0Z4Bv8Z4Rn8ZyRk5D4jPIP7s4mEZ3DvghKewX9GeAb/GeEZ3GeU8Qz+M8IzuN97ZzyD/4zwDP4zEjJynxGewX9GeAb/GeEZ/GeEZ/CfEZ7BfUYFz+D+bKLgGdy7oIJn8J8RnsF/RkJG7jPCM/jPCM/gf++NZ/CfEZ7Bf0Z4BvcZCZ7Bf0Z4Bv8Z4Rn8Z4Rn8J+RkJH7jPAM7s8mBM/g3gUJnsF/RngG/xnhGdxnVPEM/jPCM7jfe1c8g/+M8Az+MxIycp8RnsF/RngG/xnhGfxnhGfwnxGewX1GK57B/dnEimdw74JWPIP/jPAM/jMSMnKfEZ7Bf0Z4Bv97bzyD/4zwDP4zwjO4z2jDM/jPCM/gPyM8g/+M8Az+MxIycp8RnsH92cSGZ3DvgjY8g/+M8Az+M8IzuM+o4Rn8Z4RncL/3bngG/xnhGfxnJGTkPiM8g/+M8Az+M8Iz+M8Iz+A/IzyD+4w6nsH92UTHM7h3QR3P4D8jPIP/jISM3GeEZ/CfEZ7B/94bz+A/IzyD/4zwDN4zaguewX9GeAb/GeEZ/GeEZ/CfkZCR+4zwDN7PJtqCZ/DugtqCZ/CfEZ7Bf0Z4BvcZJTyD/4zwDO733gnP4D8jPIP/jISM3GeEZ/CfEZ7Bf0Z4Bv8Z4Rn8Z4RncJ9RxjO4P5vIeAb3LijjGfxnhGfwn5GQkfuM8Az+M8Iz+N974xn8Z4Rn8J8RnsF9RgXP4D8jPIP/jPAM/jPCM/jPSMjIfUZ4BvdnEwXP4N4FFTyD/4zwDP4zwjO4z0jwDP4zwjO433sLnsF/RngG/xkJGbnPCM/gPyM8g/+M8Az+M8Iz+M8Iz+A+o4pncH82UfEM7l1QxTP4zwjP4D8jISP3GeEZ/GeEZ/C/98Yz+M8Iz+A/IzyD+4xWPIP/jPAM/jPCM/jPCM/gPyMhI/cZ4Rncn02seAb3LmjFM/jPCM/gPyM8g/uMNjyD/4zwDO733huewX9GeAb/GQkZuc8Iz+A/IzyD/4zwDP4zwjP4zwjP4D6jhmdwfzbR8AzuXVDDM/jPCM/gPyMhI/cZ4Rn8Z4Rn8L/3xjP4zwjP4D8jPIP7jDqewX9GeAb/GeEZ/GeEZ/CfkZCR+4zwDO7PJjqewb0L6ngG/xnhGfxnhGfwnlFf8Az+M8IzeN979wXP4D8jPIP/jISM3GeEZ/CfEZ7Bf0Z4Bv8Z4Rn8Z4RncJ9RwjN4P5voCc/g3gUlPIP/jPAM/jMSMnKfEZ7Bf0Z4Bv97bzyD/4zwDP4zwjO4zyjjGfxnhGfwnxGewX9GeAb/GQkZuc8Iz+D+bCLjGdy7oIxn8J8RnsF/RngG9xkVPIP/jPAM7vfeBc/gPyM8g/+MhIzcZ4Rn8J8RnsF/RngG/xnhGfxnhGdwn5HgGdyfTQiewb0LEjyD/4zwDP4zEjJynxGewX9GeAb/e288g/+M8Az+M8IzuM+o4hn8Z4Rn8J8RnsF/RngG/xkJGbnPCM/g/myi4hncu6CKZ/CfEZ7Bf0Z4BvcZrXgG/xnhGdzvvVc8g/+M8Az+MxIycp8RnsF/RngG/xnhGfxnhGfwnxGewX1GG57B/dnEhmdw74I2PIP/jPAM/jMSMnKfEZ7Bf0Z4Bv97bzyD/4zwDP4zwjO4z6jhGfxnhGfwnxGewX9GeAb/GQkZuc8Iz+D+bKLhGdy7oIZn8J8RnsF/RngG9xl1PIP/jPAM7vfeHc/gPyM8g/+MhIzcZ4Rn8J8RnsF/RngG/xnhGfxnhGdwnlFfFjyD87OJR0Z4Bucu6JERnsF/RngG/xkJGbnPCM/gPyM8g/+9N57Bf0Z4Bv8Z4RncZ5TwDP4zwjP4zwjP4D8jPIP/jISM3GeEZ3B/NpHwDO5dUMIz+M8Iz+A/IzyD+4wynsF/RngG93vvjGfwnxGewX9GQkbuM8Iz+M8Iz+A/IzyD/4zwDP4zwjO4z6jgGdyfTRQ8g3sXVPAM/jPCM/jPSMjIfUZ4Bv8Z4Rn8773xDP4zwjP4zwjP4D4jwTP4zwjP4D8jPIP/jPAM/jMSMnKfEZ7B/dmE4BncuyDBM/jPCM/gPyM8g/uMKp7Bf0Z4Bvd774pn8J8RnsF/RkJG7jPCM/jPCM/gPyM8g/+M8Az+M8IzuM9oxTO4P5tY8QzuXdCKZ/CfEZ7Bf0ZCRu4zwjP4zwjP4H/vjWfwnxGewX9GeAb3GW14Bv8Z4Rn8Z4Rn8J8RnsF/RkJG7jPCM7g/m9jwDO5d0IZn8J8RnsF/RngG9xk1PIP/jPAM7vfeDc/gPyM8g/+MhIzcZ4Rn8J8RnsF/RngG/xnhGfxnhGdwn1HHM7g/m+h4BvcuqOMZ/GeEZ/CfkZCR+4zwDP4zwjP433vjGfzvvfEM/q91eAbvGaUFz+A/IzyD/4zwDP4zwjN433unRcjI+d47LXgG/9c6PIP/jPAM/jPCM/jPCM/gPqOEZ3C/9054Bv8Z4Rn8Z4Rn8J+RkJF1RjJWP/5zO8kIz+A/IzzD9zLqaX+NsvTfVn+ARAYogaSxK4GkVuuAzHRfJZAUVCWQtMhvgXw82QGytIvVvbT9mXRZftsrfV5cStsLSin9sHg7W7zkbQRTynHxR540zrnyFPKcKk+a7Fx50npD5Znq/jxK2vpJnpTvufLEAcyVJyoiVp595JlT+fPivObRVtdysTj1kk5Z75NScC1Myv8WL8seTF7yxeK67YnX3o8v72Oo8E4MlfpQ4eAYKvWhQgQyVP8NlaxjqNb+b0MlDBVDpT1UKFGG6n+Ln+U/pyYnlQ7ZyqR8b1LQuEzK9yYFQcyk/JfieBq55PbnxY8LzB55Kj2djBWemrHSHytBajNWPx+rmvbFqUr+p7YmGHAm0HYC0eVMoO0E4taZwL+YwHV8Y6H+XkV/PoHCBDKBphOItZ94Aus2JvDqdOfyi1iCtWdS/rdY8esNguBnqNSHirMAhuq/odL7eoNwEsBQaQ9V5RyAofrf4qvz7YqvZ1K+Nyl4dSble5OC/2ZSfm4fr77cUIWxYqz0xwpTzVj9fKwUz4srBpwJtJ1AdDkTaDuBuHUm8C8mUO8bCxURzwSaTuCKtZ93Arey3x8/b+u/dtYVa8+kfG9SsPZMivZmfUXwM1TqQyUMFUOlPVTIfYZKvafh6xkq9aFCwYcaqrzJGKp2ZZRU71y8osqZlP8tVvxtw4r9Zqi0h2pDaDNU6kOF+2ao/hsqvR/MbGhyhkp9qNDkDNX/Fl/9YmITJoVJ+dakILSZlO9NCpaaSfkvRc2fy2x4asbqBWOF1Gasfj5Wil8V2DDgTKDpBDZ0ORNoO4G4dSbwLyZQ72swDRHPBNpOINZ+4gnUvHNxEyaFSfk/ul9vaAh+hkp9qDgLYKj+Gyq9rzc0TgIYKvWh4hyAofrf4qvz7YavZ1K+NSkdr86kfG9S8N9Mys/t49WXGzpSm7F6wVhhqhmrn4+V4nlxFyaQCTSdQHQ5E2g7gbh1JvAvJlDvGwsdEc8E2k4g1n7eCVS9H23H2jMp35mUvGDtmRTlzXpeEPwMlfpQofcZKvWhQu4zVMo9LS/CUDFU2kOFgv/WUK3LkDNryr+t/gCJSVYCeVshWsv+2G1d0sXquoz3tSzPtUXOeLQ0LomPhx6rSz97jS23Q6Db5eq0X7lars9AHw9ysnrrsq/eei8Xq8szmfK8zOXl7CWWVJ72dP3z4lTKU18cn/Pp4kX2Z5GWw3X8sfhjYG/rTxnYfxjYbYxV3urF4rQ9U2xp/deBva3GZWBDDmy6rU1+2cCWZezDynJ41ucjmFIdm7yU1pYY2auRva2r/tnIruOhe7sYWXnyeLzEQ+0taYd+W5drCf22rtMSugD9G9DbMj6GtnK1hSt5KDiRdPEpxCdcuq05/NEI9nHbpF7rxQjWZSjjmpZy9r6/rWW0hI6R/NbFtg2ptizr1dU2reNqm8vG1fbqaotkfOsMflC/rSlbn2+4tS5Xl9tt2+1X3/rzsdd8Sl3quONIkvbb8v+w59v6Hlvst3UWtthvay1ssd/WW9hiF7BbYL9tW7fFftu+/jPsbZxG9Xb47u0p9rXV/YmsbXs2gnVnftu6bsj8tvXUkDnl9O3MC830/cyppe9nTid9P3MKqT7zPk6A1563z8wF5m9nThV9P3N66PuZ00Pfz5we+n7m9NC3Mxd66PuZ00Pfz5we+n7m9ND3MxeYv505PfT9zOmh72dOD30/c3ro+5nTQ9/OvNJD38+cHvp+5vTQ9zOnh76fucD87czpoe9nTg99P3N66PuZ00Pfz5we+nbmKz30/czpoe9nTg99P3N66PuZC8zfzpwe+n7m9ND3M6eHvp85PfT9zOmhb2e+0UPfz5we+n7m9ND3M6eHvp+5wPztzOmh72dOD30/c3ro+5nTQ1/AXMZ9LXo9YU4PfTvzRg99P3N66PuZ00Pfz5we+n7mAvO3M6eHvp85PfT9zOmh72dOD30/c3ro25l3euj7mdND38+cHvp+5vTQ9zMXmL+dOT30/czpoe9nTg99P3N66PuZ00Pfzbws9ND3M6eHvp85PfT9zOmh72cuMH87c3ro+5nTQ9/PnB76fub00Pczp4e+nXm6bw/teWe+Le1i9cXX+Eu6b7VUxXjftqiK8b4FUBWjgFED431rmirG+zYvVYz3LVOqGO/bj1Qx3rfyaGLMtBgVjLQYFYy0GBWMtBgVjAJGDYy0GBWMtBgVjLQYFYy0GBWMtBgNjIUWo4KRFqOCkRbzPYx/PmAttBgVjAJGDYy0GBWMtBgVjLQYFYy0GBWMtBgNjEKLUcFIi1HBSItRwUiLUcEoYNTASItRwUiLUcFIi1HB6LnFPB5tx5i3tF1gTHVtO/S19gOYs9W5LzuY3Gt5ri5y9rSXZX+NssjhsUvaQXruMZFAVs9NJhRIz13mlSDLsqTxEtt6ATKXvJ/IZJE0Vud29rxbfv5oLNd8sXrrsq/eei8Xq8uT369nuq9dzp70JsvAVy8Wp+35adTSerF4GY+cltaPiz/GynO3Y6zCjpXnrvvSsXrw2F9iOuzQvrjsb30HIk2Ws8u+AFIHpOe++1qQ2wCZ8xXI/HjE8RrLxoXu6kLnuf/HGKsPkJ4NwA9Brm3fWqQttSuQZR0vsRzeFaWfuojHge/+2KU9NyJtVwB1IgVgynEiA2DJcZ1IAJhynKj/m3KcqPC+kqOMwptkW48cz/YCbRl79X7YUq1y2rxLOtvZl6U53mKWNDIv+WrXWEoZQ3h8zn+1xVwn6tJM7C0mVphYJjbUxE5kh5jYW0zsROKJib3FxGL4mNhYE4tLZWJjTSzWmokNNbEb5wNMbKyJ5SSGiY01sZx5MbGxJpYzLyY21sQKE8vEhppYzryY2FgTy5kXExtrYjnzYmL/YmLtftCycebFxMaaWM689Cc252089OE1nk8sM9g4xdKfQRk/5Shy+CnHF1fNtIzVSQ633Tl76F9/NWx/Hr/d0Wfb8+SMJ1KeeVnGO3/J5Zjn58V123Op/fAr17ZHz2HJbaPn1CFW9LKO6Nf+b9EL0d81ejx4qOhT3W88kVOTk70blniuPHGoc+WJYQyVZ259J1Jy+/NHbSrb8/Skp5PwkXX3Db9jyeYNv6Z9caqS/2lH3rFvzMl35gRVx5x8Z07wehPPyTqA1N/rxs/nRJgT5uQbc4IxfMGcjOv9Y07yxZxI77tkqMvxXrVnDy11/EUWWY83h97vCdgxhi/O8+o7T0nG+z5JaX/Oc93Gkd+65bM8MYZz5YkxnCtPJOBMecqC1wuVZ8v7s16brCd54t/myhNPNlee+Ky58hTyDJTn1rfdJ7TlNyJnj7z0ZYjspdez+NFJt44f+3Tr+JFVt44ftxUp/pbz/hofu7r87/Gjwu4cf8KchWpyfRwiP5xoPskTc3abt3M/iR/Rduv48XK3jl+IX+FPdErCh+lwRCzpcMTQxP26Xzm5TqNc5soThzJVnhkp8r08l/ZFnh8ckRE6HG/b6qXkcRE43CbtC47pWZBSfv7C4vy+lQ9Xsr9GOdyqr7fTM5fp7hgo+bauQMaPa4ocbob6xVAtqY5Prcd52zOj9Xx5beM36Mua83H5B3gBvA3429Z6a/C39QAvBZ9qfn7e1W07AX9bcWAN/rYN/7Xg12VcatJ6+CXI6fLb7/BuqyXeOISlfH73l9v6A2vwtxUOLwbf8wC/yXIC/raGoubdJZb1cHk/B3/7v1Mg5bbWgUH52aAIg8KgfGdQbmt1GJSfDco8Fio/9nj76lryxaCseTz2mq82ezlJHY+dpNWTzd48VskY5DyW6Kcg2/hBcqnton7I4JHq8bi+Do4TiY66jrPg9fhFhvOPgLTtq3/9wbTn6iKnE7nW8RrL9ttF/T+QMpG4+BHI3Jf9szT3Wi5AyjJEhCxyeOySdpATiQhbkBOJBVuQExXvn10jl2X8NdPl8P39L66RZXxHLT/exRcbXzbVIowVY6U/VhOV+h/u6MZ3AX/728tfXPa3seuWdryx7POyP9FXL2xBTvRVCqOOwYXu5EI30RdFbKsrv8FQ+a1Z5bcPOhz57YMOR+5ooMORWwPocBQ4qv/WL7Vl7NX71S0WylLS2c7+/Gc+XraYJY3MS77aNZby/DuGx+f8V1vMyt0MmNhYE8t9I5jYWBPLHTqY2FgTyz1ImNhYE4vhY2JDTeyKS2ViY00s1pqJjTWxnA8wsbEmlpMYJjbWxAoTy8SGmljOvJjYWBPLmRcTG2tiOfNiYv9iYu2+bL1y5sXExppYzrz0JzbnbTz04TWeTywzuHGK9YK/bjG+Zlzk8DXjL66aafxRsZKkHl7k2fPo4xL7CO/wGrc9T854IuWZl2W885dcjnl+XlzHbSBrP/wCq+3Rc1hy2+g5dYgVvYz7KS1r/7fohejvGj0ePFT0qe4/is6pycneDUs8V5441LnyxDCGyjO3/Q+5PE5P2p8/alPZnqcnPZ2Ej6y7b/gNSzZv+HX8LdpUJf/Tjrxh35iT78wJqo45+c6c4PUmnpN1AKm/142fz4kwJ8zJN+YEY/iCORnX+8ec5Is5kd53yVCX430Uzx5aat9vEy7r8cal+/2qGsbwxXlefecpyXjfJyntz3mu2zjyW7d8lifGcK48MYZz5YkEnCrPjtcLlWfL4y9LNVlP8sS/zZUnnmyuPPFZc+Up5Bkoz61vu09oy29Ezh556csQ2UuvZ/Gjk24dP/bp1vEjq24dP24rUvwt5/01PnZ1+d/jR4XdOP66YM5CNbk+DpEfTjSf5Ik5u83buZ/Ej2i7dfx4uVvHL8Sv8Ofj6oIP0+GIWNLhiKGJ+3W/cnKdRrnMlScOZao8E1Lke3ku7Ys8PzgiI3Q43rbVS8njInC4TdoXHNOzIKX8/IXF+X0rJe0PLXK4VV9vp2cu090xsKbbugIZP64pcrgZ6hdDtaQ6PrUe523PjNbz5VJlLH98Fh2Xf4AXwNuAv22ttwZ/Ww9gDf624uC14Gsb9xlZ1mX78/LbbzRuazsYQj9DeFtFwxC6GcJ8W6/EEPoZwttKuTcOYc6fN+P5vhbPGDymywi8AN4GPKbrFeBTzc8DhrptJ+AxXUbgMV0vAb8u41KT1sOtN9han22tMV2vH8JSTt792B0b8AWj8RrwPQ/wm1xcdtc2zoHWtj2/P7p/faTQ+AOEhB0IEBImIUBIQkj+Q8JQBAgJmxEgJMyHg5D6sj/4499tn0PCDAQICYvgPyTBOAQICeMQICSMQ4CQMA4BQhJC8h8SxiFASBiHACFhHAKEhHEIEBLGwX9IFeMQICSMQ4CQMA4BQsI4BAhJCMl/SBiHACFhHAKEhHEIEBLGIUBIGAf/Ia0YhwAhYRwChIRxCBASxiFASEJI/kPCOAQICeMQICSMQ4CQMA4eQpLx+6ReT0LCOPgPacM4BAgJ4/DukD7AYxFeAr6X5129ej8DjxkwAi+AtwFPgzcCTys3Ak/TNgJPezYCTyO2Ad9ouUbgaa5G4GmuRuBprkbgBfA24GmuRuBprkbgaa5G4GmuRuBprjbgO83VCDzN1Qg8zdUIPM3VCLwA3gY8zdUIPM3VCDzN1Qg8zdUIPM3VBPy60FyNwNNcjcDTXI3A01yNwAvgbcDTXI3A01yNwNNcjcDTXI3A01xtwCeaqxF4mqsReJqrEXiaqxF4AbwNeJqrEXiaqxF4mqsReJqrEXiaqw34THM1Ak9zNQJPczUCT3M1Ai+AtwFPczUCT3M1Ak9zNQJPczUCT3O1AV9orkbgaa5G4GmuRuBprkbgBfA24GmuRuBprkbgaa5G4GmuRuBprjbgheZqBJ7magSe5moEnuZqBF4AbwOe5moEnuZqBJ7magSe5moEnuZqA77SXI3A01yNwNNcjcDTXI3AC+BtwNNcjcDTXI3A01yNwNNcjcDTXG3ArzRXI/A0VyPwNFcj8DRXI/ACeBvwNFcj8DRXI/A0VyPwNFcj8DRXG/AbzdUIPM3VCDzN1Qg8zdUIvADeBjzN1Qg8zdUIPM3VCDzN1Qg8zdUGfKO5GoGnuRqBp7kagae5GoEXwNuAp7kagae5GoGnuRqBp7kagae52oDvNFcj8DRXI/A0VyPwNFcj8AJ4G/A0VyPwNFcj8DTXl4B/7FoG+E2WPy9/XPDlY/XjEvR8neseEi03QEg04leEtEiVsbwu9dMlbFtoxEbgb9uIa97RlLXKBfiW08695V/P9WN1bmerty776q33crG6PImU5/PIyxmQxxVuAKkXi9PWd3qppfVi8TIeOS2tHxd/DMptGzyD8rNBua1xYFB+NigyzaDkx0f3vrqWfDEoax6Pvearz/CcpI7HTtLOPsPnMR7GIOcxGC8EWZ9XgdoOV8Unxnl8xE8xtn31Wmq72JzL4JGqPC/pqQ6O8yiDH3Isaxsc2wXHtY2Os7Yt/b+dflvm6fSGFNM8Bd2S4jxt25LiPFXUkuI8Pc2SokBRgeJtG8yPKPZllwCPU4/tM8Xb1hdVirdtL6oU6S4aFOkuChQz3UWDIt1FgyLdRYMi3UWDokBRgSLdRYMi3UWDIt1FgyLdRYMi3UWBYqG7aFCku2hQpLtoUKS7aFAUKCpQpLtoUKS7fIviH397sxW6iwZFuosGRbqLAkWhu2hQpLtoUKS7aFCku2hQFCgqUKS7aFCku2hQpLtoUKS7aFCkuyhQrHQXDYp0Fw2KdBcNinQXDYoCRQWKdBcNinQXDYp0Fw2KdBcNinQXBYor3UWDIt1FgyLdRYMi3UWDokBRgSLdRYMi3UWDIt1FgyLdRYMi3UWB4kZ30aBId9GgSHfRoEh30aAoUFSgSHfRoEh30aBId9GgSHfRoEh3UaDY6C4aFOkuGhTpLhoU6S4aFAWKChTpLhoU6S4aFOkuGhQn+pOwdXBJa+0XFHNfdjC51/Jc/euvlX1+2suyv0ZZ5PDYJe0gJ/qzraYg+0R/htUW5ER/VvVHIMuypPES23oBMpe831knizz/LsT5nzXkTyb2if4IK2PlZ6wm+pOtPxurB4/9JabDDu2Ly/42torSDn9q/nDZF0DqgJyn7P4U5DZA5nwFMj8ecbzGsnGhu7rQzdP+rcbqA+Q8AuCHf+S7rOMllsO74vyPfKdSxvSW9tyItF0B9IkUgCnHiQyAIce2TCQATDlO1P9NOU5UeF/JUUbh/fVnxY8cz/YCbRl79X7YUq1y2rxLOtvZP2q44y1mSSPzkq92jaWUMYTH5/w3W8y2TNSlmdhbTKwwsUxsqImdyA4xsbeY2InEExN7i4nF8DGxsSYWl8rExppYrDUTG2piE+cDTGysieUkhomNNbGceTGxsSaWMy8mNtbEChPLxIaaWM68mNi/mFizL1s/HoCJZWJDTSxnXvoTm/M2HvrwGs8nlhlMnGLpz6CMrxkXOXzN+IurZlrG6iT18CLPnkcfl9jU5fAatz1Pzngi5ZmXZbzzl1yOeX5eXLc9l9oPv8BqH9FnDktuGz2nDrGil3EToGXt/xY9+v620ePBQ0Wf6v6j6JyafN67ZSHPqfLEoc6VJ4YxVJ659Z1Iye3PH7WpbM/Tk55OwkfW3Th8LNm84de0L05V8r/tyLFvzMk35qSg6piT78wJXm/iOVkHkPp73fj5nCABmZPvzAnG8AVzMq73jznJF3Mive+SoS7H+yiePbTUvt8mXNbjjUv3+1UVIc/X5nn1nack432fpLQ/57lu48hv3fJZnhjDufLEGM6VJxJwrjzxeqHyfBzB7Hk2WU/yxL9NlafgyebKE581V554p0h5bn3bfUJbfiNy9shLX4bIXno9ix+ddOv4hfjvHD+y6tbx47Yixd9y3l/jY1eX/z1+VNit48echWpyfRwiP5xoPskTc3abt3P/HH9FtN06frzcreNH46n8+biKD9PhKHBU4Yihift1v3JynUa5zJUnDmWuPJEi38tzaV/k+cERGaHCcb1tq5eSx0XgcJu0LzimZ0FK+fkLi/P7VkraH1rkcKu+3k7PXOa7Y+B6W1cg48c1RQ43Q/1iqJZUx6fW47ztmdF6vlyqjOWPz6Lj8g/wt23p1uBvW+utwQvgbcDfVhxYg79tw7cGf9sqbg3+tp3ZGvxtS7Yx+O2+rdwYPM31JeBrG3dPW9Zl+/Pyu+uTjRbPEJoPIUaDITQfQmEIGULrIcR0vX4Icz7ZjGO6jMBjuozAY7qMwGO6XgE+1fz82kTdts/gG6bLCDym6yXg12VcatJ6uKEYW+uTrXXDdL1+CEs5efdjd4zAC+BfAr7nAX6Ti8vu2sY50Po48nku3kOi8QcICTsQICRMQoCQsA4BQsJQ+A+pYzMChIT5cBBSX/YHf/y77XNImIEAIWERAoQkhOQ/JIxDgJAwDgFCwjgECAnjECAkjIP7kPqCcQgQEsYhQEgYhwAhYRwChCSE5D8kjEOAkDAOAULCOAQICeMQICSMg/+QEsYhQEgYhwAhYRwChIRxCBCSEJL/kDAOAULCOAQICeMQICSMQ4CQMA7+Q8oYhwAhYRwChIRxCBASxiFASEJI/kPCOAQICeMQICSMQ4CQMA4BQsI4+A+pYBwChIRxCBASxiFASBiHACEJIfkPCeMQICSMQ4CQMA4BQsI4BAgJ4+A/JME4BAgJ4xAgJIxDgJAwDgFCEkLyHxLGIUBIGIcAIWEcAoSEcQgQEsbBf0gV4xAgJIxDgJAwDgFCwjgECEkIyX9IGIcAIWEcAoSEcQgQEsYhQEgYB/8hrRiHACFhHAKEhHEIEBLGIUBIQkj+Q8I4BAgJ4xAgJIxDgJAwDgFCwjj4D2nDOAQICeMQICSMQ4CQMA4BQhJC8h8SxiFASBiHACFhHAKEhHEIEBLGwX9IDeMQICSMQ4CQMA4BQsI4BAhJCMl/SBiHACFhHAKEhHEIEBLGIUBIGAf/IXWMQ4CQMA4BQsI4BAgJ4xAgJCEk/yFhHAKEhHEIEBLGIUBIGIcAIWEcnIeUl8f/CMl/SBgHDyGJjJDqSUgYhwAhYRwChCSE9OaQPsBjEV4Cvpc+wD/OeE7AYwaMwNP2jcDT4I3A08ptwCeathF42rMReBqxEXharhF4AbwNeJqrEXiaqxF4mqsReJqrEXiaqw34THM1Ak9zNQJPczUCT3M1Ai+AtwFPczUCT3M1Ak9zNQJPczUCT3O1AV9orkbgaa5G4GmuRuBprkbgBfA24GmuRuBprkbgaa5G4GmuRuBprjbgheZqBJ7magSe5moEnuZqBF4AbwOe5moEnuZqBJ7magSe5moEnuZqA77SXI3A01yNwNNcjcDTXI3AC+BtwNNcjcDTXI3A01yNwNNcjcDTXG3ArzRXI/A0VyPwNFcj8DRXI/ACeBvwNFcj8DRXI/A0VyPwNFcj8DRXG/AbzdUIPM3VCDzN1Qg8zdUIvADeBjzN1Qg8zdUIPM3VCDzN1Qg8zdUGfKO5GoGnuRqBp7kagae5GoEXwNuAp7m+BLzqXztutNwAIdGI3x3SB3ga8SvAL1JlLK9LPQFPI7YB32/biGve0ZS1ygX4ltPOveVfz/VjdW5nq7cu++qt93KxujyJlOfzyMsZkMdVawCpF4vT1nd6qaX1YvEyHjk93o3HxR+DctsGz6D8bFBuaxwYlJ8NyjyGJD8+uvfVteSLQVnzeOw1X32G5yR1PHaSdvYZLoDUATmPwXghyPq8CtR2uCo+Mc7jGH6Kse2r11LbxeZcBo9U5XlJT3VwnEcD/JBjWdvg2C44rm10nLVt6ZNM6fN0ekuK8xR0O4ppmadtW1Kcp4paUpynp1lSvG2JUaUoUPwGxb7sEuBxkrF9pnjb+qJK8bbtRZUi3UWDIt1FgyLdRYFiortoUKS7aFCku2hQpLtoUBQoKlCku2hQpLtoUKS7aFCku2hQpLsoUMx0Fw2KdBcNinQXDYp0Fw2KAkUFinQXDYp0Fw2KdBcNinQXDYp0FwWKhe6iQZHuokGR7qJBke6iQVGgqECR7qJBke6iQZHuokGR7qJBke6iQFHoLhoU6S4aFOkuGhTpLhoUBYoKFOkuGhTpLhoU6S4aFOkuGhTpLgoUK91FgyLdRYMi3UWDIt1Fg6JAUYEi3UWDIt1FgyLdRYMi3UWDIt1FgeJKd9GgSHfRoEh30aBId9GgKFBUoEh30aBId9GgSHfRoEh30aBId1GguNFdvkXxj39CLm10Fw2KdBcNinQXDYoCRQWKdBcNinQXDYp0Fw2KdBcNinQXBYqN7qJBke6iQZHuokGR7qJBUaCoQJHuokGR7qJBke6iQZHuokGR7qJAsdNdNCjSXTQo0l00KNJdNCgKFBUo0l00KNJdNCjSXTQo0l00KNJd/p1iXuguGhTpLhoU6S4aFOkuGhQFigoU6S4aFOkuGhTpLhoU6S4aFOkuChQT3UWDIt1FgyLdRYMi3UWDokBRgSLdRYMi3UWDIt1FgyLdRYMi3UWBYqa7aFCku2hQnKe7pDq4pLX2C4q5LzuY3Gt5ri5y9rSXZX+NssjhsUvaQc5TX4xBCiB1QM5TYn4GsixLGi+xrRcgc8n7nXWySBqrczt73u3RDT9Wt1zzxeqty756671crC5Pfr+e6b52OXvSmywDX71YnLa+s04trReLl/HIaWn9uPhjrOZpdYyVo7Gap+b+cKwePPaXmA47tC8u+9vYKkqT5eyyP0/TNQY5T9n9KchtgMz5CuRD840LXS4bF7qLC12Zp/1bjdUHyHkEQFrbvrVIW2pXIMs6XmI5vCtKP3smqZQxvaU9NyJtVwBlIgVgynEiA2DKUeCownGi/m/KcaLC+0qOMgpvkm09cjzbC7Rl7NX7YUu1ymnzLulsZ/+o4Y63mCWNzEu+2jWWUsYQHp/z320xJ+rSTOwtJnYiacHE3mJiJ7JDTOwdJlYmEk9M7C0mFsPHxMaaWFwqExtrYrHWTGysiRUmlokNNbGcxDCxsSaWMy8mNtbEcubFxMaaWM68mNhYE8uZFxP7FxNr92XrypkXExtrYjnz0p/YnLfx0IfXeD6xzGDlFEt/BmV8zbjI4WvGX1w10zJWJ6mHF3n2PPq4xKYuh9e47XlyxhMpz7ws452/5HLM8/Piuu251H74BVbboxeiv2v0nDrEil7GTYCWtf9b9Oj720aPBw8Vfar7j6JzanKyd8MSz5UnDnWqPFcMY6g8c+s7kZLbnz9qU9mepyc9nYSPrLtx+FiyecOvaV+cquR/2pGv2Dfm5P//xpwIc8KcfGNO8HoTz8k6gNTf68bP5wQJyJx8Z04whi+Yk3G9f8xJvpgT6X2XDHU53kfx7KGl9v024bIeb1y6369qxRi+OM+r7zwlGe/7JKX9Oc91G0d+65bP8sQYTpXnhjGcK08k4Fx54vVC5dny/qzXJutJnvi3ufIU8pwqT3zWXHninSLlufVt9wlt+Y3I2SMvfRkie+n1LH500q3jxz7dOn5k1Z3jb7itSPG3nPfX+NjV5X+PHxV26/gxZ6GaXB+HyA8nmk/yxJzd5u3cT+IX4r9z/Hi5W8ePxlP583ENH6bDEbGkwxFDE/frfuXzdbqjXObKE4cyV55Ike/lubQv8vzgiIzQ4Sh35Sglj4vA4TZpX3BMz4KU8vMXFuf3rZS0P7TI4VZ9vZ2eucx3x8B+W1cg48c1RQ43Q/1iqJZUx6fW47ztmdF6vlyqjOWPz6Lj8g/wt23p1uBvW+utwd/WA1iDv604sAVflts2fGvwt63irwVf27izzrIu25+X33xrXZbb+gOG0M8Q3la+MIR+hlAYQobQeggxXa8fwpxPNuOYLiPwmC4j8JguI/CYrleATzU/j9Tqtn0GnzBdRuAxXS8Bvy7jUpPWw81m2FqfbK0Tpuv1Q1jKybsfu2MEXgD/EvA9D/CbXFx21zbOgda2Pb8xve4h0fgDhIQdCBASJiFASFiHACFhKPyHlLEZAULCfDgIqS/7gz/+3fY5JMxAgJCwCAFCEkLyHxLGIUBIGIcAIWEcAoSEcQgQEsbBf0gF4xAgJIxDgJAwDgFCwjgECEkIyX9IGIcAIWEcAoSEcQgQEsYhQEgYB/8hCcYhQEgYhwAhYRwChIRxCBCSEJL/kDAOAULCOAQICeMQICSMQ4CQMA7+Q6oYhwAhYRwChIRxCBASxiFASEJI/kPCOAQICeMQICSMQ4CQMA4BQsI4+A9pxTgECAnjECAkjEOAkDAOAUISQvIfEsYhQEgYhwAhYRwChIRxCBASxsF/SBvGIUBIGIcAIWEcAoSEcQgQkhCS/5AwDgFCwjgECAnjECAkjEOAkDAO/kNqGIcAIWEcAoSEcQgQEsYhQEhCSP5DwjgECAnjECAkjEOAkDAOAULCOPgPqWMcAoSEcQgQEsYhQEgYhwAhCSH5DwnjECAkjEOAkDAOAULCOAQICePgPiRZMA4BQsI4BAgJ4xAgJIxDgJCEkPyHhHEIEBLGIUBIGIcAIWEcAoSEcfAfUsI4BAgJ4xAgJIxDgJAwDgFCEkLyHxLGIUBIGIcAIWEcAoSEcQgQEsbBf0gZ4xAgJIxDgJAwDgFCwjgECEkIyX9IGIcAIWEcAoSEcQgQEsYhQEgYB/8hFYxDgJAwDh5CEhkh1ZOQMA4BQsI4BAhJCOnNIX2AxyK8BHwvfYDv/Qw8ZsAIPG3fCDwN3gg8rdwGvNC0jcDTno3A04iNwNNyjcAL4G3A01yNwNNcjcDTXI3A01yNwNNcbcBXmqsReJqrEXiaqxF4mqsReAG8DXiaqxF4mqsReJqrEXiaqxF4mqsN+JXmagSe5moEnuZqBJ7magReAG8DnuZqBJ7magSe5moEnuZqBJ7magN+o7kagae5GoGnuRqBp7kagRfA24CnuRqBp7kagae5GoGnuRqBp7nagG80VyPwNFcj8DRXI/A0VyPwAngb8DRXI/A0VyPwNFcj8DRXI/A0VxvwneZqBJ7magSe5moEnuZqBF4AbwOe5moEnuZqBJ7magSe5moEnuZqAr4uNFcj8DRXI/A0VyPwNFcj8AJ4G/A0VyPwNFcj8DRXI/A0VyPwNFcb8InmagSe5moEnuZqBJ7magReAG8Dnub6EvCaf+24JlpugJBoxO8O6QM8jfgV4H/d8H8sfxjOE/A0Yhvw+baNuOYdTVmrXIBvOe3cW/71XD9W53a2euuyr956Lxery5NIeT6PvJwBeVy1BpB6sThtfaeXWlovFi/jkdPS+nHxx6DctsEzKD8blNsaBwblZ4MyjyHJj4/ufXUt+WJQ1jwee81Xn+E5SR2PnaSdfYYLIHVAzmMwXgiyPq8CtR2uik+M8ziGn2Js++q11HaxOZfBI1V5XtJTHRzn0QA/5FjWNji2C45rGx1nbVv6JFPyPJ3ekuI8Bd2QYpmnbVtSnKeKWlKcp6dZUrxtiVGlKFD8BsW+7BLgcZLx+dio3La+qFK8bXtRpUh30aBId9GgSHdRoCh0Fw2KdBcNinQXDYp0Fw2KAkUFinQXDYp0Fw2KdBcNinQXDYp0FwWKle6iQZHuokGR7qJBke6iQVGgqECR7qJBke6iQZHuokGR7qJBke6iQHGlu2hQpLtoUKS7aFCku2hQFCgqUKS7aFCku2hQpLtoUKS7aFCkuyhQ3OguGhTpLhoU6S4aFOkuGhQFigoU6S4aFOkuGhTpLhoU6S4aFOkuChQb3UWDIt1FgyLdRYMi3UWDokBRgSLdRYMi3UWDIt1FgyLdRYMi3UWBYqe7aFCku2hQpLtoUKS7aFAUKCpQpLtoUKS7aFCku2hQpLtoUKS7/DvFdaG7fIviH/+E3LrQXTQo0l00KNJdNCgKFBUo0l00KNJdNCjSXTQo0l00KNJdFCgmuosGRbqLBkW6iwZFuosGRYGiAkW6iwZFuosGRbqLBkW6iwZFuosCxUx30aBId9GgSHfRoEh30aAoUFSgSHfRoEh30aBId9GgSHfRoEh3UaBY6C4aFOkuGhTpLhoU6S4aFAWKChTpLhoU6S4aFOkuGhTpLhoU6S4KFIXuokGR7qJBke6iQZHuokFRoKhAke6iQZHuokGR7qJBke6iQZHuokCx0l00KNJdNCjO011SHVzSWvsFxdyXHUzutTxXFzl72suyv0ZZ5PDYJe0g56kvxiAFkDog5ykxPwNZliWNl9jWC5C55P3OOlkkjdW5nT3vltO+uuWaL1ZvXfbVW+/lYnV58vv1TPe1y9mT3mQZ+OrF4rT1nXVqab1YvIxHTkvrx8UfYzVPq2OsHI3VPDX3h2P14LG/xHTYoX1x2d/GVlGaLGeX/XmarjHIecruT0FuA2TOVyDz4xHHaywbF7qLC906T/u3GqsPkPMIgLS2fWuRttSuQJZ1vMRyeFeUfvZMUiljekt7bkTargDWiRSAKceJDIApR4GjCseJ+r8px4kK7ys5yii8Sbb1yPFsL9CWsVfvhy3VKqfNu6Sznf2jhjveYpY0Mi/5atdYShlDeHzOf7fFnKhLM7G3mNiJpAUTe4uJncgOMbF3mNhtIvHExN5iYjF8TGysicWlMrGxJhZrzcTGmlhhYpnYUBPLSQwTG2tiOfNiYmNNLGdeTGysieXMi4mNNbGceTGxfzGxdl+2bpx5MbGxJpYzL/2JzXkbD314jecTyww2TrH0Z1DG14yLHL5m/MVVMy1jdZJ6eJFnz6OPS2zqcniN254nZzyR8szLMt75Sy7HPD8vrtueS+2HX2C1PXoh+rtGz6lDrOhl3ARoWfu/RY++v230ePBQ0ae6/yg6pyYnezcs8Vx54lCnyrNjGEPlmVvfiZTc/vxRm8r2PD3p6SR8ZN2Nw8eSzRt+TfviVCX/0468Y9+Yk+/MiTAnzMk35gSvN/GcrANI/b1u/HxOkIDMyXfmBGP4gjkZ1/vHnOSLOZHed8lQl+N9FM8eWmrfbxMu6/HGpfv9qjrG8MV5Xn3nKcl43ycp7c95rts48lu3fJYnxnCmPB//N3lOlScScK488Xqh8mx5f9Zrk/UkT/zbXHkKeU6VJz5rrjzxTpHy3Pq2+4S2/Ebk7JGXvgyRvfR6Fj866dbxY59uHT+y6s7xJ9xWpPhbzvtrfOzq8r/Hjwq7dfyYs1BNro9D5IcTzSd5Ys5u83buJ/EL8d85frzcreNH42n8+bjHs4OjCkfEkg5HDE3cr/uVz9fpjHKZK08cylx5IkW+l+fSvsjzgyMyQoej3JWjlDwuAofbpH3BMT0LUsrPX1ic37dS0v7QIodb9fV2euYy3R0Dt3xbVyDjxzVFDjdD/WKollTHp9bjvO2Z0Xq+XKqM5Y/PouPyD/C3benW4G9b663B39YDWIO/rTgwBl9u2/Ctwd+2ir8WfG3jzjrLumx/Xn73rXW5rT9gCP0M4W3lC0PoZwiFIWQIrYcQ0/X6Icz5ZDOO6TICj+kyAo/pMgKP6XoF+FTz80itbttn8ILpMgKP6XoJ+HUZl5q0Hm42w9b6ZGstmK7XD2EpJ+9+7I4ReAH8S8D3PMBvcnHZXds4B1rb9vzG9P6FKaHxBwgJOxAgJExCgJCwDgFCwlD4D6liMwKEhPlwEFJf9gd//Lvtc0iYgQAhYREChCSE5D8kjEOAkDAOAULCOAQICeMQICSMg/+QVoxDgJAwDgFCwjgECAnjECAkIST/IWEcAoSEcQgQEsYhQEgYhwAhYRz8h7RhHAKEhHEIEBLGIUBIGIcAIQkh+Q8J4xAgJIxDgJAwDgFCwjgECAnj4D+khnEIEBLGIUBIGIcAIWEcAoQkhOQ/JIxDgJAwDgFCwjgECAnjECAkjIP/kDrGIUBIGIcAIWEcAoSEcQgQkhCS/5AwDgFCwjgECAnjECAkjEOAkDAO7kNqC8YhQEgYhwAhYRwChIRxCBCSEJL/kDAOAULCOAQICeMQICSMQ4CQMA7+Q0oYhwAhYRwChIRxCBASxiFASEJI/kPCOAQICeMQICSMQ4CQMA4BQsI4+A8pYxwChIRxCBASxiFASBiHACEJIfkPCeMQICSMQ4CQMA4BQsI4BAgJ4+A/pIJxCBASxiFASBiHACFhHAKEJITkPySMQ4CQMA4BQsI4BAgJ4xAgJIyD/5AE4xAgJIxDgJAwDgFCwjgECEkIyX9IGIcAIWEcAoSEcQgQEsYhQEgYB/8hVYxDgJAwDgFCwjgECAnjECAkIST/IWEcAoSEcQgQEsYhQEgYhwAhYRz8h7RiHAKEhHHwEJLICKmehIRxCBASxiFASEJIbw7pAzwW4SXge+kDfO9n4DEDRuBp+0bgafBG4GnlNuA3mrYReNqzEXgasRF4Wq4ReAG8DXiaqxF4mqsReJqrEXiaqxF4mqsN+EZzNQJPczUCT3M1Ak9zNQIvgLcBT3M1Ak9zNQJPczUCT3M1Ak9ztQHfaa5G4GmuRuBprkbgaa5G4AXwNuBprkbgaa5G4GmuRuBprkbgaa4m4PtCczUCT3M1Ak9zNQJPczUCL4C3AU9zNQJPczUCT3M1Ak9zNQJPc7UBn2iuRuBprkbgaa5G4GmuRuAF8Dbgaa5G4GmuRuBprkbgaa5G4GmuNuAzzdUIPM3VCDzN1Qg8zdUIvADeBjzN1Qg8zdUIPM3VCDzN1Qg8zdUGfKG5GoGnuRqBp7kagae5GoEXwNuAp7kagae5GoGnuRqBp7kagae52oAXmqsReJqrEXiaqxF4mqsReAG8DXia60vAa/614y603AAh0YjfHdIHeBrxK8AvUmUsr0s9AU8jtgFfb9uIa97RlLXKBfiW08695V/P9WN1bmert8de6GP11nu5WF2eRMrzeeTlDMjjqjWA1IvFaes7vdTSerF4GY+cltaPiz8G5bYNnkH52aDc1jgwKD8blHkMSX58dO+ra8kXg7Lm8dhrvvoMz0nqeOwk7ewzXACpA3Ieg/FCkPV5FajtcFV8YpzHMfwUY9tXr6W2i825DB6pyvOSnurgOI8G+CHHsrbBsV1wXNvoOGvb0ieZUufp9JYU5ynohhTXedq2JcV5qqglxXl6miXF25YYVYoCxW9Q7MsuAR4nGZ+Pjdbb1hdVirdtL6oU6S4aFOkuGhTpLgoUN7qLBkW6iwZFuosGRbqLBkWBogJFuosGRbqLBkW6iwZFuosGRbqLAsVGd9GgSHfRoEh30aBId9GgKFBUoEh30aBId9GgSHfRoEh30aBId1Gg2OkuGhTpLhoU6S4aFOkuGhQFigoU6S4aFOkuGhTpLhoU6S4aFOku/0wxLQvdRYMi3UWDIt1FgyLdRYOiQFGBIt1FgyLdRYMi3UWDIt1FgyLdRYFiortoUKS7aFCku2hQpLtoUBQoKlCku2hQpLtoUKS7aFCku2hQpLsoUMx0Fw2KdBcNinQXDYp0Fw2KAkUFinQXDYp0Fw2KdBcNinQXDYp0FwWKhe7yLYp/+hNyD4p0Fw2KdBcNinQXDYoCRQWKdBcNinQXDYp0Fw2KdBcNinQXBYpCd9GgSHfRoEh30aBId9GgKFBUoEh30aBId9GgSHfRoEh30aBId1GgWOkuGhTpLhoU6S4aFOkuGhQFigoU6S4aFOkuGhTpLhoU6S4aFOkuChRXuosGRbqLBkW6iwZFuosGRYGiAkW6iwZFuosGRbqLBkW6iwZFuosCxY3uokGR7qJBke6iQZHuokFRoKhAke6iQZHuokGR7qJBke6iQZHuokCx0V00KNJdNCjO011SHVzSWvsFxdyXHUzutTxXFzl72suyv0ZZ5PDYJe0g56kvxiAFkDog5ykxPwNZliWNl9jWC5C55P3OOlkkjdW5nT3vltO+uuWaL1ZvXfbVW+/lYnV58vv1TPe1y9mT3mQZ+OrF4rT1nXVqab1YvIxHfoxQPy7+GKt5Wh1j5Wis5qm5Pxyrx2vfX2I67NC+uOxvY6soTZazy/48TdcY5Dxl96cgtwEy5yuQ+fGI4zWWjQvdxYWuz9P+rcbqA+Q8AiCtbd9apC21K5BlHS+xHN4VpZ89k1TKmN7SnhuRtiuAPpECMOU4kQEw5ShwVOE4Uf835ThR4X0lRxmFN8m2Hjme7QXaMvbq/bClWuW0eZd0trN/1HDHW8ySRuYlX+0aSyljCI/P+e+2mBN1aSb2FhM7kbRgYm8xsRPZISb2BhOblonEExN7i4nF8DGxsSYWl8rExppYrDUTG2tihYllYkNNLCcxTGysieXMi4mNNbGceTGxsSaWMy8mNtbEcubFxP7FxJp92foxskwsExtqYjnz0p/YnLfx0IfXeD6xzGDiFEt/BmV8zbjI4WvGX1w1H312XDWlHl7k2fPo4xKbuhxe47bnyRlPpDzzsox3/pLLMc/Pi+u251L74RdYbY9eiP6u0XPqECt6GTcBWtb+b9Gj728bPR48VPSp7j+KzqnJyd4NSzxXnjjUqfLMGMZQeebWdyIltz9/1KayPU9PejoJH1l34/CxZPOGX9O+OFXJ/7Qjz9g35uQ7cyLMCXPyjTnB6008J+sAUn+vGz+fEyQgc/KdOcEYvmBOxvX+MSf5Yk6k910y1OV4H8Wzh5ba99uEy3q8cem654kxfHGeV995SjLe90lK+3Oe6zaO/NYtn+WJMZwqz4IxnCtPJOBceeL1QuXZ8v6s1ybrSZ74t7nyFPKcKk981lx54p0i5bn1bfcJbfmNyNkjL30ZInvp9Sx+dNKt48c+3Tp+ZNWd4xfcVqT4W877a3zs6vK/x48Ku3X8mLNQTa6PQ+SHE80neWLObvN27ifxC/HfOX683K3jR+Np/Pm4x0zAUYUjYkmHI4Ym7tf9yufrdEW5zJUnDmWuPJEi38tzaV/k+cERGaHDUe7KUUoeF4HDbdK+4JieBSnl5y8szu9bKWl/aJHDrfp6Oz1zme+OgfW2rkDGj2uKHG6G+sVQLQ9SA2Tanhmt58ulylj++Cw6Lv8Af9uWbg3+trXeGvxtPYA1+NuKA2Pw620bvjX421bx14KvbdxZZ1mX7c/L7761Xm/rDxhCP0N4W/nCEPoZQmEIGULrIcR0vX4Icz7ZjGO6jMBjuozAY7qMwGO6XgH+cRT+PFKr2/YZ/IbpMgKP6XoJ+HUZl5qHyFnYWv9pa71hul4/hKWcvPuxO0bgBfAvAd/zAL/JxWV3beMcaG3b8xvT+xemNhp/gJCwAwFCwiQECAnrECAkDIX/kBo2I0BImA8HIfVlf/DHv9s+h4QZCBASFiFASEJI/kPCOAQICeMQICSMQ4CQMA4BQsI4+A+pYxwChIRxCBASxiFASBiHACEJIfkPCeMQICSMQ4CQMA4BQsI4BAgJ4+A+pLxgHAKEhHEIEBLGIUBIGIcAIQkh+Q8J4xAgJIxDgJAwDgFCwjgECAnj4D+khHEIEBLGIUBIGIcAIWEcAoQkhOQ/JIxDgJAwDgFCwjgECAnjECAkjIP/kDLGIUBIGIcAIWEcAoSEcQgQkhCS/5AwDgFCwjgECAnjECAkjEOAkDAO/kMqGIcAIWEcAoSEcQgQEsYhQEhCSP5DwjgECAnjECAkjEOAkDAOAULCOPgPSTAOAULCOAQICeMQICSMQ4CQhJD8h4RxCBASxiFASBiHACFhHAKEhHHwH1LFOAQICeMQICSMQ4CQMA4BQhJC8h8SxiFASBiHACFhHAKEhHEIEBLGwX9IK8YhQEgYhwAhYRwChIRxCBCSEJL/kDAOAULCOAQICeMQICSMQ4CQMA7+Q9owDgFCwjgECAnjECAkjEOAkISQ/IeEcQgQEsYhQEgYhwAhYRwChIRx8B9SwzgECAnjECAkjEOAkDAOAUISQvIfEsYhQEgYhwAhYRwChIRxCBASxsF/SB3jECAkjIOHkERGSPUkJIxDgJAwDgFCEkJ6c0gf4LEILwHfSx/gez8DjxkwAk/bNwJPgzcCTys3AV8WmrYReNqzEXgasRF4Wq4ReAG8DXiaqxF4mqsReJqrEXiaqxF4mqsN+ERzNQJPczUCT3M1Ak9zNQIvgLcBT3M1Ak9zNQJPczUCT3M1Ak9ztQGfaa5G4GmuRuBprkbgaa5G4AXwNuBprkbgaa5G4GmuRuBprkbgaa424AvN1Qg8zdUIPM3VCDzN1Qi8AN4GPM3VCDzN1Qg8zdUIPM3VCDzN1Qa80FyNwNNcjcDTXI3A01yNwAvgbcDTXI3A01yNwNNcjcDTXI3A01xtwFeaqxF4mqsReJqrEXiaqxF4AbwNeJqrEXiaqxF4mqsReJqrEXiaqw34leZqBJ7magSe5moEnuZqBF4AbwOe5moEnuZqBJ7magSe5moEnuZqA36juRqBp7kagae5GoGnuRqBF8DbgKe5vgS85l87LhstN0BINOJ3h/QBnkb8CvCLVBnL61JPwNOIbcC32zbimnc0D+cuF+BbTjv3ln8914/VuZ2t3rrsq7fey8Xq8iRSns8jL2dAHletAaReLE5b3+mlltaLxct45LS0flz8MSi3bfAMys8G5bbGgUH52aDMY0jy46N7X11LvhiUNY/HXvPVZ3hOUsdjJ2lnn+ECSB2Q8xiMF4Ksz6tAbYer4hPjPI7hpxjbvnottV1szmXwSFWel/RUB8d5NMAPOT6OpgfHdsFxbaPjrG1Ln2RKm6fTW1Kcp6AbUuzztG1LivNUUUuK8/Q0S4q3LTGqFAWK36DYl10CPE4yPh8b9dvWF1WKt20vqhTpLhoU6S4aFOku/05RFrqLBkW6iwZFuosGRbqLBkWBogJFuosGRbqLBkW6iwZFuosGRbqLAsVEd9GgSHfRoEh30aBId9GgKFBUoEh30aBId9GgSHfRoEh30aBId1GgmOkuGhTpLhoU6S4aFOkuGhQFigoU6S4aFOkuGhTpLhoU6S4aFOkuChQL3UWDIt1FgyLdRYMi3UWDokBRgSLdRYMi3UWDIt1FgyLdRYMi3UWBotBdNCjSXTQo0l00KNJdNCgKFBUo0l00KNJdNCjSXTQo0l00KNJdFChWuosGRbqLBkW6iwZFuosGRYGiAkW6iwZFuosGRbqLBkW6iwZFuosCxZXu8i2Kf/wTcrLSXTQo0l00KNJdNCgKFBUo0l00KNJdNCjSXTQo0l00KNJdFChudBcNinQXDYp0Fw2KdBcNigJFBYp0Fw2KdBcNinQXDYp0Fw2KdBcFio3uokGR7qJBke6iQZHuokFRoKhAke6iQZHuokGR7qJBke6iQZHuokCx0100KNJdNCjSXTQo0l00KAoUFSjSXTQo0l00KNJdNCjSXTQo0l3+nWJd6C4aFOkuGhTpLhoU6S4aFAWKChTpLhoU6S4aFOkuGhTpLhoU6S4KFBPdRYMi3UWD4jzdJdXBJa21X1DMfdnB5F7Lc3WRs6e9LPtrlEUOj13SDnKe+mIMUgCpA3KeEvMzkGVZ0niJbb0AmUve76yTRdJYndvZ824PsB+rW675YvXWZV+99V4uVpcnv1/PdF+7nD3pTZaBr14sTlvfWaeW1ovFy3jktLR+XPwxVvO0OsbK0VjNU3N/OFYPHvtLTIcd2heX/W1sFaXJcnbZn6fpGoOcp+z+FOQ2QOZ8BTI/HnG8xrJxobu40OV52r/VWH2AnEcApLXtW4u0pXYFsqzjJZbDu6L0s2eSShnTW9pzI9J2BZAnUgCmHCcyAKYcBY4qHCfq/6YcJyq8r+Qoo/D+ul3IkePZXqAtY6/eD1uqVU6bd0lnO/tHDXe8xSxpZF7y1a6xlDKG8Pic/26LOVGXZmJvMbETSQsm9hYTO5EdYmLvMLFlIvHExN5iYjF8TGysicWlMrGxJhZrzcTGmlhhYpnYUBPLSQwTG2tiOfNiYmNNLGdeTGysieXMi4mNNbGceTGxfzGxdl+2Fs68mNhYE8uZl/7E5ryNhz68xvOJZQaFUyz9GZTxNeMih68Zf3HVTMtYnaQeXuTZ8+jjEpu6HF7jtufJGU+kPPOyjHf+kssxz8+L67bnUvvhF1htj16I/q7Rc+oQK3oZNwFa1v5v0aPvbxs9HjxU9KnuP4rOqcnJ3g1LPFeeONSp8qwYxlB55tZ3IiW3P3/UprI9T096OgkfWXfj8LFk84Zf0774lw79px15xb4xJ9+ZE2FOmJNvzAleb+I5WQeQ+nvd+PmcIAGZk+/MCcbwBXMyrvePOckXcyK975KhLsf7KJ49tNS+3yZc1uONS/f7VVWM4YvzvPrOU5Lxvk9S2p/zXLdx5Ldu+SxPjOFUea4Yw7nyRALOlSdeL1SeLe/Pem2ynuSJf5srTyHPqfLEZ82VJ94pUp5b33af0JbfiJw98tKXIbKXXs/iRyfdOn7s063jR1bdOf4NtxUp/pbz/hofu7r87/Gjwm4dP+YsVJPr4xD54UTzSZ6Ys9u8nftJ/EL8d44fL3fr+NF4Kn8+bsOH6XBELOlwxNDE/bpf+XydbiiXufLEocyVJ1Lke3ku7Ys8PzgiI3Q4yl05SsnjInC4TdoXHNOzIKX8/IXF+X0rJe0PLXK4VV9vp2cu890xsN3WFcj4cU2Rw81QvxiqJdXxqfU4b3tmtJ4vlypj+eOz6Lj8A/xtW7o1+NvWemvwt/UA1uBvKw6MwffbNnxr8Let4q8F/+hyY/m6bH9efvetdb+tP2AI/QzhbeULQ+hnCIUhZAithxDT9fohzPlkM47pMgKP6TICj+kyAo/pegX4VPPzSK1u2yfw64LpMgKP6XoJ+HUZl5q0Hm42w9b689Z6XTBdrx/CUk7e/dgdI/AC+JeA73mA3+Tisru2cQ60tu35jel1D4nGHyAk7ECAkDAJAULCOgQICUPhP6SEzQgQEubDQUh92R/88e+2zyFhBgKEhEUIEJIQkv+QMA4BQsI4BAgJ4xAgJIxDgJAwDv5DyhiHACFhHAKEhHEIEBLGIUBIQkj+Q8I4BAgJ4xAgJIxDgJAwDgFCwjj4D6lgHAKEhHEIEBLGIUBIGIcAIQkh+Q8J4xAgJIxDgJAwDgFCwjgECAnj4D8kwTgECAnjECAkjEOAkDAOAUISQvIfEsYhQEgYhwAhYRwChIRxCBASxsF/SBXjECAkjEOAkDAOAULCOAQISQjJf0gYhwAhYRwChIRxCBASxiFASBgH/yGtGIcAIWEcAoSEcQgQEsYhQEhCSP5DwjgECAnjECAkjEOAkDAOAULCOPgPacM4BAgJ4xAgJIxDgJAwDgFCEkLyHxLGIUBIGIcAIWEcAoSEcQgQEsbBf0gN4xAgJIxDgJAwDgFCwjgECEkIyX9IGIcAIWEcAoSEcQgQEsYhQEgYB/8hdYxDgJAwDgFCwjgECAnjECAkIST/IWEcAoSEcQgQEsYhQEgYhwAhYRzch7QtGIcAIWEcAoSEcQgQEsYhQEhCSP5DwjgECAnjECAkjEOAkDAOAULCOPgPKWEcAoSEcQgQEsYhQEgYhwAhCSH5DwnjECAkjEOAkDAOAULCOAQICePgP6SMcQgQEsbBQ0giI6R6EhLGIUBIGIcAIQkhvTmkD/BYhJeA76UP8L2fgccMGIGn7RuBp8EbgaeV24AvNG0j8LRnI/A0YiPwtFwj8AJ4G/A0VyPwNFcj8DRXI/A0VyPwNFcb8EJzNQJPczUCT3M1Ak9zNQIvgLcBT3M1Ak9zNQJPczUCT3M1Ak9ztQFfaa5G4GmuRuBprkbgaa5G4AXwNuBprkbgaa5G4GmuRuBprkbgaa424FeaqxF4mqsReJqrEXiaqxF4AbwNeJqrEXiaqxF4mqsReJqrEXiaqw34jeZqBJ7magSe5moEnuZqBF4AbwOe5moEnuZqBJ7magSe5moEnuZqA77RXI3A01yNwNNcjcDTXI3AC+BtwNNcjcDTXI3A01yNwNNcjcDTXG3Ad5qrEXiaqxF4mqsReJqrEXgBvA14mqsReJqrEXiaqxF4mqsReJqrCfi20FyNwNNcjcDTXI3A01yNwAvgbcDTXF8CXvOvHbeFlhsgJBrxu0P6AE8jfgX4RaqM5XWpJ+BpxDbg020bcc07mrJWuQDfctq5t/zruX6szu1s9eP0ZF/9cD3lYnV5EinP55GXMyCPq9YAUi8W/zKrO4+W1ovFy3jktLR+XPwxKLdt8AzKzwbltsaBQfnZoMxjSPLjo3tfXUu+GJQ1j8de89VneE5Sx2MnaWef4QJIHZDzGIwXgqzPq0Bth6viE+M8juGnGNu+ei21XWzOZfBIVZ6X9FQHx3k0wA85lrUNju2C49pGx1nblj7JlDRPp7ekOE9BN6SY52nblhTnqaKWFOfpaZYUb1tiVCkKFL9BsS+7BHicZHw+Nsq3rS+qFG/bXlQp0l00KNJdNCjSXRQoFrqLBkW6iwZFuosGRbqLBkWBogJFuosGRbqLBkW6iwZFuosGRbqLAkWhu2hQpLtoUKS7aFCku2hQFCgqUKS7aFCku2hQpLtoUKS7aFCkuyhQrHQXDYp0Fw2KdBcNinQXDYoCRQWKdBcNinQXDYp0Fw2KdBcNinQXBYor3UWDIt1FgyLdRYMi3UWDokBRgSLdRYMi3UWDIt1FgyLdRYMi3UWB4kZ30aBId9GgSHfRoEh30aAoUFSgSHfRoEh30aBId9GgSHfRoEh3UaDY6C4aFOkuGhTpLhoU6S4aFAWKChTpLhoU6S4aFOkuGhTpLhoU6S4KFDvd5VsU//wn5DrdRYMi3UWDIt1Fg6JAUYEi3UWDIt1FgyLdRYMi3UWDIt3l3yn2he6iQZHuokGR7qJBke6iQVGgqECR7qJBke6iQZHuokGR7qJBke6iQDHRXTQo0l00KNJdNCjSXTQoChQVKNJdNCjSXTQo0l00KNJdNCjSXRQoZrqLBkW6iwZFuosGRbqLBkWBogJFuosGRbqLBkW6iwZFuosGRbqLAsVCd9GgSHfRoEh30aBId9GgKFBUoEh30aBId9GgSHfRoEh30aBId1GgKHQXDYp0Fw2K83SXVAeXtNZ+QTH3ZQeTey3P1UXOnvay7K9RFjk8dkk7yHnqizFIAaQOyHlKzM9AlmVJ4yW29QJkLnm/s04WSWN1bmfPu+W0r2655ovV2yOEj9Vb7+VidXny+/VM97XL2ZPeZBn46sXitPWddWppvVi8jEdOS+vHxR9jNU+rY6wcjdU8NfeHY/Xgsb/EdNihfXHZ38ZWUZosZ5f9eZquMch5yu5PQW4DZM5XIPPjEcdrLBsXuosLXZ2n/VuN1QfIeQRAWtu+tUhbalcgyzpeYjm8K0o/eyaplDG9pT03Im1XAHUiBWDKcSIDYMpR4KjCcaL+b8pxosL7So4yCm+SbT1yPNsLtGXs1fthS7XKafMu6Wxn/6jhjreYJY3MS77aNZZSxhAen/PfbTEn6tJM7C0mdiJpwcTeYmInskNM7B0mdp1IPDGxt5hYDB8TG2ticalMbKyJxVozsbEmVphYJjbUxHISw8TGmljOvJjYWBPLmRcTG2tiOfNiYmNNLGdeTOxfTKzdl603zryY2FgTy5mX/sTmvI2HPrzG84llBjdOsfRnUMbXjIscvmb8xVUzLWN1knp4kWfPo49L7K+f/z0Xb3uenPFEyjMvy3jnL7kc8/y8uG57LrUffoHV9uiF6O8aPacOsaKXcROgZe3/Fj36/rbR48FDRZ/q/qPonJqc7N2wxHPliUOdKs+GYQyVZ259J1Jy+/NHbSrb8/Skp5PwkXU3Dh9LNm/4Ne2LU5X8Tzvyhn1jTr4zJ8KcMCffmBO83sRzsg4g9fe68fM5QQIyJ9+ZE4zhC+ZkXO8fc5Iv5kR63yVDXY73UTx7aKl9v024rMcbl+73q2oYwxfnefWdpyTjfZ+ktD/nuW7jyG/d8lmeGMOp8uwYw7nyRALOlSdeL1SeLe/Pem2ynuSJf5srTyHPqfLEZ82VJ94pUp5b33af0JbfiJw98tKXIbKXXs/iRyfdOn7s063jR1bdN/5fv14g/kDxt5z31/jY1eV/jx8Vduv4MWehmlwfh8gPJ5pP8sSc3ebt3E/iF+K/c/x4uVvHj8ZT+PNxD474MB2OiCUdjhiauF/3K5+v0wnlMleeOJS58kSKfC/PpX2R5wdHZIQOR7krRyl5XAQOt0n7gmN6FqSUn7+wOL9vpaT9oUUOt+rr7fTMZbY7Bj6G6rauQMaPa4ocbob6xVA9QI1Prcd52zOj9Xy5VBnLH59Fx+Uf4G/b0q3B37bWW4O/rQewBn9bcWAMPt+24VuDv20Vfy342saddZZ12f68/O5b63xbf8AQ+hnC28oXhtDPEApDyBBaDyGm6/VDmPPJZhzTZQQe02UEHtNlBB7T9QrwqebnkVrdts/gC6bLCDym6yXg12VcatJ6uNkMW+uTrXXBdL1+CEs5efdjd4zAC+BfAr7nAX6Ti8vu2sY50Nq25zem9y9MFRp/gJCwAwFCwiQECAnrECAkDIX/kASbESAkzIeDkPqyP/jj322fQ8IMBAgJixAgJCEk/yFhHAKEhHEIEBLGIUBIGIcAIWEc/IdUMQ4BQsI4BAgJ4xAgJIxDgJCEkPyHhHEIEBLGIUBIGIcAIWEcAoSEcfAf0opxCBASxiFASBiHACFhHAKEJITkPySMQ4CQMA4BQsI4BAgJ4xAgJIyD/5A2jEOAkDAOAULCOAQICeMQICQhJP8hYRwChIRxCBASxiFASBiHACFhHPyH1DAOAULCOAQICeMQICSMQ4CQhJD8h4RxCBASxiFASBiHACFhHAKEhHHwH1LHOAQICeMQICSMQ4CQMA4BQhJC8h8SxiFASBiHACFhHAKEhHEIEBLGwX1IacE4BAgJ4xAgJIxDgJAwDgFCEkLyHxLGIUBIGIcAIWEcAoSEcQgQEsbBf0gJ4xAgJIxDgJAwDgFCwjgECEkIyX9IGIcAIWEcAoSEcQgQEsYhQEgYB/8hZYxDgJAwDgFCwjgECAnjECAkIST/IWEcAoSEcQgQEsYhQEgYhwAhYRz8h1QwDgFCwjgECAnjECAkjEOAkISQ/IeEcQgQEsYhQEgYhwAhYRwChIRx8B+SYBwChIRxCBASxiFASBiHACEJIfkPCeMQICSMQ4CQMA4BQsI4BAgJ4+A/pIpxCBASxsFDSCIjpHoSEsYhQEgYhwAhCSG9OaQP8FiEl4DvpQ/wvZ+BxwwYgaftG4GnwRuBp5XbgF9p2kbgac9G4GnERuBpuUbgBfA24GmuRuBprkbgaa5G4GmuRuBprjbgN5qrEXiaqxF4mqsReJqrEXgBvA14mqsReJqrEXiaqxF4mqsReJqrDfhGczUCT3M1Ak9zNQJPczUCL4C3AU9zNQJPczUCT3M1Ak9zNQJPc7UB32muRuBprkbgaa5G4GmuRuAF8Dbgaa5G4GmuRuBprkbgaa5G4GmuJuDzQnM1Ak9zNQJPczUCT3M1Ai+AtwFPczUCT3M1Ak9zNQJPczUCT3O1AZ9orkbgaa5G4GmuRuBprkbgBfA24GmuRuBprkbgaa5G4GmuRuBprjbgM83VCDzN1Qg8zdUIPM3VCLwA3gY8zdUIPM3VCDzN1Qg8zdUIPM3VBnyhuRqBp7kagae5GoGnuRqBF8DbgKe5vgS85l87zoWWGyAkGvG7Q/oATyN+BfhFqozldakn4GnENuDlto245h1NWatcgG857dxb/vVcP1bndrZ667Kv3novF6vLk0h5Po+8nAF5XLUGkHqxOG19p5daWi8WL+OR09L6cfHHoNy2wTMoPxuU2xoHBuVngzKPIcmPj+59dS35YlDWPB57zVef4TlJHY+dpJ19hgsgdUDOYzBeCLI+rwK1Ha6KT4zzOIafYmz76rXUdrE5l8EjVXle0lMdHOfRAD/kWNY2OLYLjmsbHWdtW/okU2SeTm9JcZ6CbkixztO2LSnOU0UtKc7T0ywp3rbEqFIUKH6DYl92CfA4yfh8bFRvW19UKd62vahSpLtoUKS7aFCkuyhQXOkuGhTpLhoU6S4aFOkuGhQFigoU6S4aFOkuGhTpLhoU6S4aFOkuChQ3uosGRbqLBkW6iwZFuosGRYGiAkW6iwZFuosGRbqLBkW6iwZFuosCxUZ30aBId9GgSHfRoEh30aAoUFSgSHfRoEh30aBId9GgSHfRoEh3UaDY6S4aFOkuGhTpLhoU6S4aFAWKChTpLhoU6S4aFOkuGhTpLhoU6S7/TrEsdBcNinQXDYp0Fw2KdBcNigJFBYp0Fw2KdBcNinQXDYp0Fw2KdBcFionuokGR7qJBke6iQZHuokFRoKhAke6iQZHuokGR7qJBke6iQZHuokAx012+RfGPf0KuZLqLBkW6iwZFuosGRYGiAkW6iwZFuosGRbqLBkW6iwZFuosCxUJ30aBId9GgSHfRoEh30aAoUFSgSHfRoEh30aBId9GgSHfRoEh3UaAodBcNinQXDYp0Fw2KdBcNigJFBYp0Fw2KdBcNinQXDYp0Fw2KdBcFipXuokGR7qJBke6iQZHuokFRoKhAke6iQZHuokGR7qJBke6iQZHuokBxpbtoUKS7aFCku2hQpLtoUBQoKlCku2hQpLtoUKS7aFCku2hQpLsoUNzoLhoU6S4aFOfpLqkOLmmt/YJi7ssOJvdanquLnD3tZdlfoyxyeOySdpDz1BdjkAJIHZDzlJifgSzLksZLbOsFyF93N9ifiUgaq3M7e94tp311yzVfrN667Ku33svF6vLk9+uZ7muXsye9yTLw1YvFaes769TSerF4GY+cltaPiz/Gap5Wx1g5Gqt5au4Px+rBY3+J6bBD++Kyv42tojRZzi778zRdY5DzlN2fgtwGyJyvQObHI47XWDYudBcXujZP+7caqw+Q8wiAtLZ9a5G21K5APsz6/hLL4V1R+tkzSaWM6X0wG6vbrgDaRArAlONEBsCUo8BRheNE/d+U40SF95UcZRTeJNt65Hi2F2jL2Kv3w5ZqldPmXdLZzv5Rwx1vMUsamZd8tWsspYwhPD7nv9tiTtSlmdhbTOxE0oKJvcXETmSHmNg7TGyfSDwxsbeYWAwfExtrYnGpTGysicVaM7GxJlaYWCY21MRyEsPExppYzryY2FgTy5kXExtrYjnzYmJjTSxnXkzsX0ys2ZetZeHMi4mNNbGceelPbM7beOjDazyfWGZw4RRLfwZlfM24yOFrxl9cNdMyViephxd59jz6uMSmLofXuO15csYTKc+8LOOdv+RyzPPz4rrtudR++AVW26MXor9r9Jw6xIpexk2AlrX/W/To+9tGjwcPFX2q+4+ic2pysnfDEs+VJw51qjwThjFUnrn1nUjJ7c8ftalsz9OTnk7CR9bdOHws2bzh17QvTlXyP+3IE/aNOfnOnAhzwpx8Y07wehPPyTqA1N/rxs/nBAnInHxnTjCGL5iTcb1/zEm+mBPpfZcMdTneR/HsoaX2/Tbhsh5vXLrueWIMX5zn1Xeekoz3fZLS/pznuo0jv3XLZ3liDKfKM2MM58oTCThXnni9UHm2vD/rtcl6kif+ba48hTynyhOfNVeeeKdIeW59231CW34jcvbIS1+GyF56PYsfnXTr+LFPt44fWXXn+AtuK1L8Lef9NT52dfnf40eF3Tp+zFmoJtfHIfLDieaTPDFnt3k795P4hfjvHD9e7tbxo/E0/nycFHyYDkfEkg5HDE3cr/uVz9dpQbnMlScOZa48kSLfy3NpX+T5wREZocNR7srx4SfHReBwm7QvOKZnQUr5+QuL8/tWStof+sH3eXnp7fTMZb47BsptXYGMH9cUOdwM9YuhWlIdn1qP87ZnRuv5cqkylj8+i47LP8DftqVbg79trbcGf1sPYA3+tuLAGHy9bcO3Bn/bKv5a8LWNO+ss67L9efndt9b1tv6AIfQzhLeVLwyhnyEUhpAhtB5CTNfrhzDnk804pssIPKbLCDymywg8pusV4FPNzyO1um2fwa+YLiPwmK6XgF+XcalJ6+FmM2ytT7bWK6br9UNYysm7H7tjBF4A/xLwPQ/wm1xcdtc2zoHWtj2/Mb1/YWql8QcICTsQICRMQoCQsA4BQsJQ+A9pw2YECAnz4SCkvuwP/vh32+eQMAMBQsIiBAhJCMl/SBiHACFhHAKEhHEIEBLGIUBIGAf/ITWMQ4CQMA4BQsI4BAgJ4xAgJCEk/yFhHAKEhHEIEBLGIUBIGIcAIWEc/IfUMQ4BQsI4BAgJ4xAgJIxDgJCEkPyHhHEIEBLGIUBIGIcAIWEcAoSEcXAfUl0wDgFCwjgECAnjECAkjEOAkISQ/IeEcQgQEsYhQEgYhwAhYRwChIRx8B9SwjgECAnjECAkjEOAkDAOAUISQvIfEsYhQEgYhwAhYRwChIRxCBASxsF/SBnjECAkjEOAkDAOAULCOAQISQjJf0gYhwAhYRwChIRxCBASxiFASBgH/yEVjEOAkDAOAULCOAQICeMQICQhJP8hYRwChIRxCBASxiFASBiHACFhHPyHJBiHACFhHAKEhHEIEBLGIUBIQkj+Q8I4BAgJ4xAgJIxDgJAwDgFCwjj4D6liHAKEhHEIEBLGIUBIGIcAIQkh+Q8J4xAgJIxDgJAwDgFCwjgECAnj4D+kFeMQICSMQ4CQMA4BQsI4BAhJCMl/SBiHACFhHAKEhHEIEBLGIUBIGAf/IW0YhwAhYRwChIRxCBASxiFASEJI/kPCOAQICeMQICSMQ4CQMA4BQsI4+A+pYRwChIRx8BCSyAipnoSEcQgQEsYhQEhCSG8O6QM8FuEl4HvpA3zvZ+AxA0bgaftG4GnwRuBp5TbgO03bCDzt2Qg8jdgIPC3XCLwA3gY8zdUIPM3VCDzN1Qg8zdUIPM3VBPy60FyNwNNcjcDTXI3A01yNwAvgbcDTXI3A01yNwNNcjcDTXI3A01xtwCeaqxF4mqsReJqrEXiaqxF4AbwNeJqrEXiaqxF4mqsReJqrEXiaqw34THM1Ak9zNQJPczUCT3M1Ai+AtwFPczUCT3M1Ak9zNQJPczUCT3O1AV9orkbgaa5G4GmuRuBprkbgBfA24GmuRuBprkbgaa5G4GmuRuBprjbgheZqBJ7magSe5moEnuZqBF4AbwOe5moEnuZqBJ7magSe5moEnuZqA77SXI3A01yNwNNcjcDTXI3AC+BtwNNcjcDTXI3A01yNwNNcjcDTXG3ArzRXI/A0VyPwNFcj8DRXI/ACeBvwNNeXgNf8a8frSssNEBKN+N0hfYCnEb8C/CJVxvK61BPwNGIb8NttG3HNO5ryOO24AN9y2rm3/Ou5fqzO7Wz11mVfvfVeLlaXJ5HyfB55OQPyuGoNIPVicdr6Ti+1tF4sXsYjp6X14+KPQbltg2dQfjYotzUODMrPBmUeQ5IfH9376lryxaCseTz2mq8+w3OSOh47STv7DBdA6oCcx2C8EGR9XgVqO1wVnxjncQw/xdj21Wup7WJzLoNHqvK8pKc6OM6jAX7IsaxtcGwXHNc2Os7atvRJpmzzdHpLivMUdEOKbZ62bUlxnipqSXGenmZJ8bYlRpWiQPEbFPuyS4DHScbnY6N22/qiSvG27UWVIt1FgyLdRYMi3UWBYqe7aFCku2hQpLtoUKS7aFAUKCpQpLtoUKS7aFCku2hQpLtoUKS7/DvFbaG7aFCku2hQpLtoUKS7aFAUKCpQpLtoUKS7aFCku2hQpLtoUKS7KFBMdBcNinQXDYp0Fw2KdBcNigJFBYp0Fw2KdBcNinQXDYp0Fw2KdBcFipnuokGR7qJBke6iQZHuokFRoKhAke6iQZHuokGR7qJBke6iQZHuokCx0F00KNJdNCjSXTQo0l00KAoUFSjSXTQo0l00KNJdNCjSXTQo0l0UKArdRYMi3UWDIt1FgyLdRYOiQFGBIt1FgyLdRYMi3UWDIt1FgyLdRYFipbt8i+If/4TcVukuGhTpLhoU6S4aFAWKChTpLhoU6S4aFOkuGhTpLhoU6S4KFFe6iwZFuosGRbqLBkW6iwZFgaICRbqLBkW6iwZFuosGRbqLBkW6iwLFje6iQZHuokGR7qJBke6iQVGgqECR7qJBke6iQZHuokGR7qJBke6iQLHRXTQo0l00KNJdNCjSXTQoChQVKNJdNCjSXTQo0l00KNJdNCjSXRQodrqLBkW6iwZFuosGRbqLBkWBogJFuosGRbqLBkW6iwZFuosGRbrLv1NsC91FgyLdRYPiPN0l1cElrbVfUMx92cHkXstzdZGzp70s+2uURQ6PXdIOcp76YgxSAKkDcp4S8zOQZVnSeIltvQCZS97vrJNF0lid29nzbjntq1uu+WL1o47vqx97p3Kxujz5/Xqm+9rl7Elvsgx89WJxenSInV5L68XiZTxyWlo/Lv4Yq3laHWPlaKzmqbk/HKsHj/0lpsMO7YvL/ja2itJkObvsz9N0jUHOU3Z/CnIbIHO+ApkfjzheY9m40F1c6NI87d9qrD5AziMA0tr2rUXaUrsCWdbxEsvhXVH62TNJpYzpLe25EWm7AkgTKQBTjhMZAFOOAkcVjhP1f1OOExXeV3KUUXiTbOuR49leoC1jr94PW6pVTpt3SWc7+0cNd7zFLGlkXvLVrrGUMobw+Jz/bos5UZdmYm8xsRNJCyb2FhM7kR1iYu8wsXki8cTE3mJiMXxMbKyJxaUysbEmFmvNxMaaWGFimdhQE8tJDBMba2I582JiY00sZ15MbKyJ5cyLiY01sZx5MbF/MbF2X7YunHkxsbEmljMv/YnNeRsPfXiN5xPLDBZOsfRnUMbXjIscvmb8xVUzLWN1knp4kWfPo49LbOpyeI3bnidnPJHyzMsy3vlLLsc8Py+u255L7YdfYLU9eiH6u0bPqUOs6GXcBGhZ+79Fj76/bfR48FDRp7r/KDqnJid7NyzxXHniUKfKUzCMofLMre9ESm5//qhNZXuenvR0Ej6y7sbhY8nmDb+mfXGqkv9pRy7YN+bkO3MizAlz8o05wetNPCfrAFJ/rxs/nxMkIHPynTnBGL5gTsb1/jEn+WJOpPddMtTleB/Fs4eW2vfbhMt6vHHpfr8qwRi+OM+r7zwlGe/7JKX9Oc91G0d+65bP8sQYTpVnxRjOlScScK488Xqh8mx5f9bro/Oc5Il/mytPIc+p8sRnzZUn3ilSnlvfdp/Qlt+InD3y0pchspdez+JHJ906fuzTreNHVt05/hW3FSn+lvP+Gh+7uvzv8aPCbh0/5ixUk+vjEPnhRPNJnpiz27yd+0n8Qvx3jh8vd+v40Xgqfz5uxYfpcEQs6XDE0MT9ul/5fJ3eUC5z5YlDmStPpMj38lzaF3l+cERG6HCUu3KUksdF4HCbtC84pmdBSvn5C4vz+1ZK2h9a5HCrvt5Oz1zmu2PgdltXIOPHNUUON0P9YqiWVMen1uO87ZnRer5cqozlj8+i4/IP8Ldt6dbgb1vrrcHf1gNYg7+tODAG327b8K3B37aKvxZ8bePOOsu6bH9efvetdbutP2AI/QzhbeULQ+hnCIUhZAithxDT9fohzPlkM47pMgKP6TICj+kyAo/pegX4VPPzSK1u22fwHdNlBB7T9RLw6zIuNWk93GyGrfXJ1rpjul4/hKWcvPuxO0bgBfAvAd/zAL/JxWV3beMcaG3b8xvT+xemOo0/QEjYgQAhYRIChIR1CBAShsJ9SH3BZgQICfPhIKS+7A/++Hfb55AwAwFCwiIECEkIyX9IGIcAIWEcAoSEcQgQEsYhQEgYB/8hJYxDgJAwDgFCwjgECAnjECAkIST/IWEcAoSEcQgQEsYhQEgYhwAhYRz8h5QxDgFCwjgECAnjECAkjEOAkISQ/IeEcQgQEsYhQEgYhwAhYRwChIRx8B9SwTgECAnjECAkjEOAkDAOAUISQvIfEsYhQEgYhwAhYRwChIRxCBASxsF/SIJxCBASxiFASBiHACFhHAKEJITkPySMQ4CQMA4BQsI4BAgJ4xAgJIyD/5AqxiFASBiHACFhHAKEhHEIEJIQkv+QMA4BQsI4BAgJ4xAgJIxDgJAwDv5DWjEOAULCOAQICeMQICSMQ4CQhJD8h4RxCBASxiFASBiHACFhHAKEhHHwH9KGcQgQEsYhQEgYhwAhYRwChCSE5D8kjEOAkDAOAULCOAQICeMQICSMg/+QGsYhQEgYhwAhYRwChIRxCBCSEJL/kDAOAULCOAQICeMQICSMQ4CQMA7+Q+oYhwAhYRwChIRxCBASxiFASEJI/kPCOAQICeMQICSMQ4CQMA4BQsI4eA+pLAvGIUBIGIcAIWEcAoSEcQgQkhCS/5AwDgFCwjgECAnjECAkjEOAkDAO/kNKGIcAIWEcPIQkMkKqJyFhHAKEhHEIEJIQ0ptD+gCPRXgJ+F76AN/7GXjMgBF42r4ReBq8EXhauQ34TNM2Ak97NgJPIzYCT8s1Ai+AtwFPczUCT3M1Ak9zNQJPczUCT3O1AV9orkbgaa5G4GmuRuBprkbgBfA24GmuRuBprkbgaa5G4GmuRuBprjbgheZqBJ7magSe5moEnuZqBF4AbwOe5moEnuZqBJ7magSe5moEnuZqA77SXI3A01yNwNNcjcDTXI3AC+BtwNNcjcDTXI3A01yNwNNcjcDTXG3ArzRXI/A0VyPwNFcj8DRXI/ACeBvwNFcj8DRXI/A0VyPwNFcj8DRXG/AbzdUIPM3VCDzN1Qg8zdUIvADeBjzN1Qg8zdUIPM3VCDzN1Qg8zdUGfKO5GoGnuRqBp7kagae5GoEXwNuAp7kagae5GoGnuRqBp7kagae52oDvNFcj8DRXI/A0VyPwNFcj8AJ4G/A015eAV/1rx52WGyAkGvG7Q/oATyN+BfhFqozldakn4GnEJuDTcttGXPOOpqxVLsC3nHbuLf96rh+rcztbvXXZV2+9l4vV5UmkPJ9HXs6APK5aA0i9WJy2vtNLLa0Xi5fxyOnhp46LPwbltg2eQfnZoNzWODAoPxuUeQxJfnx076tryReDsubx2Gu++gzPSep47CTt7DNcAKkDch6D8UKQ9XkVqO1wVXxinMcx/BRj21evpbaLzbkMHqnK85Ke6uA4jwb4IceytsGxXXBc2+g4a9vS/ytTHp89UFSgOE9BN6SY5mnblhTnqaKWFOfpaZYUb1tiVCkKFL9BsS+7BHicZGyfKd62vqhSvG17UaVId9GgSHfRoEh3UaCY6S4aFOkuGhTpLhoU6S4aFAWKChTpLhoU6S4aFOkuGhTpLhoU6S4KFAvdRYMi3UWDIt1FgyLdRYOiQFGBIt1FgyLdRYMi3UWDIt1FgyLdRYGi0F00KNJdNCjSXTQo0l00KAoUFSjSXTQo0l00KNJdNCjSXTQo0l0UKFa6iwZFuosGRbqLBkW6iwZFgaICRbqLBkW6iwZFuosGRbqLBkW6iwLFle6iQZHuokGR7qJBke6iQVGgqECR7qJBke6iQZHuokGR7qJBke6iQHGju2hQpLtoUKS7aFCku2hQFCgqUKS7aFCku2hQpLtoUKS7aFCkuyhQbHSXb1H845+QS43uokGR7qJBke6iQVGgqECR7qJBke6iQZHuokGR7qJBke6iQLHTXTQo0l00KNJdNCjSXTQoChQVKNJdNCjSXTQo0l00KNJdNCjSXf6dYl7oLhoU6S4aFOkuGhTpLhoUBYoKFOkuGhTpLhoU6S4aFOkuGhTpLgoUE91FgyLdRYMi3UWDIt1Fg6JAUYEi3UWDIt1FgyLdRYMi3UWDIt1FgWKmu2hQpLtoUKS7aFCku2hQFCgqUKS7aFCku2hQpLtoUKS7aFCkuyhQLHQXDYp0Fw2K83SXVAeXtNZ+QTH3ZQeTey3P1UXOnvay7K9RFjk8dkk7yHnqizFIAaQOyHlKzM9AlmVJ4yW29QLkg9R+Z50sksbq3M6ed3uca32sbrnmi9Vbl3311nu5WF2e/H49033tcvakN1kGvnqxOG19Z51aWi8WL+OR09L6cfHHWM3T6hgrR2M1T8394Vg9eOwvMR12aF9c9rexVZQmy9llf56mawxynrL7U5DbAJnzFcj8eMTxGsvGhe7iQifztH+rsfoAOY8ASGvbtxZpS+0KZFnHSyyHd0XpZ88klTKmt7TnRqTtCkAmUgCmHCcyAKYcBY4qHCfq/6YcJyq8r+Qoo/Am2dYjx7O9QFvGXr0ftlSrnDbvks529o8a7niLWdLIvOSrXWMpZQzh8Tn/3RZzoi7NxN5iYieSFkzsLSZ2IjvExN5hYutE4omJvcXEYviY2FgTi0tlYmNNLNaaiY01scLEMrGhJpaTGCY21sRy5sXExppYzryY2FgTy5kXExtrYjnzYmL/YmLtvmy9cubFxMaaWM689Cc252089OE1nk8sM7hyiqU/gzK+Zlzk8DXjL66aaRmrk9TDizx7Hn1cYlOXw2vc9jw544mUZ16W8c5fcjnm+Xlx3fZcaj/8Aqvt0QvR3zV6Th1iRS/jJkDL2v8tevT9baPHg4eKPtX9R9E5NTnZu2GJ58oThzpVnhuGMVSeufWdSMntzx+1qWzP05OeTsJH1t04fCzZvOHXtC9OVfI/7cg37Btz8p05EeaEOfnGnOD1Jp6TdQCpv9eNn88JEpA5+c6cYAxfMCfjev+Yk3wxJ9L7LhnqcryP4tlDS+37bcJlPd64dL9f1YYxfHGeV995SjLe90lK+3Oe6zaO/NYtn+WJMZwqz4YxnCtPJOBceeL1QuXZ8v6s1ybrSZ74t7nyFPKcKk981lx54p0i5bn1bfcJbfmNyNkjL30ZInvp9Sx+dNKt48c+3Tp+ZNWd4++4rUjxt5z31/jY1eV/jx8Vduv4MWehmlwfh8gPJ5pP8sSc3ebt3E/iF+K/c/x4uVvHj8ZT+fNxHR+mwxGxpMMRQxP3637l03W6LCiXufLEocyVJ1Lke3ku7Ys8PzgiI3Q4yl05SsnjInC4TdoXHNOzIKX8/IXF+X0rJe0PLXK4VV9vp2cu090xsCy3dQUyflxT5HAz1C+Gakl1fGo9ztueGa3ny6XKWP74LDou/wB/25ZuDf62td4a/G09gDX424oDY/Dptg3fGvxtq/hrwdc27qyzrMv25+V331qn2/oDhtDPEN5WvjCEfoZQGEKG0HoIMV2vH8KcTzbjmC4j8JguI/CYLiPwmK5XgE81P4/U6rZ9Bp8xXUbgMV0vAb8u41KT1sPNZthan2ytM6br9UNYysm7H7tjBF4A/xLwPQ/wm1xcdtc2zoHWtj2/Mb1/YSrT+AOEhB0IEBImIUBIWIcAIWEo/IdUsBkBQsJ8OAipL/uDP/7d9jkkzECAkLAIAUISQvIfEsYhQEgYhwAhYRwChIRxCBASxsF/SIJxCBASxiFASBiHACFhHAKEJITkPySMQ4CQMA4BQsI4BAgJ4xAgJIyD/5AqxiFASBiHACFhHAKEhHEIEJIQkv+QMA4BQsI4BAgJ4xAgJIxDgJAwDv5DWjEOAULCOAQICeMQICSMQ4CQhJD8h4RxCBASxiFASBiHACFhHAKEhHHwH9KGcQgQEsYhQEgYhwAhYRwChCSE5D8kjEOAkDAOAULCOAQICeMQICSMg/+QGsYhQEgYhwAhYRwChIRxCBCSEJL/kDAOAULCOAQICeMQICSMQ4CQMA7+Q+oYhwAhYRwChIRxCBASxiFASEJI/kPCOAQICeMQICSMQ4CQMA4BQsI4uA9JFoxDgJAwDgFCwjgECAnjECAkIST/IWEcAoSEcQgQEsYhQEgYhwAhYRz8h5QwDgFCwjgECAnjECAkjEOAkISQ/IeEcQgQEsYhQEgYhwAhYRwChIRx8B9SxjgECAnjECAkjEOAkDAOAUISQvIfEsYhQEgYhwAhYRwChIRxCBASxsF/SAXjECAkjEOAkDAOAULCOAQISQjJf0gYhwAhYRwChIRxCBASxiFASBgH/yEJxiFASBgHDyGJjJDqSUgYhwAhYRwChCSE9OaQPsBjEV4Cvpc+wPd+Bh4zYASetm8EngZvBJ5WbgO+0rSNwNOejcDTiI3A03KNwAvgbcDTXI3A01yNwNNcjcDTXI3A01xtwK80VyPwNFcj8DRXI/A0VyPwAngb8DRXI/A0VyPwNFcj8DRXI/A0VxvwG83VCDzN1Qg8zdUIPM3VCLwA3gY8zdUIPM3VCDzN1Qg8zdUIPM3VBnyjuRqBp7kagae5GoGnuRqBF8DbgKe5GoGnuRqBp7kagae5GoGnudqA7zRXI/A0VyPwNFcj8DRXI/ACeBvwNFcj8DRXI/A0VyPwNFcj8DRXE/B1obkagae5GoGnuRqBp7kagRfA24CnuRqBp7kagae5GoGnuRqBp7nagE80VyPwNFcj8DRXI/A0VyPwAngb8DRXI/A0VyPwNFcj8DRXI/A0VxvwmeZqBJ7magSe5moEnuZqBF4AbwOe5voS8Jp/7bhmWm6AkGjE7w7pAzyN+BXgF6kyltelnoCnEduAL7dtxI+N4v4S1yoX4FtOO/eWfz3Xj9W5na3euuyrt97LxeryJFKezyMvZ0AeV60BpF4sTlvf6aWW1ovFy3jktLR+XPwxKLdt8AzKzwbltsaBQfnZoMxjSPLjo3tf/XgDXAzKmsdjr/nqMzwnqeOxk7Szz3ABpA7IeQzGC0HW51WgtsNV8YlxHsfwU4xtX72W2i425zJ4pCrPS3qqg+M8GuCHHMvaBsd2wXFto+OsbUufZEqZp9NbUpynoBtSlHnatiXFeaqoJcV5epolxduWGFWKAsVvUOzLLgEeJxmfj43ktvVFleJt24sqRbqLBkW6iwZFuosCxUp30aBId9GgSHfRoEh30aAoUFSgSHfRoEh30aBId9GgSHfRoEh3UaC40l00KNJdNCjSXTQo0l00KAoUFSjSXTQo0l00KNJdNCjSXTQo0l0UKG50Fw2KdBcNinQXDYp0Fw2KAkUFinQXDYp0Fw2KdBcNinQXDYp0FwWKje6iQZHuokGR7qJBke6iQVGgqECR7qJBke6iQZHuokGR7qJBke6iQLHTXTQo0l00KNJdNCjSXTQoChQVKNJdNCjSXTQo0l00KNJdNCjSXf6d4rrQXTQo0l00KNJdNCjSXTQoChQVKNJdNCjSXTQo0l00KNJdNCjSXRQoJrrLtyj+8U/IrYnuokGR7qJBke6iQVGgqECR7qJBke6iQZHuokGR7qJBke6iQDHTXTQo0l00KNJdNCjSXTQoChQVKNJdNCjSXTQo0l00KNJdNCjSXRQoFrqLBkW6iwZFuosGRbqLBkWBogJFuosGRbqLBkW6iwZFuosGRbqLAkWhu2hQpLtoUKS7aFCku2hQFCgqUKS7aFCku2hQpLtoUKS7aFCkuyhQrHQXDYp0Fw2KdBcNinQXDYoCRQWKdBcNinQXDYp0Fw2KdBcNinQXBYor3UWDIt1Fg+I83SXVwSU9rlQXFHNfdjC51/JcXeTsaS/L/hplkcNjl7SDnKe+GIMUQOqAnKfE/AxkWZY0XmJbL0Dmkvc762SRNFbndva8W0776pZrvli9ddlXb72Xi9Xlye/XM93XLmdPepNl4KsXi9PWd9appfVi8TIeOS2tHxd/jNU8rY6xcjRW89TcH47Vg8f+EtNhh/bFZX8bW0Vpspxd9udpusYg5ym7PwW5DZA5X4HMj0ccr7FsXOguLnTbPO3faqw+QM4jANLa9q1F2lK7Avm4Nu0vsRzeFaWfPZNUypje0p4bkbYrgG0iBWDKcSIDYMpR4KjCcaL+b8pxosL7So4yCm+SbT1yPNsLtGXs1fthS7XKafMu6Wxn/6jhjreYJY3MS77aNZZSxhAen/PfbTEn6tJM7C0mdiJpwcTeYmInskNM7B0mtk0knpjYW0wsho+JjTWxuFQmNtbEYq2Z2FgTK0wsExtqYjmJYWJjTSxnXkxsrInlzIuJjTWxnHkxsbEmljMvJvYvJtbuy9adMy8mNtbEcualP7E5b+OhD6/xfGKZwc4plv4MyviacZHD14y/uGqmZaxOUg8v8ux59HGJTV0Or3Hb8+SMJ1KeeVnGO3/J5Zjn58V123Op/fALrLZHL0R/1+g5dYgVvYybAC1r/7fo0fe3jR4PHir6VPcfRefU5GTvhiWeK08c6kx5bguGMVSeufWdSMntzx+1qWzP05OeTsJH1t04fCzZvOHXtC9OVfK/7Mi3BfvGnHxnToQ5YU6+MSd4vYnnZB1A6u914+dzggRkTr4zJxjDF8zJuN4/5iRfzIn0vkuGuhzvo3j20FL7fptwWY83Ll33PDGGL87z6jtPScb7Pklpf85z3caR37rlszwxhlPlmTCGc+WJBJwrT7xeqDxb3p/12mQ9yRP/NleeQp5T5YnPmitPvFOkPLe+7T6hLb8ROXvkpS9DZC+9nsWPTrp1/NinW8ePrLpz/Bm3FSn+lvP+Gh+7uvzv8aPCbh0/5ixUk+vjEPnhRPNJnpiz27yd+0n8Qvx3jh8vd+v40Xgafz5uy/gwHY6IJR2OGJq4X/crn6/TBeUyV544lLnyRIp8L8+lfZHnB0dkhA5HuStHKXlcBA63SfuCY3oWpJSfv7A4v2+lpP2hRQ636uvt9MxlujsGbuW2rkDGj2uKHG6G+sVQLamOT63Hedszo/V8uVQZyx+fRcflH+Bv29Ktwd+21luDv60HsAZ/W3FgDF5u2/Ctwd+2ir8WfG3jzjrLumx/Xn73rbXc1h8whH6G8LbyhSH0M4TCEDKE1kOI6Xr9EOZ8shnHdBmBx3QZgcd0GYHHdL0CfKr5eaRWt+0z+IrpMgKP6XoJ+HUZl5q0Hm42w9b6ZGtdMV2vH8JSTt792B0j8AL4l4DveYDf5OKyu7ZxDrS27fmN6f0LU5XGHyAk7ECAkDAJAULCOgQICUPhP6QVmxEgJMyHg5D6sj/4499tn0PCDAQICYsQICQhJP8hYRwChIRxCBASxiFASBiHACFhHPyHtGEcAoSEcQgQEsYhQEgYhwAhCSH5DwnjECAkjEOAkDAOAULCOAQICePgP6SGcQgQEsYhQEgYhwAhYRwChCSE5D8kjEOAkDAOAULCOAQICeMQICSMg/+QOsYhQEgYhwAhYRwChIRxCBCSEJL/kDAOAULCOAQICeMQICSMQ4CQMA7uQ2oLxiFASBiHACFhHAKEhHEIEJIQkv+QMA4BQsI4BAgJ4xAgJIxDgJAwDv5DShiHACFhHAKEhHEIEBLGIUBIQkj+Q8I4BAgJ4xAgJIxDgJAwDgFCwjj4DyljHAKEhHEIEBLGIUBIGIcAIQkh+Q8J4xAgJIxDgJAwDgFCwjgECAnj4D+kgnEIEBLGIUBIGIcAIWEcAoQkhOQ/JIxDgJAwDgFCwjgECAnjECAkjIP/kATjECAkjEOAkDAOAULCOAQISQjJf0gYhwAhYRwChIRxCBASxiFASBgH/yFVjEOAkDAOAULCOAQICeMQICQhJP8hYRwChIRxCBASxiFASBiHACFhHPyHtGIcAoSEcQgQEsYhQEgYhwAhCSH5DwnjECAkjEOAkDAOAULCOAQICePgP6QN4xAgJIyDh5BERkj1JCSMQ4CQMA4BQhJCenNIH+CxCC8B30sf4Hs/A48ZMAJP2zcCT4M3Ak8rtwHfaNpG4GnPRuBpxEbgablG4AXwNuBprkbgaa5G4GmuRuBprkbgaa424DvN1Qg8zdUIPM3VCDzN1Qi8AN4GPM3VCDzN1Qg8zdUIPM3VCDzN1QR8X2iuRuBprkbgaa5G4GmuRuAF8Dbgaa5G4GmuRuBprkbgaa5G4GmuNuATzdUIPM3VCDzN1Qg8zdUIvADeBjzN1Qg8zdUIPM3VCDzN1Qg8zdUGfKa5GoGnuRqBp7kagae5GoEXwNuAp7kagae5GoGnuRqBp7kagae52oAvNFcj8DRXI/A0VyPwNFcj8AJ4G/A0VyPwNFcj8DRXI/A0VyPwNFcb8EJzNQJPczUCT3M1Ak9zNQIvgLcBT3M1Ak9zNQJPczUCT3M1Ak9ztQFfaa5G4GmuRuBprkbgaa5G4AXwNuBpri8Br/nXjnul5QYIiUb87pA+wNOIXwF+kSpjeV3qCXgasQ349baNuOYdTVmrXIBvOe3cW/71XD9W53a2entY/I/VW+/lYnV5EinP55GXMyCPq9YAUi8Wp63v9FJL68XiZTxyWlo/Lv4YlNs2eAblZ4NyW+PAoPxsUOYxJPnx0b2vriVfDMqax2Ov+eozPCep47GTtLPPcAGkDsh5DMYLQdbnVaC2w1XxiXEex/BTjG1fvZbaLjbnMnikKs9LeqqD4zwa4Iccy9oGx3bBcW2j46xtS59kyjpPp7ekOE9BN6S4zdO2LSnOU0UtKc7T0ywp3rbEqFIUKH6DYl92CfA4yfh8bLTdtr6oUrxte1GlSHfRoEh30aBId1Gg2OguGhTpLhoU6S4aFOkuGhQFigoU6S4aFOkuGhTpLhoU6S4aFOkuChQ73UWDIt1FgyLdRYMi3UWDokBRgSLdRYMi3UWDIt1FgyLdRYMi3eWfKcqy0F00KNJdNCjSXTQo0l00KAoUFSjSXTQo0l00KNJdNCjSXTQo0l0UKCa6iwZFuosGRbqLBkW6iwZFgaICRbqLBkW6iwZFuosGRbqLBkW6iwLFTHfRoEh30aBId9GgSHfRoChQVKBId9GgSHfRoEh30aBId9GgSHdRoFjoLhoU6S4aFOkuGhTpLhoUBYoKFOkuGhTpLhoU6S4aFOkuGhTpLgoUhe7yLYp/+hNyD4p0Fw2KdBcNinQXDYoCRQWKdBcNinQXDYp0Fw2KdBcNinQXBYqV7qJBke6iQZHuokGR7qJBUaCoQJHuokGR7qJBke6iQZHuokGR7qJAcaW7aFCku2hQpLtoUKS7aFAUKCpQpLtoUKS7aFCku2hQpLtoUKS7KFDc6C4aFOkuGhTpLhoU6S4aFAWKChTpLhoU6S4aFOkuGhTpLhoU6S4KFBvdRYMi3UWDIt1FgyLdRYOiQFGBIt1FgyLdRYMi3UWDIt1FgyLdRYFip7toUKS7aFCcp7ukOriktfYLirkvO5jca3muLnL2tJdlf42/fvV3WJ12kPPUF2OQAkgdkPOUmJ+BLMuSxkts6wXIXPJ+Z50sksbq3M6ed8tpX91yzRerty776q33crG6PPn9eqb72uXsSW+yDHz1YnHa+s46tbReLF7GI6fHfu+4+GOs5ml1jJWjsZqn5v5wrB489peYDju0Ly7729gqSpPl7LI/T9M1BjlP2f0pyG2AzPkKZH484niNZeNC9+cLXVrmaf9WY/UBch4BkNa2by3SltoVyLKOl1gO74rSz55JKmVMb2nPjUhbd44TKQBTjhMZAFOOAkcVjhP1f1OOExXeV3KUUXiTbOuR49leoC1jr94PW6pVTpt3SWc7+0cNd7zFLGlkXvLVrrGUMobw+Jz/bos5UZdmYm8xsRNJCyb2FhM7kR1iYu8wsWki8cTE3mJiMXxMbKyJxaUysbEmFmvNxMaaWGFimdhQE8tJDBMba2I582JiY00sZ15MbKyJ5cyLiY01sZx5MbF/MbF2X7bOnHkxsbEmljMv/YnNeRsPfXiN5xPLDGZOsfRnUMbXjIscvmb8xVUzLWN1knp4kWfPo49LbOpyeI3bnidnPJHyzMsy3vlLLsc8Py+u255L7YdfYLU9eiH6u0bPqUOs6GXcBGhZ+79Fj76/bfR48FDRp7r/KDqnJid7NyzxXHniUKfKs2AYQ+WZW9+JlNz+/FGbyvY8PenpJHxk3Y3Dx5LNG35N++JUJf/Tjrxg35iT78yJMCfMyTfmBK838ZysA0j9vW78fE6QgMzJd+YEY/iCORnX+8ec5Is5kd53yVCX430Uzx5aat9vEy7r8cal+/2qCsbwxXlefecpyXjfJyntz3mu2zjyW7d8lifGcKo8BWM4V55IwLnyxOuFyrPl/VmvTdaTPPFvc+Up5DlVnvisufLEO0XKc+vb7hPa8huRs0de+jJE9tLrWfzopFvHj326dfzIqjvHX3FbkeJvOe+v8bGry/8ePyrs1vFjzkI1uT4OkR9ONJ/kiTm7zdu5n8QvxH/n+PFyt44fjafy5+MqPkyHI2JJhyOGJu7X/crn6/SKcpkrTxzKXHkiRb6X59K+yPODIzJCh6PclaOUPC4Ch9ukfcExPQtSys9fWJzft1LS/tAih1v19XZ65jLfHQPX27oCGT+uKXK4GeoXQ7U8rMoAmbZnRuv5cqkylj8+i47LP8DftqVbg79trbcGf1sPYA3+tuLAGPx224ZvDf62Vfy14Gsbd9ZZ1mX78/K7b6232/oDhtDPEN5WvjCEfoZQGEKG0HoIMV2vH8KcTzbjmC4j8JguI/CYLiPwmK5XgE81P4/U6rZ9Bt8wXUbgMV0vAb8u41KT1sPNZthan2ytG6br9UNYysm7H7tjBF4A/xLwPQ/wm1xcdtc2zoHWtj2/Mb1/YarR+AOEhB0IEBImIUBIWIcAIWEo/IfUsRkBQsJ8OAipL/uDP/7d9jkkzECAkLAIAUISQvIfEsYhQEgYhwAhYRwChIRxCBASxsF9SHnBOAQICeMQICSMQ4CQMA4BQhJC8h8SxiFASBiHACFhHAKEhHEIEBLGwX9ICeMQICSMQ4CQMA4BQsI4BAhJCMl/SBiHACFhHAKEhHEIEBLGIUBIGAf/IWWMQ4CQMA4BQsI4BAgJ4xAgJCEk/yFhHAKEhHEIEBLGIUBIGIcAIWEc/IdUMA4BQsI4BAgJ4xAgJIxDgJCEkPyHhHEIEBLGIUBIGIcAIWEcAoSEcfAfkmAcAoSEcQgQEsYhQEgYhwAhCSH5DwnjECAkjEOAkDAOAULCOAQICePgP6SKcQgQEsYhQEgYhwAhYRwChCSE5D8kjEOAkDAOAULCOAQICeMQICSMg/+QVoxDgJAwDgFCwjgECAnjECAkIST/IWEcAoSEcQgQEsYhQEgYhwAhYRz8h7RhHAKEhHEIEBLGIUBIGIcAIQkh+Q8J4xAgJIxDgJAwDgFCwjgECAnj4D+khnEIEBLGIUBIGIcAIWEcAoQkhOQ/JIxDgJAwDgFCwjgECAnjECAkjIP/kDrGIUBIGIcAIWEcAoSEcQgQkhCS/5AwDgFCwjgECAnjECAkjEOAkDAO7kMqC8YhQEgYBw8hiYyQ6klIGIcAIWEcAoQkhPTmkD7AYxFeAr6XPsD3fgYeM2AEnrZvBJ4GbwSeVm4DPtG0jcDTno3A04iNwNNyjcAL4G3A01yNwNNcjcDTXI3A01yNwNNcbcBnmqsReJqrEXiaqxF4mqsReAG8DXiaqxF4mqsReJqrEXiaqxF4mqsN+EJzNQJPczUCT3M1Ak9zNQIvgLcBT3M1Ak9zNQJPczUCT3M1Ak9ztQEvNFcj8DRXI/A0VyPwNFcj8AJ4G/A0VyPwNFcj8DRXI/A0VyPwNFcb8JXmagSe5moEnuZqBJ7magReAG8DnuZqBJ7magSe5moEnuZqBJ7magN+pbkagae5GoGnuRqBp7kagRfA24CnuRqBp7kagae5GoGnuRqBp7nagN9orkbgaa5G4GmuRuBprkbgBfA24GmuRuBprkbgaa5G4GmuRuBprjbgG83VCDzN1Qg8zdUIPM3VCLwA3gY8zfUl4FX/2nGj5QYIiUb87pA+wNOIXwF+kSpjeV3qCXgasQ34fttGXPOOpqxVLsC3nHbuLf96rh+rcztbvXXZV2+9l4vV5UmkPJ9HXs6APK5aA0i9WJy2vtNLLa0Xi5fxyGlp/bj4Y1Bu2+AZlJ8Nym2NA4Pys0GZx5Dkx0f3vrqWfDEoax6Pvearz/CcpI7HTtLOPsMFkDog5zEYLwRZn1eB2g5XxSfGeRzDTzG2ffVaarvYnMvgkao8L+mpDo7zaIAfcixrGxzbBce1jY6zti19kil9nk5vSXGegm5HUZZ52rYlxXmqqCXFeXqaJcXblhhVigLFb1Dsyy4BHicZ22eKt60vqhRv215UKdJdNCjSXTQo0l0UKCa6iwZFuosGRbqLBkW6iwZFgaICRbqLBkW6iwZFuosGRbqLBkW6iwLFTHfRoEh30aBId9GgSHfRoChQVKBId9GgSHfRoEh30aBId9GgSHdRoFjoLhoU6S4aFOkuGhTpLhoUBYoKFOkuGhTpLhoU6S4aFOkuGhTpLgoUhe6iQZHuokGR7qJBke6iQVGgqECR7qJBke6iQZHuokGR7qJBke6iQLHSXTQo0l00KNJdNCjSXTQoChQVKNJdNCjSXTQo0l00KNJdNCjSXRQornQXDYp0Fw2KdBcNinQXDYoCRQWKdBcNinQXDYp0Fw2KdBcNinQXBYob3eVbFP/4J+Rko7toUKS7aFCku2hQFCgqUKS7aFCku2hQpLtoUKS7aFCkuyhQbHQXDYp0Fw2KdBcNinQXDYoCRQWKdBcNinQXDYp0Fw2KdBcNinQXBYqd7qJBke6iQZHuokGR7qJBUaCoQJHuokGR7qJBke6iQZHuokGR7vLvFOtCd9GgSHfRoEh30aBId9GgKFBUoEh30aBId9GgSHfRoEh30aBId1GgmOguGhTpLhoU6S4aFOkuGhQFigoU6S4aFOkuGhTpLhoU6S4aFOkuChQz3UWDIt1Fg+I83SXVwSWttV9QzH3ZweRey3N1kbOnvSz7a5RFDo9d0g5ynvpiDFIAqQNynhLzM5BlWdJ4iW29AJlL3u+sk0XSWJ3b2fNuOe2rW675YvXWZV+99V4uVpcnv1/PdF+7nD3pTZaBr14sTlvfWaeW1ovFy3jktLR+XPwxVvO0OsbK0VjNU3N/OFYPHvtLTIcd2heX/W1sFaXJcnbZn6fpGoOcp+z+FOQ2QOZ8BTI/HnG8xrJxobu40JV52r/VWH2AnEcApLXtW4u0pXYFsqzjJZbDu6L0s2eSShnTW9pzI9J2BVAmUgCmHCcyAKYcBY4qHCfq/6YcJyq8r+Qoo/Am2dYjx7O9QFvGXr0ftlSrnDbvks529o8a7niLWdLIvOSrXWMpZQzh8Tn/3RZzoi7NxN5iYieSFkzsLSZ2IjvExN5hYmUi8cTE3mJiMXxMbKyJxaUysbEmFmvNxMaaWGFimdhQE8tJDBMba2I582JiY00sZ15MbKyJ5cyLiY01sZx5MbF/MbF2X7aunHkxsbEmljMv/YnNeRsPfXiN5xPLDFZOsfRnUMbXjIscvmb8xVUzLWN1knp4kWfPo49LbOpyeI3bnidnPJHyzMsy3vlLLsc8Py+u255L7YdfYLU9eiH6u0bPqUOs6GXcBGhZ+79Fj76/bfR48FDRp7r/KDqnJid7NyzxXHniUKfKc8Uwhsozt74TKbn9+aM2le15etLTSfjIuhuHjyWbN/ya9sWpSv6nHfmKfWNOvjMnwpwwJ9+YE7zexHOyDiD197rx8zlBAjIn35kTjOEL5mRc7x9zki/mRHrfJUNdjvdRPHtoqX2/TbisxxuX7verWjGGL87z6jtPScb7Pklpf85z3caR37rlszwxhlPluWEM58oTCThXnni9UHm2vD/rtcl6kif+ba48hTynyhOfNVeeeKdIeW59231CW34jcvbIS1+GyF56PYsfnXTr+LFPt44fWXXn+BtuK1L8Lef9NT52dfnf40eF3Tp+zFmoJtfHIfLDieaTPDFnt3k795P4hfjvHD9e7tbxo/FU/nxcw4fpcEQs6XDE0MT9ul/5fJ3+v+z9wY7zurKFgb1LxhmIZIkiHyYIkgyCAEECJJned4//7Zbsvi03bXVJZJHf5ODfB5JNfqtarLUkU5nIpS89yVD60pNQ5D09p/RCzy+OhBE6HGVUjhL8dhF42ibtBUf3MEjOP35hsb9vpbj1o0WeturLafeeS387BuZhswLZflwT5Gkz1BdFNbl5W7Vu99seGsX9w2WW7fDbWvR8+Bf4YV16bfDD2vra4IfNAWqDHzY4qAs+TsM6/Nrgh7Xi54K/3VjeDo/T8vvhg7fWcRo2P6AI2ynCYcMXirCdIhSKkCKsXYQkXecXofc7zThJVyXwJF2VwJN0VQJP0nUGeDf7xy21eVl+gnckXZXAk3SdAv5mnDfw8WmzGVrrndbakXSdX4Qh7Pz1k+5UAi+APwV89hv4RQqX3Zi2+0AxLY8npuMqEo7fgEikAwZEIkkwIBKpgwGRSCjaF8mTZhgQieSjAZHytH747bzlp0gkAwZEIkUwIJIgUvsikTgYEInEwYBIJA4GRCJxMCASiUP7IgUSBwMikTgYEInEwYBIJA4GRBJEal8kEgcDIpE4GBCJxMGASCQOBkQicWhfJCFxMCASiYMBkUgcDIhE4mBAJEGk9kUicTAgEomDAZFIHAyIROJgQCQSh/ZFmkkcDIhE4mBAJBIHAyKROBgQSRCpfZFIHAyIROJgQCQSBwMikTgYEInEoX2RIomDAZFIHAyIROJgQCQSBwMiCSK1LxKJgwGRSBwMiETiYEAkEgcDIpE4tC/SQuJgQCQSBwMikTgYEInEwYBIgkjti0TiYEAkEgcDIpE4GBCJxMGASCQO7YuUSBwMiETiYEAkEgcDIpE4GBBJEKl9kUgcDIhE4mBAJBIHAyKROBgQicShfZEyiYMBkUgcDIhE4mBAJBIHAyIJIrUvEomDAZFIHAyIROJgQCQSBwMikTg0L9IykTgYEInEwYBIJA4GRCJxMCCSIFL7IpE4GBCJxMGASCQOBkQicTAgEolD+yI5EgcDIpE4GBCJxMGASCQOBkQSRGpfJBIHAyKROBgQicTBgEgkDgZEInFoXyRP4mBAJBIHAyKROBgQicTBgEiCSO2LROJgQCQSBwMikTgYEInEwYBIJA7tixRIHAyIROLQgkgim0jzjkgkDgZEInEwIJIg0sUifYEnRTgFfA55A5/zHniSgUrgcfuVwOPgK4HHldcBLzjtSuBxz5XA44grgcflVgIvgK8DHudaCTzOtRJ4nGsl8DjXSuBxrnXAzzjXSuBxrpXA41wrgce5VgIvgK8DHudaCTzOtRJ4nGsl8DjXSuBxrnXAR5xrJfA410rgca6VwONcK4EXwNcBj3OtBB7nWgk8zrUSeJxrJfA41zrgF5xrJfA410rgca6VwONcK4EXwNcBj3OtBB7nWgk8zrUSeJxrJfA41zrgE861EnicayXwONdK4HGulcAL4OuAx7lWAo9zrQQe51oJPM61Enicax3wGedaCTzOtRJ4nGsl8DjXSuAF8HXA41wrgce5VgKPc60EHudaCTzOtQr4NOFcK4HHuVYCj3OtBB7nWgm8AL4OeJxrJfA410rgca6VwONcK4HHudYB73CulcDjXCuBx7lWAo9zrQReAF8HPM71FPCabztODpdrQCQc8dUifYHHEZ8BfpJZtsPnad4BjyOuA94P64hnv6IJcZYC+OTdyj35f2P9OtqnvaOXLOvRS86hcHR4EAmPcfhpD8jtqrUBmQsHuyWv9Nxt3S8cPG2f7KaUnw/+KpRhHTyF8lmhDJs4UCifFUo/CYm/Ld3r0XPwhUKJfvvs6EtruHcyb5/tJO2t4QJIHZD9JBgngpwfV4E5PV0VHxj7yRg+xZjWo2OYU6E5l42Hm+VxSXfzxrGfGOBDjiGmjWMqcIxp8zgxLe5HmOL78fQ1KfZj0CtSDP247ZoU+7GiNSn249NqUhzWxKhSFCi+QTFPawhwu5Px87ZRGNa+qFIc1r2oUsS7aFDEu2hQxLsoUBS8iwZFvIsGRbyLBkW8iwZFgaICRbyLBkW8iwZFvIsGRbyLBkW8iwLFGe+iQRHvokER76JBEe+iQVGgqEAR76JBEe+iQRHvokER76JBEe+iQDHiXTQo4l00KOJdNCjiXTQoChQVKOJdNCjiXTQo4l00KOJdNCjiXRQoLngXDYp4Fw2KeBcNingXDYoCRQWKeBcNingXDYp4Fw2KeBcNingXBYoJ76JBEe+iQRHvokER76JBUaCoQBHvokER76JBEe+iQRHvokER76JAMeNdNCjiXTQo4l00KOJdNCgKFBUo4l00KOJdNCjiXTQo4l00KOJd/k4xT3iXtyj++gq5POFdNCjiXTQo4l00KAoUFSjiXTQo4l00KOJdNCjiXTQo4l0UKDq8iwZFvIsGRbyLBkW8iwZFgaICRbyLBkW8iwZFvIsGRbyLBkW8iwJFj3fRoIh30aCId9GgiHfRoChQVKCId9GgiHfRoIh30aCId9GgiHdRoBjwLhoU8S4aFPEuGhTxLhoUBYoKFPEuGhTxLhoU8S4aFPEuGhTxLgoUBe+iQRHvokER76JBEe+iQVGgqEAR76JBEe+iQRHvokER76JBEe+iQHHGu2hQxLtoUOzHu7h54+LinAsUfZ5WMD7P4XF0kL1hT9M6R5nk6bODW0H2Y18qgxRA6oDsx8R8BjJMk9ummGIBpA9+3VnHi7jtaJ/2xp28W49OfvaFo5ebk/w6esk5FI4OD37/RroeO+0NepFpwzcXDnZLXlm75GLh4Gn7ZDel/HzwV1n14+ooq4bKqh+b+2FZ3XisU3RPHdqLy/6ytYqSZNq77PfjdCuD7Mfsfgpy2UB6XwLpb5+4zTEsXOgKF7rYj/uvVVZfIPsJAFxMa2vhFpdKIEPcphie/ipC3huJC2Gr3pAejUhaI4DYUQRQlWNHCUBVjgJHFY4d+f+qHDsyvGdylM3wOlniM8e9XiBNW6+en1qqKLvOO7i9zv5mwxtuMYPbNA++1DWGELYifB7zsRazIy9NxQ5RsR2FFlTsEBXbUTpExY5QsUtHwRMVO0TFkvBRsbYqliyVirVVsaTWVKytihUqloo1VbHciaFibVUs97yoWFsVyz0vKtZWxXLPi4q1VbHc86JiD1RsvYetE/e8qFhbFcs9L/2K9X7ZPvppjvsVSw0m7mLp16BsjxkHeXrM+MVV003b0U7mp0nujSNvl1iX5WmOy6on93gs6emnafvLn3x41vPnwfOy6jLnp19gpVV6QfpRpeeugy3pZdsEaIr5b9IT3w8rPTm4KendvP4o2rskO70bKXFfepKhdqVnJmE0padPeSUSfPp9qXVhedw9yW5HfMK6gcUnJetX/NmtB7tZ/J868kz6Rp28UydCnVAnb9QJuV7HdRI3IPN3u/F5nRACUifv1AmJ4Ql1sl3vb3XiC3Vy02ANGebpeR/FvY+WOa/bhEt83rh03a8qkxierGfpmScn29+9k5B+1zMu2y2/uPg9PUkMO9Jzvt3hRc+u9CQE7EtPcj1Teia/jjomiTt6kr/1paegZ1d6kmf1pSe5kyU9l7yseUKavhHZ++QpT1uQPeV5T37ipKHlJ30aWn7CqpHld2RbluRP3q9zvHV1/u/yE4UNLT/JmSknl7ebyLdM1O/oSXI2zJ9z3pFfkH9k+cnlhpafGE/h9XE3juRhOhwJlnQ4ktDYfdwv/LxOeyKXvvQkQ+lLT0KR9/Sc0gs9vzgSRuhwlFE5SvDbReBpm7QXHN3DIDn/+IXF/r6V4taPFnnaqi+n3Xsuve0YeCuqYbMC2X5cE+RpM9QXRXULVbZV6+YMHxrF/cNllu3w21r0fPgX+GFdem3ww9r62uCHzQFqgx82OKgMPgzr8GuDH9aKnwt+TtvOOlOclt8PH721DsPmBxRhO0U4bPhCEbZThEIRUoS1i5Ck6/wi9H6nGSfpqgSepKsSeJKuSuBJus4A72b/uKU2L8tP8ELSVQk8Sdcp4OO0XWpcfNpshtZ6p7UWkq7zizCEnb9+0p1K4AXwp4DPfgO/SOGyG9N2Hyim5fHE9PrAlOD4DYhEOmBAJJIEAyKROhgQiYSifZFm0gwDIpF8NCBSntYPv523/BSJZMCASKQIBkQSRGpfJBIHAyKROBgQicTBgEgkDgZEInFoX6RI4mBAJBIHAyKROBgQicTBgEiCSO2LROJgQCQSBwMikTgYEInEwYBIJA7ti7SQOBgQicTBgEgkDgZEInEwIJIgUvsikTgYEInEwYBIJA4GRCJxMCASiUP7IiUSBwMikTgYEInEwYBIJA4GRBJEal8kEgcDIpE4GBCJxMGASCQOBkQicWhfpEziYEAkEgcDIpE4GBCJxMGASIJI7YtE4mBAJBIHAyKROBgQicTBgEgkDs2L5CYSBwMikTgYEInEwYBIJA4GRBJEal8kEgcDIpE4GBCJxMGASCQOBkQicWhfJEfiYEAkEgcDIpE4GBCJxMGASIJI7YtE4mBAJBIHAyKROBgQicTBgEgkDu2L5EkcDIhE4mBAJBIHAyKROBgQSRCpfZFIHAyIROJgQCQSBwMikTgYEInEoX2RAomDAZFIHAyIROJgQCQSBwMiCSK1LxKJgwGRSBwMiETiYEAkEgcDIpE4tC+SkDgYEInEwYBIJA4GRCJxMCCSIFL7IpE4GBCJxMGASCQOBkQicTAgEolD+yLNJA4GRCJxMCASiYMBkUgcDIgkiNS+SCQOBkQicTAgEomDAZFIHAyIROLQvkiRxMGASCQOLYgksok074hE4mBAJBIHAyIJIl0s0hd4UoRTwOeQN/A574EnGagEHrdfCTwOvhJ4XHkd8AtOuxJ43HMl8DjiSuBxuZXAC+DrgMe5VgKPc60EHudaCTzOtRJ4nGsd8AnnWgk8zrUSeJxrJfA410rgBfB1wONcK4HHuVYCj3OtBB7nWgk8zrUO+IxzrQQe51oJPM61EnicayXwAvg64HGulcDjXCuBx7lWAo9zrQQe51oFvJ9wrpXA41wrgce5VgKPc60EXgBfBzzOtRJ4nGsl8DjXSuBxrpXA41zrgHc410rgca6VwONcK4HHuVYCL4CvAx7nWgk8zrUSeJxrJfA410rgca51wHucayXwONdK4HGulcDjXCuBF8DXAY9zrQQe51oJPM61EnicayXwONc64APOtRJ4nGsl8DjXSuBxrpXAC+DrgMe5VgKPc60EHudaCTzOtRJ4nGsd8IJzrQQe51oJPM61EnicayXwAvg64HGup4DXfNuxF1yuAZFwxFeL9AUeR3wG+Elm2Q6fp3kHPI64Dvh5WEd8K7p1inGWAvjk3co9+X9j/Trap72jlyzr0UvOoXB0eBAJj3H4aQ/I7aq1AZkLB7slr/RccrFw8LR9sptSfj74q1CGdfAUymeFMmziQKF8Vij9JCS3/mUd9G1EvlAo0W+fHX1pDfdO5u2znaS9NVwAqQOynwTjRJDz4yowp6er4gNjPxnDpxjTenQMcyo057LxcLM8Lulu3jj2EwN8yDHEtHFMBY4xbR4npsX9CFPmfjx9TYr9GPSKFGM/brsmxX6saE2K/fi0mhSHNTGqFAWKb1DM0xoC3O5k/LxtFIe1L6oUh3UvqhTxLhoU8S4aFPEuChQXvIsGRbyLBkW8iwZFvIsGRYGiAkW8iwZFvIsGRbyLBkW8iwZFvIsCxYR30aCId9GgiHfRoIh30aAoUFSgiHfRoIh30aCId9GgiHfRoIh3UaCY8S4aFPEuGhTxLhoU8S4aFAWKChTxLhoU8S4aFPEuGhTxLhoU8S5/pxgmvIsGRbyLBkW8iwZFvIsGRYGiAkW8iwZFvIsGRbyLBkW8iwZFvIsCRYd30aCId9GgiHfRoIh30aAoUFSgiHfRoIh30aCId9GgiHfRoIh3UaDo8S4aFPEuGhTxLhoU8S4aFAWKChTxLhoU8S4aFPEuGhTxLhoU8S4KFAPe5S2Kv75CLgS8iwZFvIsGRbyLBkWBogJFvIsGRbyLBkW8iwZFvIsGRbyLAkXBu2hQxLtoUMS7aFDEu2hQFCgqUMS7aFDEu2hQxLtoUMS7aFDEuyhQnPEuGhTxLhoU8S4aFPEuGhQFigoU8S4aFPEuGhTxLhoU8S4aFPEuChQj3kWDIt5FgyLeRYMi3kWDokBRgSLeRYMi3kWDIt5FgyLeRYMi3kWB4oJ30aCId9GgiHfRoIh30aAoUFSgiHfRoIh30aCId9GgiHfRoIh3UaCY8C4aFPEuGhT78S5u3ri4OOcCRZ+nFYzPc3gcHWRv2NO0zlEmefrs4FaQ/diXyiAFkDog+zExn4EM0+S2KaZYAOmDX3fW8SJuO9qnvXEn79ajk5994egly3r0knMoHB0e/P6NdD122hv0ItOGby4c7Ja8snbJxcLB0/bJbkr5+eCvsurH1VFWDZVVPzb3w7K68Vin6J46tBeX/WVrFSXJtHfZ78fpVgbZj9n9FOSygfS+BNLfPnGbY1i40BUudLkf91+rrL5A9hMAuJjW1sItLpVAhrhNMTz9VYS8NxIXwla9t9BkOzqtEUDuKAKoyrGjBKAqR4GjCseO/H9Vjh0Z3jM5ymZ4nSzxmeNeL5CmrVfPTy1VlF3nHdxeZ3+z4Q23mMFtmgdf6hpDCFsRPo/5WIvZkZemYoeo2I5CCyp2iIrtKB2iYgeo2NsNQyqWijVVsSR8VKytiiVLpWJtVSypNRVrq2KFiqViTVUsd2KoWFsVyz0vKtZWxXLPi4q1VbHc86JibVUs97yo2AMVW+1ha3Hc86JibVUs97z0K9b7ZfvopznuVyw16LiLpV+Dsj1mHOTpMeMXV003bUc7mZ8muTeOvF1iXZanOS6rntzjsaSnn6btL3/y4VnPnwfPy6rLnJ9+gZVW6QXpR5Weuw62pJdtE6Ap5r9JT3w/rPTk4Kakd/P6o2jvkuz0bqTEfelJhtqVnp6E0ZSePuWVSPDp96XWheVx9yS7HfEJ6wYWn5SsX/Fntx7sbkr/qSP3pG/UyTt1ItQJdfJGnZDrdVwncQMyf7cbn9cJISB18k6dkBieUCfb9f5WJ75QJ5LzGjLM0/M+insfLXNetwmX+LxxaVz1JDE8Wc/SM09Otr97JyH9rmdctlt+cfF7epIYdqVnIDHsS09CwL70JNczpWfy66hjkrijJ/lbX3oKenalJ3lWX3qSO1nSc8nLmiek6RuRvU+e8rQF2VOe9+QnThpaftKnoeUnrBpZfiHbsiR/8n6d462r83+XnyhsaPlJzkw5ubzdRL5lon5HT5KzYf6c8478gvwjy08uN7T8xHgar48TIQ/T4UiwpMORhMbu437h53V6JnLpS08ylL70JBR5T88pvdDziyNhhA5HGZWjBL9dBJ62SXvB0T0MkvOPX1js71spbv3oW2ryuLzktHvPpb8dA+dhswLZflwT5Gkz1BdFNbl5W7Vu99seGsX9w29/rdvht7Xo+fAv8MO69Nrgh7X1tcEPmwPUBj9scFAZfBzW4dcGP6wVPxf8nLaddaY4Lb8fPnprHYfNDyjCdopw2PCFImynCIUipAhrFyFJ1/lF6P1OM07SVQk8SVcl8CRdlcCTdJ0B3s3+cUttXpaf4BeSrkrgSbpOAR+n7VLj4tNmM7TWO631QtJ1fhGGsPPXT7pTCbwA/hTw2W/gFylcdmPa7gPFtDyemF4fmFpw/AZEIh0wIBJJggGRSB0MiERC0b5IiTTDgEgkHw2IlKf1w2/nLT9FIhkwIBIpggGRBJHaF4nEwYBIJA4GRCJxMCASiYMBkUgc2hcpkzgYEInEwYBIJA4GRCJxMCCSIFL7IpE4GBCJxMGASCQOBkQicTAgEolD8yLNE4mDAZFIHAyIROJgQCQSBwMiCSK1LxKJgwGRSBwMiETiYEAkEgcDIpE4tC+SI3EwIBKJgwGRSBwMiETiYEAkQaT2RSJxMCASiYMBkUgcDIhE4mBAJBKH9kXyJA4GRCJxMCASiYMBkUgcDIgkiNS+SCQOBkQicTAgEomDAZFIHAyIROLQvkiBxMGASCQOBkQicTAgEomDAZEEkdoXicTBgEgkDgZEInEwIBKJgwGRSBzaF0lIHAyIROJgQCQSBwMikTgYEEkQqX2RSBwMiETiYEAkEgcDIpE4GBCJxKF9kWYSBwMikTgYEInEwYBIJA4GRBJEal8kEgcDIpE4GBCJxMGASCQOBkQicWhfpEjiYEAkEgcDIpE4GBCJxMGASIJI7YtE4mBAJBIHAyKROBgQicTBgEgkDu2LtJA4GBCJxMGASCQOBkQicTAgkiBS+yKROBgQicTBgEgkDgZEInEwIBKJQ/siJRIHAyKROBgQicTBgEgkDgZEEkRqXyQSBwMikTgYEInEwYBIJA5Xi/QFnhThFPA55A18zjvgM8lAJfC4/UrgcfCVwOPKK4EXwNcBj3uuBB5HXAk8LrcSeJxrJfA41yrg44RzrQQe51oJPM61EnicayXwAvg64HGulcDjXCuBx7lWAo9zrQQe51oHvMO5VgKPc60EHudaCTzOtRJ4AXwd8DjXSuBxrpXA41wrgce5VgKPc60D3uNcK4HHuVYCj3OtBB7nWgm8AL4OeJxrJfA410rgca6VwONcK4HHudYBH3CulcDjXCuBx7lWAo9zrQReAF8HPM61EnicayXwONdK4HGulcDjXOuAF5xrJfA410rgca6VwONcK4EXwNcBj3OtBB7nWgk8zrUSeJxrJfA41zrgZ5xrJfA410rgca6VwONcK4EXwNcBj3OtBB7nWgk8zrUSeJxrJfA41zrgI861EnicayXwONdK4HGulcAL4OuAx7lWAo9zrQQe51oJPM61Enic6yngSy/SjQvO9Qzwk8yyHT5P8w54nGsl8MM619mvaMLtPlwBfPJu5Z78v7F+He3T3tFLlvXoJedQODo8iITHOPy0B+R21dqAzIWD3ZJXei65WDh42j7ZTSk/H/xVKMM6bQrls0IRCoVCeadQ+kky/G3pXo+egy8USvTbZ0dfWsO9k3n7bCdpbw3vJ5moDLKfpOFTkGk9OoY5FbpK2Xi4WR7XIjdvHPsJDj7kGGLaOKYCx5i25jymxT0OXin2kwJUpJj6sfQ1Kfbjz2tS7Mds16TYjxM9k2KeVsdwiz2XnxQFigoUh/UwqhSHNTCqFId1L6oU8S4aFPEuChQz3kWDIt5FgyLeRYMi3kWDokBRgSLeRYMi3kWDIt5FgyLeRYMi3uXvFJcJ76JBEe+iQRHvokER76JBUaCoQBHvokER76JBEe+iQRHvokER76JA0eFdNCjiXTQo4l00KOJdNCgKFBUo4l00KOJdNCjiXTQo4l00KOJdFCh6vIsGRbyLBkW8iwZFvIsGRYGiAkW8iwZFvIsGRbyLBkW8iwZFvIsCxYB30aCId9GgiHfRoIh30aAoUFSgiHfRoIh30aCId9GgiHfRoIh3UaAoeBcNingXDYp4Fw2KeBcNigJFBYp4Fw2KeJe3KMq2/2KedyjiXTQo4l00KOJdFCjOeBcNingXDYp4Fw2KeBcNigJFBYp4Fw2KeBcNingXDYp4Fw2KeBcFihHvokER76JBEe+iQRHvokFRoKhAEe+iQRHvokER76JBEe+iQRHvokBxwbtoUMS7aFDEu2hQxLtoUBQoKlDEu2hQxLtoUMS7aFDEu2hQxLsoUEx4Fw2KeBcNingXDYp4Fw2KAkUFingXDYp4Fw2KeBcNingXDYp4FwWKGe+iQRHvokER76JBEe+iQVEupigprxRn943i14Dm1gYUWxvQ0tqAUmsDym0NKF3+ZuzigFxrA/KtDSi0NqDGrtRpauxKnabGrtRpauxKnabGrtRpau1K7Vq7UrvWrtSutSu1a+1K7Vq7UrvWrtSutSu1a+1K7Vq7UrvWrtS+tSu1b+1K7Vu7UvvWrtS+tSu1b+1K7Vu7UvvWrtS+tSu1b+1KHVq7UofWrtShtSt1aO1KHVq7UofWrtShtSt1aO1KHVq7UofWrtTS2pVaWrtSS2tXamntSi2tXamltSu1tHalltau1NLalVpau1LPrV2p59au1HNrV+q5tSv13NqVem7tSj23dqWeW7tSz61dqefWrtSxtSt1bO1KHVu7UsfWrtSxtSt1bO1KHVu7UsfWrtSxtSt1bO1KvbR2pV5au1IvrV2pl9au1EtrV+qltSv10tqVemntSr20dqVeWrtSp9au1Km1K7XG/ghz2H7DMj/9dOTxHeGC75ALvmO+4DviBd+xXPAd6YLvyOd/h8bvQeO0/cFG73e+w13wHRp/5+nBKhcuPG4J7utgt8zTzoBCawOS1gY0XzygLH4dUF6mwsIS/bawxPD4wwl5G368dvh+mtdfMPop5sJc52n9ZPf8d7//u8vo1190Rin96tInt/7q0t8yvW9gfh6dfFqZ3+5hL8Wj3foS2+Tnx0huH7Jz9JJlPXrJORSODo9frQZ5HDvtTTG47WITfPz9YBfCerALz2PePXiSdRRuSvn54K+iWiiqTotq2aT3y1w42C15I51c/GtRJYqKotIuqjxkUYVpytsEJRXKxN2+fes5XEyOsvq9rLLGL8QbKatlsyypWFbJrR+c00NIt/bKWeN36o1gSbL+Ad1y/QKWfzf6vw7+FylvR+9u8eGdzNv2IU7S/Hz4F0YPRg2MAYwaGAWMGhhnMGpg7CfPqIpx18EH59dWLTiR3zGKi49Wzaenyc57aGLaAojlKa1wNwG+hpTaG1Jubkj7O17UHZJrb0i+vSGF9oYk7Q1pbm9Isb0htXf1dldfvX1YtoVZZrc3pKuv3t77LcqT5TulvZAhyBYyzKWje0xR/IRAbQt09cruJW8CzWEuIM9bHOWm+MiukiOz3BPTNy2m82n7axPvntX8Gn8wPn5pe/x5ewbH5Rh+/2u6/VGsf0zu6W9pybsX3cd9au+Xb0d/kZkh84JMhMwLMsuoZILfyMgumQSZF2QyZPbJhGlUMvODzFMI+0Sm7Ra4JpnG+8mKZBrvVE9ctZ/I+D0yMiqZ7f6U9znukRm2By6SGbYHLpIZtgd+us7k3X6mox44xUeu8/TJ+2g6fNo8h47a9kbErJdCSkdOAzE7MkdqYn6had0duS2tzk/PQO2vzbJiXOJjGH732XCf4jpDn56eJHdpBdO6OaoGRgCzD6Z1a1QNTOvOqBqY1o1RNTCt+6JqYFr3GLXAzK3369XAtN77VgND5/sCDJ3vCzACmH0wdL4vwND5vgBD5/sCDJ3vCzB0vvtgIp3vCzB0vi/A0Pm+AEPn+wKMAGYfDJ3vCzB0vi/A0Pm+AEPn+wIMne8+mIXO9wUYOt8XYOh8X4Ch830BRgCzD4bO9wUYOt8XYOh8X4Ch830Bhs53H0yi830Bhs73BRg63xdg6HxfgJF+wDzmmtL0DczXXDtqZotz7ag/vaWp67HT5AoVP4ftJTS3YTz9fQyztVLqqANH+s+k78hjIP1n0nfkopD+I+lzRz4R6T+TviMnjPSfSd+R10f6z6TvKM1A+s+kF6QfVfqO4iuk/0x60rxhpSfNG1Z60rxhpSfNG1P6OE2kecNKT5o3rPSkecNKT5o3rPSC9KNKT5o3rPSkecNKT5o3rPSkecNKT5o3qvSONG9Y6UnzhpWeNG9Y6UnzhpVekH5U6UnzhpWeNG9Y6UnzhpWeNG9Y6UnzRpXek+YNKz1p3rDSk+YNKz1p3rDSC9KPKj1p3rDSk+YNKz1p3rDSk+YNKz1p3qjSB9K8YaUnzRtWetK8YaUnzRtWekH6UaUnzRtWetK8YaUnzRtWetK8YaUnzRtVeiHNG1Z60rxhpSfNG1Z60rxhpRekH1V60rxhpSfNG1Z60rxhpSfNG1Z60rxRpZ9J84aVnjRvWOlJ84aVnjRvWOkF6UeVnjRvWOlJ84aVnjRvWOlJ84aVnjRvVOkjad6w0pPmDSs9ad6w0pPmDSu9IP2o0pPmDSs9ad6w0pPmDSs9ad6w0pPmjSr9Qpo3rPSkecNKT5o3rPSkecNKL0g/qvSkecNKT5o3rPSkecNKT5o3rPSkeaNKn0jzhpWeNG9Y6UnzhpWeNG9Y6QXpR5WeNG9Y6UnzhpWeNG9Y6UnzhpWeNG9U6TNp3rDSk+YNKz1p3rDSk+YNK70g/ajSk+YNKz1p3rDSk+YNKz1p3rDSk+YNKv2NEdKPKj1p3rDSk+YNKz1p3rDSC9KPKj1p3rDSk+YNKz1p3rDSk+YNKz1p3qjSO9K8YaUnzRtWetK8YaUnzRtWekH6UaUnzRtWetK8YaUnzRtWetK8YaUnzRtVek+aN6z0pHnDSk+aN6z0pHnDSi9IP6r0pHnDSk+aN6z0pHnDSk+aN6z0pHmjSh9I84aVnjRvWOlJ84aVnjRvWOkF6UeVnjRvWOlJ84aVnjRvWOlJ84aVnjRvVOmFNG9Y6UnzhpWeNG9Y6UnzhpVekH5U6UnzhpWeNG9Y6UnzhpWeNG9Y6UnzRpV+Js0bVnrSvGGlJ80bVnrSvGGlF6QfVXrSvGGlJ80bVnrSvGGlJ80bVnrSvFGlj6R5w0pPmjes9KR5w0pPmjes9IL0o0pPmjes9KR5w0pPmjes9KR5w0pPmjeq9Atp3rDSk+YNKz1p3rDSk+YNK70g/ajSk+YNKz1p3rDSk+YNKz1p3rDSk+aNKn0izRtWetK8YaUnzRtWetK8YaWXtqVP22f/b+m/xt92JOXnvA7Exydld0vXeb/VuQ/TdnCY9z46h7QenWVaHgNJe8UY0lroIeSng5e9gye/VliYQng++At622FQp9DbjmE6hd52ANIp9LajB5vQ3Zw2ekv+CT23bfo7hd623TYKfZti8C78frCP3m0zDIWDXQ5ua0Yl7cjZtoVGzu8HT9PmuiZfOHhewmoUc36e3pfybTtolD9PeUH5QZUnejClvMRN+Zj/pjz5x6jKE8JYUv7hv/wt6d5p2Il3upKT4KgjOW+9GnIaktNvw/DfUO9GKWFbZ13Ibkd7krFxtSdG61b72a0Hu1n8X3pxP5G5USZvlIlQJpRJuUxI8/otk7jdt5u/G43Py4TojzJ5o0zICWuXybxsMyyFvqUb+34iJzQkp+JNPj8RKQ6qvCN9NKW82k0+78geR1We5NGS8qUbSI6EsCs5BTl7kpPEzZKcqrf4HDHauNqTjXWrveINGUfmRpm8USYEdJRJuUw8aV6/ZaJ3384T/VEmb5QJOWHlMlnCNsMl/tWReHLCruQU5DQkp2aXR6Q4qvIEiqMqT5xoSnnFLpyEcFTlCf30lfeLbMqnkvPW3DfrNmvktCOn5kOWgbxtVOWJ0EZVnrTNlPJ6j9cGQflBlSeYs6R86dHNQNrWlZxEaF3JSS5mSU7Vh2sDydiw2gsxWrfaK94wEzI3yuSNMiGgo0zeKBPSvH7LRO+OrQhlQpmUy4ScsHaZaO6bJeSEhuTUvMknRIqjKk/6aEp5vZt8QvY4qPIzyaMl5Us3kGYSwq7kJMnrSk4SN0tyqt7imwXth9WebKxb7RVvyMxkbpTJG2VCQEeZvFEmpHn9lonefbuZ6I8yKZdJJCesXCaqGy1FcsKu5CQntCSnYpcXiRRHVV5QflDliRNNKa/YhZMQjqp846FfzNszyss8G1F+8qvzDtP3B6u/oDceofUJvfFAqkvoS+PxTp/QGw9hTEJ/PIMT3JJ3oDcelfQJvfGUwib0j17Oobnr5yLIaUdOzZ+ILI1HDyh/mvKNRw8of5ryRA+mlNf7cdBC/jGq8oQwlpQv/fAkEe90JSfBUVdyEklZklP1p0GJZGxc7QXte9Ve8XGfROZGmbxRJgR0lMkbZUKa12+Z6D1vloj+KJM3yoScsHaZaO76mckJDcmpeZMvEymOqjzpoynl9W7yZbLHUZUXlDekfOkGUiYh7EpOkryu5CRxsySn6i2+TIw2rvZkY91qr3dDJkxkbpTJG2VCQEeZvFEmpHn9lonafbswEf1RJm+UiVAmdctEc5vIMJETdiUnOaElOTW7PCLFUZUnUBxVeeJEU8rrdeGOhHBU5Qn9ar+cQ3HfrJtuyGlHTsWHLIMjbxtVeUH5QZUnbTOlvNrjtcERzI2qPMGcJeULj24GR9rWlZxEaD3J6cnFLMmp+XDtLbND+2G1J0brVnvFG2aezI0yeaNMhDKhTMplQprXb5no3bH1RH+UyRtlQk5Yu0wU9826fR1y2pFT8yafJ1IcVPlA+mhKeb2bfIHscVTlSR4tKV+6gRRICLuSU5CzJzlJ3CzJqXqLLxCjjas92Vi32ivekAlkbpTJG2VCQEeZlMtESPP6LRO9+3ZC9EeZvFEm5ISVy0R1oyUhJ+xKTkFOQ3JqdnlEiqMqT6A4qvLEiaaUV+zCSQhHVb7x0C+ldfg+O/+s/H38c+NpVIr+Mf6wM/62Y5Iw+ZV/mJa4M/62/Xt5/Jcb1jltf+lzlm/j/xqStDekub0hxfaGdHn/FLfmz0eZ9oaU2htSbm5I8fJF5LYWbMvC02XpaUgv1oU5bkPK6fchzc6vB8/hKQD+V7s7nyzT9slPLda8f1XNDzJP3cq/L9npVvK8NWRzfjrcJ7/H5jFs7+QxEp93Pz3ELcISN307+oukL5G8Jd6/kwzBb3CeSe7DWdJWCE+RmqwrTgwK41m2PlRC/H08LvpHyhflqRONfh2StDek+eIhLXF7yO727zTvDCm2N6RFdUhxcr8Pyeftg6enP3v5n//T7T/+r/+f/8f/8//5//i//5//n//v/9v/5f/3//h//7/+v/9OnP79j9v/SbDPk9s+Lj5dBafp3/zc/i9Ei2cth85Kh87KR87a/z1M8Sx36Cx/6Kxw6Cw5dNah2giHaiMcqo1wqDbCodqQQ7Uhh2pDDtWGHKoNOVQbcqg25FBtyKHakEO1IYdqYz5UG/Oh2pgP1cZ8qDbmQ7UxH6qN+VBtzIdqYz5UG/Oh2oiHaiMeqo14qDbiodqIh2ojHqqNeKg24qHaiIdqIx6qjeVQbSyHamM5VBvLodpYDtXGcqg2lkO1sRyqjeVQbSyHaiMdqo10qDbSodpIh2ojHaqNdKg20qHaSPvebXp4t+n5FtMU7melQ2flI2fl6dBZ7tBZ/tBZL7KU6XHnzedvZ+3eTYtbFvF0i8lNe7fTZLsfNT/591trdh+PKIwnTWu4dvs7S4XxzHFZj55jetxgmuU+oLm1AcXWBrS0NqDU2oByWwPy09TagFxrA/KtDSi0NqDGrtR+uv5KvWzbfczLLM8D2rv7+bhjNS/u94PTvA4jPd/cCmn3dk/Yfqbg5scHy+69ofRoqb4d+h/BCME/Elwg+EeCCYJ/JJgh+DeCboLgHwk6CP6RoIfgHwkGCP6RoEDwjwTxJH8liCf5K0E8yV8J4kn+ShBP8keCHk/yV4J4kr8SxJP8lSCe5K8EBYJ/JIgn+StBPMlfCeJJ/koQT/JXgniSPxIMeJK/EsST/JUgnuSvBGt4EvcgmH6H4tL2BKvLz+/R2v1oJ/mxm9Pinz/6v7nKQHOdB5prHGiuy0BzTQPNNY8zV5kGmqsbaK5+oLkO1DfJQH2TDNQ3yUB9kwzUN8lAfZMM1DfNA/VN80B90zxQ3zQP1DfNA/VN80B90zxQ3zQP1DfNA/VN80B9Uxyob4oD9U1xoL4pDtQ3xYH6pjhQ3xQH6pviQH1THKhvigP1TctAfdMyUN+0DNQ3LQP1TctAfdMyUN+0DNQ3LQP1TctAfdMyUN+UBuqb0kB9Uxqob0oD9U1poL4pDdQ3pYH6pjRQ35QG6pvSQH1THqhvygP1TXmgvin31Df5HLeXG05Pbwd9RWZ5vKj06WXdLu2NJE7ryxmjf/q5Ywp3jAJGDYw9dXsVMfbUSFbE2FOPWhFjT+1vRYw9ddbVMIapp6a9Isae/EBFjD1ZjYoYcTEqGAWMGhhxMSoYcTEqGHtyMbcr/bJhzKWBOLf47cNdnp4+/Z8E52LvyfUYwt6TS7KD3fXkqgxh78mFGcLek2szhL0nl2cIu4C9BvaeXKQh7D25TkPYcalVsONSq2DHpdbA7nGpVbAP7FL9NK8jcf424wJ2f5Pp63Dv0hOUFPeOXqbt6MU/nu2Ld+wDu9Sa2Ad2qTWxC9hrYB/YpdbEPrBLrYl9YJdaE/vALrUm9oFdakXsYWCXWhM7LrUKdlxqFey41CrYBew1sI/sUkNKG3aRUvDr4zYWH+P8ODq7vbE4v3747Yb109H/BPt5dFi2kYccvh39n0wju1pDMo3sgg3JNLJrNiTTyC7bjkxdvQS0Y5lGdvGGZBrZ9RuSaeSUwJBMgkwWZCKFMCETKYQJmUghTMhECmFCJlIICzJ19UrtjmUihTAhEymECZlIIUzIJMhkQSZSCBMykUKYkIkUwoRMpBAmZCKFsCBTJIUwIRMphAmZSCFMyEQKYUImQSYLMpFCmJCJFMKETKQQJmQihTAhEymEBZkWUggTMpFCmJCJFMKETKQQJmQSZLIgEymECZlIIUzIRAphQiZSCBMykUJYkCmRQpiQiRTChEykECZkIoUwIZMgkwWZSCFMyEQKYUImUggTMpFCmJCJFMKCTJkUwoRMpBAmZCKFMCETKYQJmQSZLMhECmFCJlIIEzKRQpiQiRTChEykEAZkkokUwoRMpBAmZCKFMCETKYQJmQSZLMhECmFCJlIIEzKRQpiQiRTChEykEBZkcqQQJmQihTAhEymECZlIIUzIJMhkQSZSCBMykUKYkIkUwoRMpBAmZCKFsCCTJ4UwIRMphAmZSCFMyEQKYUImQSYLMpFCmJCJFMKETKQQJmQihTAhEymEBZkCKYQJmUghTMhECmFCJlIIEzIJMlmQiRTChEykECZkIoUwIRMpxEkyeZk3hKkkk+RNpnma8k+ZSCEsyCSkECZkIoUwIRMphAmZSCFMyCTIZEEmUggTMpFCmJCJFMKETKQQJmQihbAg00wKYUImUggTMpFCmJCJFMKETIJMFmQihTAhEymECZlIIUzIRAphQiZSCAsyRVIIEzKRQpiQiRTChEykECZkEmSyIBMphAmZSCFMyEQKYUImUggTMpFCWJBpIYUwIRMphAmZSCFMyEQKYUImQSYLMpFCmJCJFMKETKQQJmQihTAhEymEBZkSKYQJmUghTMhECmFCJlIIEzIJMlmQiRTChEykECZkIoUwIRMphAmZSCEsyJRJIUzIRAphQiZSCBMykUKYkEmQyYJMpBAmZCKFMCETKYQJmUghTMhECmFAptv/h0wWZCKFMCETKYQJmUghTMgkyGRBJlIIEzKRQpiQiRTChEykECZkIoWwIJMjhTAhEymECZlIIUzIRAphQiZBJgsykUKYkIkUwoRMpBAmZCKFMCETKYQFmTwphAmZSCFMyEQKYUImUggTMgkyWZCJFMKETKQQJmQihTAhEymECZlIISzIFEghTMhECmFCJlIIEzKRQpiQSZDJgkykECZkIoUwIRMphAmZSCFMyEQKYUEmIYUwIRMphAmZSCFMyEQKYUImQSYLMpFCmJCJFMKETKQQJmQihTAhEymEBZlmUggTMpFCmJCJFMKETKQQJmQSZLIgEymECZlIIUzIRAphQiZSCBMykUJYkCmSQpiQiRTChEykECZkIoUwIZMgkwWZRk4h4uQ2mZbnge/KdPtIt0F5lumFqGlaRV1cLh3tp7we7f3y7ej/ZBo5hTAk08gphCGZRk4hDMk0cgphR6Zl5BTCkEwjpxCGZBo5hTAk08gphCGZBJksyEQKYUImUggTMpFCmJCJFMKETKQQTcgkIaxHSyrdUonivw6O8SFpiHvi5MfNmulpGPsHR7cdHf08FY52i4sr79u/cyh9et54x+yeajHtHJxut5a+Dk4++ueD/9VtIpahbi3WLTkVdWuxbgnuqFuLdUuSSd1arFuhbqlbg3VL1k3dWqxbwn/q1mLdcjeEurVYt9weom4t1i33y6hbg3WbuV9G3VqsW+6XUbcW65b7ZdStxbrlfhl1a7Fuhbqlbg3WLffLqFuLdcv9MurWYt1yv4y6tVi33C+jbi3WLffLqFt7dRsn7pdRtxbrlvtl1O3jg/28bHWbSh/tUtxG/e/f8u34/6qLu1pU13nVxb0nquu86hKqi+o6rbq4j0N1nVdd3G2hus6rLu6JUF3nVRd3Lqiu86qL+wtU12nV5bgLQHWdV11k9VTXedVFVk91nVddZPVU13nVJVQX1XVadZHVn1Rdy/Zsyu2f34/+DzwxdiXwJLyVwBN+VgJPLlgHvCcyqwSeNKkSeIKWSuDJICqBF8DXAY9zrQQe51oJPM61EnicayXwAzvXEJY1Q3ZBZl9A6W6D2aJel5bHD/PiLvjJb+C9fzr2H/YwsG+tiX1g11oT+8CeVaZlG7c4WQrY4/T46W98HJvu95LCwB5UF6QAUgfkwB5RF+TAnk8X5MAeThfkwJ5MF+TAHksVpAzsmnRBDuyDdEHibJRA4myUQAogdUDibJRAjuxsouQNZCw+1OzDspL0IT+l9Wn5OHSTkX1QRewju6aK2Ef2WPWwzyM7sorYR/ZvFbGP7PYqYh/ZG1bELmCvgX1k31kROy61CnZcahXsuNQq2HGpNbBHXOrb2MVtWzaITN+w/4cS56mGEjephhKHqIZSQKmFEienhhJ3poYSx6WGEhelhhJnpIVywe2oocTtqKHE7aihxO2ooRRQaqHE7aihxO2oocTtqKHE7aihxO1ooUy4HTWUuB01lLgdNZS4HTWUAkotlLgdNZS4HTWUuB01lLgdNZS4HS2UGbejhhK3o4YSt6OGErejhlJAqYUSt6OGErejhhK3o4YSt6OGErejhHKZcDtqKHE7aihxO2oocTtqKAWUWihxO2oocTtqKHE7aihxO2oocTtaKB1uRw0lbkcNJW5HDSVuRw2lgFILJW5HDSVuRw0lbkcNJW5HDSVuRwulx+2oocTtqKHE7aihxO2ooRRQaqHE7aihxO2oocTtqKHE7aihxO1ooQy4HTWUuB01lLgdNZS4HTWUAkotlLgdNZS4HTWUuB01lLgdNZS4HS2UgttRQ4nbUUOJ21FDidtRQymg1EKJ21FDidtRQ4nbUUOJ21FDidvRQjnjdtRQ4nbUUOJ21FDidtRQSk8og2wowxJLR8e0kgy3GzNPR+c7mq7ciy6artyILpqu3IUumq7cgi6arrp/VTSxq25eF01X3bkumq66bV00XXXPumgENK/Q0A2/REM3/BIN3fBLNHTDL9HQDb9C09e75HXR0A2/REM3/BIN3fBLNAKaV2johl+ioRt+iYZu+CUauuGXaOiGX6Hp613jumjohl+ioRt+iYZu+CUaAc0rNHTDL9HQDb9EQzf8Eg3d8Es0dMOv0PT1LmpdNHTDL9HQDb9EQzf8Eo2A5hUauuGXaOiGX6KhG36Jhm74JRq64RdoUl/vKtZFQzf8Eg3d8Es0dMMv0QhoXqGhG36Jhm74JRq64Zdo6IZfoqEbfoWmr3fZ6qKhG36Jhm74JRq64ZdoBDSv0NANv0RDN/wSDd3wSzR0wy/R0A2/QtPXu0510dANv0RDN/wSDd3wSzQCmldo6IZfoqEbfomGbvglGrrhl2johl+h6etdmLpo6IZfoqEbfomGbvglGgHNKzR0wy/R0A2/REM3/BIN3fBLNHTDr9D09a5EXTR0wy/R0A2/REM3/BKNgOYVGrrhl2johl+ioRt+iYZu+CUauuFXaPp6l54uGrrhl2johl+ioRt+iUZA8woN3fBLNHTDL9HQDb9EQzf8Eg3d8Cs0vIvuNRq64Zdo6IZfoqEbfolGQPMKDd3wSzR0wy/R0A2/REM3/BIN3fArNLyL7jUauuGXaOiGX6KhG36JRkDzCg3d8Es0dMMv0dANv0RDN/wSDd3wKzS8i+41Grrhl2johl+ioRt+iUZA8woN3fBLNHTDL9HQDb9EQzf8Eg3d8Cs0vIvuNRq64Zdo6IZfoqEbfolGQPMKDd3wSzR0wy/R0A2/REM3/BIN3fALNJl30b1GQzf8Eg3d8Es0dMMv0QhoXqGhG36Jhm74JRq64Zdo6IZfoqEbfoWGd9G9RkM3/BIN3fBLNHTDL9EIaF6hoRt+iYZu+CUauuGXaOiGX6IZtxuWMPmvoyXM8RuanZHIsiJxs3saSdobd5zS18HRP31yCv9BH/gtdxWhj9vBV4Q+rjeoCH1c11ERugD9eujjOqWK0Mf1YBWhj+vuKkIf1zdWhI4jvR76wG+arAgdR1oBOo60AvS+HGlajw7i529H/zdZGWmyfTmwwmT7cj6FyfblOAqT7avTL0y2rw7798l29tbIwmT76igLk+2rkytMdqQOqrO3LxYmO1IH1dkbEguTHamD6uwthoXJjtRBdfamwcJkR+qgOnsbYGGyI3VQnb2xrzDZkTqozt6qV5jsSB1UZ2++K0x2pA6qs7fTFSY7UgfV2RvkCpMdqYPq7C1vhcmO1EF19ia2wmRH6qA6e1taYbIjdVCdvdGsMNmROqjO3jpWmOxIHVRnbwYrTHakDqqzt3cVJjtSB9XZG7YKkx2pg+rsLViFyY7UQXX2pqrCZEfqoDp7m1RhsiN1UJ298akw2ZE6qM7eylSY7EgdVGdvTipMdqQOqq+3G0l4TLb4m0C3rL/b89Pjk31yO8emjUcKuXBs3ojn/P3Y/4B31cVZAC4AvxZ4V92sBeBdddQWgHfV1VsA3pWzsAC8K3fTPnA39fU6LhPEu/J5JohjNq8mjtu8mrh0RTxtmywlcSXiPm3bJoUgT0envc+e3abmnKZvR99J9uUja5LsyyDWJNmX86tJsi9LV5NkX16tIsm+XgJXlWRf3qomyb48U02SfXmhmiQFkkok8ThaJPE4WiTxOFok8ThaJPE4SiT7egFfVZJ4HC2SeBwtkngcLZICSSWSeBwtkngcLZJ4HC2SeBwtkngcJZJ9vdKtKkk8jhZJPI4WSTyOFkmBpBJJPI4WSTyOFkk8jhZJPI4WSTyOEsm+Xu5XlSQeR4skHkeLJB5Hi6RAUokkHkeLJB5HiyQeR4skHkeLJB5HiWRfr9+sShKPo0USj6NFEo+jRVIgqUQSj6NFEo+jRRKPo0USj6NFEo+jRLKvF+RWJYnH0SKJx9EiicfRIimQVCKJx9EiicfRIonH0SKJx9EiicdRItnXK6yrksTjaJHE42iRxONokRRIKpHE42iRxONokcTjaJHE42iRxOMokezrJfNVSeJxtEjicbRI4nG0SAoklUjicbRI4nG0SOJxtEjicbRI4nGUSGY8jhZJPI4WSTyOFkk8jhZJgaQSSTyOFkk8jhZJPI4WSTyOFkk8jg5JN+FxtEjicbRI4nG0SOJxtEgKJJVI4nG0SOJxtEjicbRI4nG0SOJxlEg6PI4WSTyOFkk8jhZJPI4WSYGkEkk8jhZJPI4WSTyOFkk8jhZJPI4SSY/H0SKJx9EiicfRIonH0SIpkFQiicfRIonH0SKJx9EiicfRIonHUSIZ8DhaJPE4WiTxOFok8ThaJAWSSiTxOFok8ThaJPE4WiTxOFok8ThKJAWPo0USj6NFEo+jRRKPo0VSIKlEEo+jRRKPo0USj6NFEo+jRRKPo0RyxuNokcTjaJHE42iRxONokRRIKpHE42iRxONokcTjaJHE42iRxOMokYx4HC2SeBwtkngcLZJ4HC2SAkklkngcLZJ4HC2SeBwtkngcLZJ4HCWSCx5HiyQeR4skHkeLJB5Hi6RAUokkHkeLJB5HiyQeR4skHkeLJB5HiWTC42iRxONokcTjaJHE42iRFEgqkcTjaJHE42iRxONokcTjaJHE4yiRzHgcLZJ4HC2SeBwtkngcLZICSSWSeBwtkngcLZJ4HC2SeBwtkngcHZJ+wuNokcTjaJHE42iRxONokRRIKpHE42iRxONokcTjaJHE42iRxOMokXR4HC2SeBwtkngcLZJ4HC2SAkklkngcLZJ4HC2SeBwtkngcLZJ4HCWSHo+jRRKPo0USj6NFEo+jRVIgqUQSj6NFEo+jRRKPo0USj6NFEo+jRDLgcbRI4nG0SOJxtEjicbRICiSVSOJxtEjicbRI4nG0SOJxtEjicZRICh5HiyQeR4skHkeLJB5Hi6RAUokkHkeLJB5HiyQeR4skHkeLJB5HieSMx9EiicfRIonH0SKJx9EiKZBUIonH0SKJx9EiicfRIonH0SKJx1EiGfE4WiTxOFok8ThaJPE4WiQFkkok8ThaJPE4WiTxOFok8TjvkRS/5K+jJcy+cLSTZfvs2T2NO+3NMk7p6+Do49Ox4Usj3FPzGi34svY1wvG1rxFesn2NcKntayRo1LxGOOv2NcKzt68RaUD7GpEztK8ROUPzGiVyhvY1ImdoX6OBc4awDcTFKRSoez9NX0d7Cd81upMcOA1QJimQVCI5sLNWJjmw/1UmObBLVSY5sJdUJjmw49MlmQf2ZcokB3ZPyiTxOFok8ThaJAWSSiTxOFok8ThaJPE4WiTxOFok8Tg6JMOEx9EiicfRIonH0SKJx9EiKZBUIonH0SKJx9EiicfRIonH0SKJx1Ei6fA4WiTxOFok8ThaJPE4WiQFkkok8ThaJPE4WiTxOFok8ThaJPE4SiQ9HkeLJB5HiyQeR4skHkeLpEBSiSQeR4skHkeLJB5HiyQeR4skHkeJZMDjaJHE42iRxONokcTjaJEUSCqRxONokcTjaJHE42iRxONokcTjKJEUPI4WSTyOFkk8jhZJPI4WSYGkEkk8jhZJPI4WSTyOFkk8jhZJPI4SyRmPo0USj6NFEo+jRRKPo0VSIKlEEo+jRRKPo0USj6NFEo+jRRKPo0Qy4nG0SOJxtEjicbRI4nG0SAoklUjicbRI4nG0SOJxtEjicbRI4nGUSC54HC2SeBwtkngcLZJdeZw0byTzJN+Ovs9WhpptV16hONuu+vnibLvquYuz7aovLs62q961NNvUVX9ZnG1XPWBxtl31acXZDtVL9fXO8+Jsh+ql+np3eHG2Q/VSfb2DuzjboXqpvt5lXZztUL1UX++ELs52qF6qr3crF2c7VC/V1zuKi7Mdqpfq612/xdmO1EtJX+/MLc52pF5K+nr3bHG2I/VSMslQsx2pl5K+3oVanO1IvZT09U7R4myH6qX6ejdncbZD9VJ9veOyONuheqm+3hVZnO1QvVRf71wsznaoXqqvdxcWZztUL9XXOwCLsx2ql+rrXXrF2Q7VS/X1TrribIfqpfp6t1txtkP1Un29I60426F6qb7eNVac7VC9VF/v7CrOdqheqq93XxVnO1Qv1dc7pIqzHaqX6utdTMXZDtVL9fVOo+Jsh+ql+no3UHG2Q/VSfb1jpzjboXqpvt5VU5ztUL1UX+98yW7eZhtLR7slfR3sn3bA8cntHJs2HinkwrE5rUPO+fuxd+Jd9XMWiPf1DhkTxLvqa/OyDlucTIWj/RL8inzJz0fPe8xv14MVunfx29F3kl31zFVJdtWPVyUpkFQi2ZWPqEqyK49SlWRX/qcqyb68VU2SfXmmiiT7etdMVZJ4HC2SeBwtkngcLZICSSWSeBwtkngcLZJ4HC2SeBwtkngcJZJ9vWumKkk8jhZJPI4WSTyOFkmBpBJJPI4WSTyOFkk8jhZJPI4WSTyOEsm+3ndUlSQeR4skHkeLJB5Hi6RAUokkHkeLJB5HiyQeR4skHkeLJB5HiWRf7yGrShKPo0USj6NFEo+jRVIgqUQSj6NFEo+jRRKPo0USj6NFEo+jQ3Lu6/2AVUnicbRI4nG0SOJxtEgKJJVI4nG0SOJxtEjicbRI4nG0SOJxlEj29d7OqiTxOFok8ThaJPE4WiQFkkok8ThaJPE4WiTxOFok8ThaJPE4SiT7ep9uVZJ4HC2SeBwtkngcLZICSSWSeBwtkngcLZJ4HC2SeBwtkngcJZJ9vee6Kkk8jhZJPI4WSTyOFkmBpBJJPI4WSTyOFkk8jhZJPI4WSTyOEsm+3j9flSQeR4skHkeLJB5Hi6RAUokkHkeLJB5HiyQeR4skHkeLJB5HieSMx9EiicfRIonH0SKJx9EiKZBUIonH0SKJx9EiicfRIonH0SKJx1EiGfE4WiTxOFok8ThaJPE4WiQFkkok8ThaJPE4WiTxOFok8ThaJPE4SiQXPI4WSTyOFkk8jhZJPI4WSYGkEkk8jhZJPI4WSTyOFkk8jhZJPI4SyYTH0SKJx9EiicfRIonH0SIpkFQiicfRIonH0SKJx9EiicfRIonHUSKZ8ThaJPE4WiTxOFok8ThaJAWSSiTxOFok8ThaJPE4WiTxOFok8Tg6JOOEx9EiicfRIonH0SKJx9EiKZBUIonH0SKJx9EiicfRIonH0SKJx1Ei6fA4WiTxOFok8ThaJPE4WiQFkkok8ThaJPE4WiTxOFok8ThaJPE4SiQ9HkeLJB5HiyQeR4skHkeLpEBSiSQeR4skHkeLJB5HiyQeR4skHkeJZMDjaJHE42iRxONokcTjaJEUSCqRxONokcTjaJHE42iRxONokcTjKJEUPI4WSTyOFkk8jhZJPI4WSYGkEkk8jhZJPI4WSTyOFkk8jhZJPI4SyRmPo0USj6NFEo+jRRKPo0VSIKlEEo+jRRKPo0USj6NFEo+jRRKPo0Qy4nG0SOJxtEjicbRI4nG0SAoklUjicbRI4nG0SOJxtEjicbRI4nGUSC54HC2SeBwtkngcLZJ4HC2SAkklkngcLZJ4HC2SeBwtkngcLZJ4HCWSCY+jRRKPo0USj6NFEo+jRVIgqUQSj6NFEo+jRRKPo0USj6NFEo+jRDLjcbRI4nG0SOJxtEjicbRICiSVSOJxtEjicbRI4nG0SOJxtEjicXRILhMeR4skHkeLJB5HiyQeR4ukQFKJJB5HiyQeR4skHkeLJB5HiyQeR4mkw+NokcTjaJHE42iRxONokRRIKpHE42iRxONokcTjaJHE42iRxOMokfR4HC2SeBwtkngcLZJ4HC2SAkklkngcLZJ4HC2SeBwtkngcLZJ4HCWSAY+jRRKPo0USj6NFEo+jRVIgqUQSj6NFEo+jRRKPo0USj6NFEo+jRFLwOFok8ThaJPE4WiTxOFokpSOS4rajxeX47ej7bHvyIeXZ9uQVyrPtqZ8vz7annrs825764uJsu3p/fXm2PfWX5dn21AOWZ9tTn1aerQw126F6qa7eS16e7VC9VFfv9y7Pdqheqqv3ZJdnO1Qv1dX7psuzHaqX6uq9zeXZDtVLdfX+4/Jsh+qlunqPcHm2Q/VSXb2PtzzboXqprt5rW57tUL1UV++HLc92qF6qq/eslmc7VC/V1ftKy7Mdqpfq6r2f5dkO1Ut19f7M8myH6qW6eg9lebZD9VJdvc+xPNuheqmu3otYnu1QvVRX7xcsz3aoXqqr9/SVZztUL9XV++7Ksx2ql+rqvXHl2Q7VS3X1/rXybEfqpVJX7zErz3akXip19T6w8mxH6qXSJEPNtqteSlxYZ7u4aWe2XfVSxdl21UsVZ9tVL1WcbVe9VGm2Xb0vqTzbrnqp4my76qWKs+2qlyrOVoaa7VC9VFfvwSnPdqheqqv3yZRnO1Qv1dV7WcqzHaqX6ur9JuXZDtVLdfWekPJsh+qlunrfRnm2Q/VSXb23ojzboXqprt7/UJ7tUL1UV+9RKM92qF6qq/cRlGc7VC/V1b7+5dkO1Ut1tT9+ebZD9VJd7TNfnu1QvVRX+7WXZztUL9XXvufF2Q7VS/W173lxtkP1Un3te16c7VC9VF/7nhdnO1Qv1de+58XZDtVL9bXveXG2Q/VSfe17XphtrnCvIC7r0XNM4Xm29xFVuG5OD/5T/Dmi/fr3YRUihCUVRhRintaj0/TztVT5RRyq/CXLFV+SrviSfMGXvIi6lL/EXfEl/oovCVd8iVzxJVf8xcsVf/FyxV+8XPEXL1f8xc9X/MXPV/zFz1f8xc9X/MXPV/zFz1f8xc9X/MXPV/zFz1f8xc9X/MXHK/7i4xV/8fGKv/h4xV98vOIvPl7xFx+v+IuPV/zFxyv+4uMVf/HLFX/xyxV/8csVf/HLFX/xyxV/8csVf/HLFX/xyxV/8csVf/HLFX/x6Yq/+HTFX3y64i8+XfEXn674i09X/MWnK/7i0xV/8UnjLz4t29F5cjtfki/4kjxd8SXuii/xV3xJuOJL5Iovma/4kqj8Jc7vfInGX3zabv+E7KdvX/Lz6LTdYknhcYfFJ7dz7O2q93Vszt+PvQ8+WR58Njt4P02T5cE7y4P3lgcfLA9eLA9+tjz4aHnwdlfY2+DtrrC3wVteYZ3lFda1vcLG9Vh3W053Rt/2ElsafdtrbGn0bS+ypdG3vcqWRt/2MlsavcY6m/2yjX5eCqP//RnD24hScyPKrY3IT82NyDU3It/ciEJzI5LmRjQ3N6LY3Iiau2b75q6Q4for5K9Pqt9GJM2N6Pq/tcU/RuSXnyOKzY1oaW5EqbkR5dZGJBX++iVuI/r346DHiH4e7GUbiBeRn8N3tofvbQ8/2B6+2B7+bHv40fbwF9vDT40P36fH8H82ZJJND39ufdUtDL/xVXee157HzzH8fnCcpvVxsnhLh3/OtfEl+pO5znnJv8618fV83rJfPy/u94PTtH5wkqcfWof0NVUZZ6qN9wmaU228p9CcauP9h+ZUG+9VNKfaeF+jONXYeA+kOdXW+yXFqfa0rs5rcJ6W+G2qOx/swjpm7+bHB4vfOzitPVuYvh16R9jTel0JYU99QCWEPfUXlRD21LdUQthTP1QH4dJTn1UJYU/9WyWErcdoBhD2lM5VQigg/CtC3MmfEeJO/owQd/JnhLiTPyPEnfwVYcKd/BnhqFU4Zb8hfHpodxdhSusgvm1TsfvB/3ZBWj/532ZFTz8GyvHOPI9atjWZj+rCazIf1bbXZD6qz6/JXGB+OfNRk4SazEeNHmoyHzWrqMl81HCjJnN86NXM3YQPvZ45PvR65vjQ65njQ69nLjC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYOH3o9c3zo9czxodczx4dez1xgfjlzfOj1zPGh1zPHh17PHB96PXN86OXMPT70eub40OuZ40OvZ44PvZ65wPxy5vjQ65njQ69njg+9njk+9Hrm+NDLmQd86PXM8aHXM8eHXs8cH3o9c4H55czxodczx4dezxwfej1zfOj1zPGhlzNv/fWOXTLHh17PHB96PXN86PXMBeaXM8eHXs8cH3o9c3zo9czxodczx4dezrz1Fx53yRwfej1zfOj1zPGh1zOXUZlvb1D/t6HK78x/3bbfdfVa7koIh3WJaghNvWw2/X7wEtdjlyX+nKmlYvnbTC0Z+b/NtIZ9do+ZFgb/20ffx59tj7/Ku0U1x++Mj98bH38wPn4xPv7Z+Pij8fEvxsdvfP1djK+/qe31V6aw+hSZci58dJC4pg5B0tOw5+lrtm2v1tqzbXtt155t252A9mxlqNm23WVoz7btnkR7tm13MNqzbbvf0Z5t292R8mzzUL1UtttL3cdvtzu6j99uv3Mfvxgfv92e5D5+u13GffyN9w1uu6EhwUnho9MkXwen8Jjr7cbbzrE5rR+c8/dj71wa7zCqcWm8F6nExU+Ndy3VuDTe31Tj0njfVI1L4/1YNS4Cl10ujfeP1bg03pdW40K/u8+FfnefC/3uLhdHv7vPpfX+ZXuiXJz/mQf4Ki8c0hx/6/1Aafytr9ul8be+vpbG3/o6WBp/6+tVYfy+9XWlNP7W847S+FvPJUrjN77+VnnRgub4ja+/3vj6642vv974+uuNr7/B+PobjK+/wfj6G4yvv1U2mNYcv/H1Nxhff4Px9TcYX3+D8fVXjK+/Ynz9FePrrxhff6tsrKk5fuPrrxhff8X4+ivG118xvv7Oxtff2fj6Oxtff2fj62+VDcU0x298/Z2Nr7+z8fV3Nr7+zsbX32h8/Y3G199ofP2NxtffaHz9jcbX32h8/Y3G19/GdxIsj9/4+tv4ToLl8RtffxvfSbA8fuPrb+M7CZbHb3z9bXwnwfL4ja+/je8kWB6/8fW39Z0Ei+M3vv62vttfcfzG19/Wd+Qrjt/4+tv6rnnF8Rtff1vf2a44fuPrb+u7zxXHb3z9bX0/ueL4ja+/re8nVxy/8fW39f3kiuM3vv42v+9bafy219/Q/D5qpfHbXn9D8/uSlcZve/0Nk+31NzS/H1dp/LbX39D8/lal8dtef0Pz+0UVxt/8vk6l8Rtff53x9df4/lfB+P5Xwfj+V8H4/lfB+P5Xwfj+V8H4/lfB+P5Xwfj+V8H4/lfB+P5Xofn9r07bVzSux7pp8t8OvoMZdqPrEphhd7ougRl2q+sSmGH3ui6BGXaz6wKY5ncVew3mPn67bxu5j9/uW0Hu4xfj47fbfNzHb7dHuI/f7lJ+H7/dFfc+frsL43/jb35XsdL4ja+/ze8qVhq/8fW3+V3FSuM3vv42v6tYafzG19/mdxUrjd/4+tv8rmKl8Rtff5vfVaw0fuPrb/O7ipXGb3z9bX5XsdL4ja+/ze8qVhq/8fW3+V3FSuM3vv42v6tYafzG19/mdxUrjd/4+tv8rmKl8Rtff5vfVaw0fuPrb/O7ipXGb3z9bX5XsdL4ja+/ze8qVhq/8fW3+V3FSuM3vv42v6tYafzG19/mdxUrjd/4+tv8rmKl8Rtff5vfVaw0fuPrb/O7ipXGb3z9bX5XsdL4ja+/ze8qVhq/8fW3+V3FSuM3vv42v6tYafzG19/mdxUrjd/4+tv8rmKl8dtef6X5XcVK47e9/krzu4qVxm97/ZXJ9vorze8qVhq/7fVXmt9VrDR+2+uvNL+rWGH8ze8qVhq/8fW3+V3FSuM3vv42v6tYafzG19/mdxUrjd/4+tv8rmKl8Rtff5vfVaw0fuPrb/O7ipXGb3z9Nbyr2H38xtdfw3t03cdvfP01vOPVffzG199gfP01vv+VGN//SozvfyWt738VQ17Hn/59+a8f/dHGcmmdYc7fj71zaXxdr8al8X6hGpfG+5DzuPy+QaO0vsFYPTCNd07VwLS+JVo9MI33evXANN5E1gPTeHeato+WJCUwSwxfBy9L3I4V/zVVGWeqjfemmlNtvN38Zar38TfeFhbH33j3Vhx/401Wafytb09XHH/jLUtx/G13FrOTeT3YxZ14p/Ht6crjb3tVL4+/7aW6PP6219/y+Ntef8vjb3v9LY+/7fW3OP7Gt6crj7/t9fd5/N75nfHbWX/3x29n/d0ff+Pr7+KW7eCUd8bf+PpbHH/j629x/I2vv8XxN77+Fsff+PpbGn/j29OVx9/4+lscf+Prb3H8ja+/xfEbX38b356uPH7j62/j29PNKUzrwTmmwkdL3ib7/ChTmr7m2vharTrXxtd1zbk2vkWe7lwb7xdU59p4b6E618b7ENW5ykBzbby/UZ1r473QR3O9xV3rwZJ25tpT31Saa099U2muPfVNhbk2vrWh7lx76ptKc+2pbyrNtae+qTRXGWiuPfVN87z1TWmnb2p8i0fduXbVNxXm2lXfVJhrV33Tr3OdG9+SUneuXfVNhbl21TcV5tpV31SYqww013H6prnxrTl/m+t9/HZ7ofv47fY39/G33bPEaVoHEkN0P8ff+Nac5fG33VuUx992v1Aef9s9QHn8ba/r5fG3vVaXx9/2+lsef9vrb3n8ba+/5fEbX38b35qzPH7j62/jW3OWx298/W18a87y+I2vv41vzVkev/H1t/GtOcvjN77+Nr41Z3n8xtffxrfmLI/f+Prb+Nac5fEbX38b3+qyPH7j62/jO0eWx298/W18H8by+I2vv43valgev/H1t/EdBcvjN77+Nr73X3n8xtffxvf+K4/f+Prb+N5/5fEbX38b3/uvPH7j62/je/+Vx298/W1877/y+I2vv43v/Vcev/H1t/G9/8rjN77+Nr73X3n8xtffxvf+K4/f+Prb+N5/5fEbX38b3/uvPH7j62/je/+Vx298/W1877/y+I2vv43v/Vcev/H1t/G9/8rjN77+Nr6fX3n8xtffxvfdK4/f+Prb+P545fEbX38b38euPH7j62/j+82Vx298/W18X7jy+I2vv43v31Yev/H1t/F91srjN77+Nr4fWnn8xtffxvctK4/f+Prb+P5i5fHbXn9j4/uAlcdve/2Nje/XVR6/7fU3TrbX39j4Xlnl8dtef2Pj+1+Vx297/Y3G97+Kxve/isb3v4rG97+Kxve/isb3v4rG97+Kxve/isb3v4rG97+Kxve/isb3v4rG97+Kxve/isb3v4rG97+Kxve/isb3v4rG97+Kxve/isb3v4qt738laT04zs7vjL/x9TcsG//biYWPTpN8HZzC4z3LPrmdY3NaPzjn78feuTS+rlfj0ni/UI2LwGWXS+P9TTUujfdN1bg03o9V49J4n1eNS+P9Yy0ure8LV40L/e4+F/rdfS70u/tcBC67XOh397nQ7+5zGbbfjeuxbpr8DphhG94SmGE73gKY1rdirAdm2J63BGbYprcExm7Xex+/GB+/3S7yPn673d59/Ha7svv47TZP9/Hb7XH+G3/ru1IWx2+3Y7iP3+7Cfh+/8fW39V0pi+M3vv62vitlcfzG19/Wd6Usjt/4+tv6rpTF8Rtff1vflbI4fuPrb+u7UhbHb3z9bX1XyuL4G7/+zymv44+uFIy5OU9hjbvm7MJ2fLzPtvU9/H6Z7X38jV+tiuNv+2q1LMt68LI83cPb/2i/xPnraL8s4fmj75Nt+9KmPNm2r4PKk23btChPtm2HozzZtpdD3ck2vqOh8mTbNlrKk227z/l0stmvk01PXcU22babIuXJykiT7amDCn5am+Pg/fJzsj11UMXJ9tRBFSfbUwdVnGxPHdRtstMvk10a3xPxw8mKW48O4qefk+1pnS1Otqd1tjjZrtbZ0mS7WmdDTttk3fT7R895WS/dc847V7OuFuVPyMRpu87H6WcjujS+9+Q1NbNPpqvlXsLW28js/vbX1Ph+mdeQ2a2Zxnfi/JTMdoctSE4/J9tXi1iYbF8tYmGyMtJk+2oRH5Odn34VsU22qxaxNNmuur7SZLtq5EqT7ao3C4+BzG75/aNdTGs/7xZ52gwtpDuaxjcj/RDNsm39FpYc/ta2Nr7N6YlkSiaw8Q1Ur6mZfTLSFZnto8P/uim1c6GZ8vbAmQvTzoWmq74pednQ7DSJjW8RqzzZrvqm0mS76ptKk+2qbypMtvFtbZUn21XbV5psV51cabIy0HPsS+t7rSrPtvHfWCjPtvFfRCrPtvHfTyrPdqRf2yyt70yqPNvGf8mpPFu7v6Q6Mlu7v7vanW2Qx2xn/zTb/aP909HxBxuBzUs2nfVpqmw66+o+YCNuewJH/NO9jJVMZx2gIpnOukVFMp11lnpkWt8stCKZzjpWRTKddbeKZMbthEtkBDIvyIzbBZfI0AO/IkMP/IpMbz3wK5e489lpe6zrditvKn12Tuskbxif3ug5T18ke+uZq5FsfRfcSiTvbHrrsjXZ9NZn/5p4vdhr1m3b+Qfvc2G2Lk3rzh8uuWc2y+5sp8dsp/g82/uI4vUj8o8R7fyi+sV+sDVHlJobUW5tRC92Ya05Inf9iCQ+riyF50a9bJc4L/LzidoX26qaGX6wPXyxPfzZ9vCj7eEvtoefbA8/Nz58nx7D/9mQpcn28FtfdQvDb3zVnee15/Fz/OOvmVLjS/Qncy39Pik1vp7PLmxzXQqbK6Rp/eAkT2Nef2+UGl/7NafaeJ+gOdXGewrNqTbef2hOtfFeRXGqufWV9ZOpzusw0hK/TXXng114JOdP++b8+036z4MfP8mdvh16R9j6gm0AoYDwrwh76i8qIeypb6mEsKd+qBLCnvqsSgh76t+qIExT43mXBYSNZ24WEOJO/owQd/JXhG7U1np6vAXEPT2ksoswpXUQ2fnCB7uc3PZATk7+cbzP8Yv5qL14TeajNu81mY/a7ddkPqo9qMjcj+onajIf1YDUZD6qY6nJfFSLU5O5wPxy5vjQ65njQ69njg+9njk+9Hrm+NDLmQd86PXM8aHXM8eHXs8cH3o9c4H55czxodczx4dezxwfej1zfOj1zPGhlzMXfOj1zPGh1zPHh17PHB96PXOB+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczn/Gh1zPHh17PHB96PXN86PXMBeaXM8eHXs8cH3o9c3zo9czxodczx4dezjziQ69njg+9njk+9Hrm+NDrmQvML2eOD72eOT70eub40OuZ40OvZ44PvZz5gg+9njk+9Hrm+NDrmeNDr2cuML+cOT70eub40OuZ40OvZ44PvZ45PvRy5q2/b7ZL5vjQ65njQ69njg+9nrnA/HLm+NDrmeNDr2eOD72eOT70eub40MuZZ3zo9czxodczx4dezxwfej1zgfnlzPGh1zPHh17PHB96PXN86PXM8aFXM88TPvR65vjQ65njQ69njg+9nrnA/HLm+NDrmeNDr2eOD72eOT70eub40MuZO3zo9czxodczx4dezxwfej1zgfnlzPGh1zPHh17PHB96PXN86PXM8aGXM/f40OuZ40OvZ44PvZ45PvR65gLzy5njQ69njg+9njk+9Hrm+NDrmeNDL2ce8KHXM8eHXs8cH3o9c3zo9cwF5pczx4dezxwfej1zfOj1zPGh1zPHh17OXPCh1zPHh17PHB96PXN86PXMBeaXM8eHXs8cH3o9c3zo9czxodczx4deznzGh17PHB96PXN86PXM8aHXMxeYX84cH3o9c3zo9czxodczx4dezxwfejnziA+9njk+9Hrm+NDrmeNDr2cuML+cOT70eub40OuZ40OvZ44PvZ45PvRy5gs+9Hrm+NDrmeNDr2eOD72eucD8cub40OuZ40OvZ44PvZ45PvR65vjQy5knfOj1zPGh1zPHh17PHB96PXOB+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczz/jQ65njQ69njg+9njk+9HrmAvPLmeNDr2eOD72eOT70eub40OuZ40MvZh6mCR96PXN86PXM8aHXM8eHXs9cYH45c3zo9czxodczx4dezxwfej1zfOjlzB0+9Hrm+NDrmeNDr2eOD72eucD8cub40OuZ40OvZ44PvZ45PvR65vjQy5l7fOj1zPGh1zPHh17PHB96PXOB+eXM8aHXM8eHXs8cH3o9c3zo9czxoZczD/jQ65njQ69njg+9njk+9HrmAvPLmeNDr2eOD72eOT70eub40OuZ40MvZy740OuZ40OvZ44PvZ45PvR65gLzy5njQ69njg+9njk+9Hrm+NDrmeNDL2c+40OvZ44PvZ45PvR65vjQ65kLzC9njg+9njk+9Hrm+NDrmeNDr2eOD72cecSHXs8cH3o9c3zo9czxodczF5hfzhwfej1zfOj1zPGh1zPHh17PHB96OfMFH3o9c3zo9czxodczx4dez1xgfjlzfOj1zPGh1zPHh17PHB96PXN86OXMEz70eub40OuZ40OvZ44PvZ65wPxy5vjQ65njQ69njg+9njk+9Hrm+NDLmWd86PXM8aHXM8eHXs8cH3o9c4H55czxodczx4dezxwfej1zfOj1zPGhVzN3Ez70eub40OuZ40OvZ44PvZ65wPxy5vjQ65njQ69njg+9njk+9Hrm+NDLmTt86PXM8aHXM8eHXs8cH3o9c4H55czxodczx4dezxwfej1zfOj1zPGhlzP3+NDrmeNDr2eOD72eOT70euYC88uZ40OvZ44PvZ45PvR65vjQ65njQy9nHvCh1zPHh17PHB96PXN86PXMBeaXM8eHXs8cH3o9c3zo9czxodczx4dezlzwodczx4dezxwfej1zfOj1zAXmlzPHh17PHB96PXN86PXM8aHXM8eHXs58xodezxwfej1zfOj1zPGh1zMXmF/OHB96PXN86PXM8aHXM8eHXs8cH3o584gPvZ45PvR65vjQ65njQ69nLjC/nDk+9Hrm+NDrmeNDr2eOD72eOT70cuYLPvR65vjQ65njQ69njg+9nrnA/HLm+NDrmeNDr2eOD72eOT70eubD+tAlP5gvvzP3ya00Jvd86H8I07C2Ug/hsC5RD+Gwpk8P4bAeTg+hgPCPCLOlbj/9fvAS12OXJf6cqaUe+28ztdTZ/m2mNfpJ95hpYfC/ffS/8fsq73bXHL8zPn5vfPzB+PjF+Phn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qDpVWcZ+JBeWY2Jf5jV6Xe400yguLOrCYi4s2YWleLCk4MISXViSCwu5sBwT+8+/k61JXFjUhcVcWLILS/FgoeDCEl1YkgsLubC4xD65xD65xD65xD65xD65xD67xD67xD67xD67xD67xD67xD67xD67xD67xD67xL64xL64xL64xL64xL64xL64xL64xL64xL64xL64xL66xL66xL66xL66xL66xL66xL66xL66xL66xL66xL65xL65xL65xL65xL65xL65xL65xL65xL65xL65xH52if3sEpVrOydDihNLeNzjUGWJNCwYjNeT0tbBM5TK+MV2osjT1fppk3Zok73EJtIy2fTw5THdde3d/nxy+8u57V/bx9mP/Rwn/XOKC/vjye1PJ7efTm4/n9x+Obn9enL7ux9/N+zvfvzdsL/78fep/RbOPf5aOPf4a+Hc46+Fc4+/Fs49/lo49/hr4dzjr4Vzj78Wzj3+Wjj5+BuPyv9ss/1Svl1/5zkqT5vOPIWXPOzEI0486sRjTjzZiaf48KTgxBOdeA7KByZ54jHTJQ858bATjzjxqBOPOfFkJ57iw0PBieegfJB5up5yZdym5MRDTjzsxCNOPOrEY0482Ymn+PDwQfmgpOlzI1TIljzRiSc58ZATDzvxiBOPOvGYE0/x4ZFjdJ1ymK5POW59Fujp3gYT6tAmfolNR633m8jJ7deT22+92/+8Xib55PaXc9uv4eT2x5Pbn05uP53c/u7H3w37ux9/N+zvfvzdsP/k46+efPzVk4+/dvLx104+/trJx187+fhrJx9/7eTjr518/LWTj7928vHXTj7+5pOPv/mo/J/ybP8Pn1+/87ATz0H5tESZeArlJY868ZgTT3biOSrep49/Dz+X5Xp8CU480YknOfGQEw878YgTjzrxmBPPUfnA5n0zIcqSp7jw5IPea9nmiU48yYmHnHjYiUeceNSJ56B1/1BmnkgVnuzEU3x4YnDiiU48yYmHnHjYiUeceA7aB5TizJMkLnnMiSc78RQfnqPeG9jkiU48yYmHnHjYieegfJDKNL8mWu5vy0e9N7DJY0482Ymn+PAc9d7AJk904klOPAflAyph4uGgSx524hEnHnXiMSee4sNTr7+nUMr4/u7t55knFf3ERRCXQByBOAZxAuKqOuShvjWuIWT6jqrcNY3Ty8dK847lW764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",
      "brillig_names": [
        "discover_new_messages",
        "get_notes_internal",
        "get_collapse_hints",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "random",
        "notify_created_note_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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/yvk/V8R3/8V6f1fsb7/K/L7v6K8/SueLP80/Yr3/3WX9/91l/f/dZf3/3WX9/91l/f/dZf3/3WX9/91l7f/dbtlef9X/Piv+3qaP3daOHeanDstnjstnTttPXdaPndaOXWaW86ddq5K3LkqceeqxJ2rEneuSty5KnHnqsSdqxJ3rkr8uSrx56rEn6sSf65K/Lkq8eeqxJ+rEn+uSvy5KvHnqiScq5JwrkrCuSoJ56oknKuScK5KwrkqCeeqJJyrknCuSuRclci5KpFzVSLnqkTOVYmcqxI5VyVyrkrkXJXIuSqJ56oknquSeK5K4rkqieeqJJ6rkniuSuK5KonnqiSeq5J0rkrSuSpJ56oknauSdK5K0rkqSeeqJJ2rknSuStK5KlnPVcl6rkrWc1WynquS9VyVrOeqZD1XJeu5KlnPVcl6rkryuSrJ56okn6uSfK5K8rkqyeeqJJ+rknyuSvK5KsnnqqScq5JyrkrKuSop56qknKuScq5KyrkqKeeqpJyrknKqSvyynDvNnTvNnzstnDtNzp0Wz52Wzp22njstnzvtXJWcy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/bns1Z/LXv257NWfy179uezVn8te/ZPstewP713iOndw2pMqWdf9tOL/OO1ox9lG77O4DGe1NZxsazjF1HCeZdtaw3G2huNtDSfYGo7YGk60NRxbV+Vi66pcbF2Vi6mrclhMXZXDYuqqHBZTV+WwmLoqh+XTV+WXr2K6jCcaG08yNp7V2HiysfEUW+NxP742X09z507z5047vCZdVjG3LTwua4WxAs2lNexv901rum2sc7TTwcUqb5vIXO4XofLZaVn2DbCWcPsxeVm+xi/Gxx+XTYAUQ3gcf+x8/Knz8a+djz93Pv7S9/iPH8DoaPyu8/H7zsdv/f5bG3/n91/f+f3Xd37/9Z3ff33n91/f+f03dH7/DZ3ff0Pn99/Q+f03dH7/DZ3ff0Pn99/Q+f03dH7/DZ3ff6Xz+690fv+Vzu+/0vn9Vzq//0rn91/p/P4rnd9/pfP7r3R+/42d339j5/ff2Pn9N3Z+/42d339j5/ff2Pn9N3Z+/42d339j5/ff1Pn9N3V+/02d339T5/ff1Pn9N3V+/02d339T5/ff1Pn9N3V+/107v/+und9/187vv2vn99+18/vv2vn9d+38/rt2fv9dO7//rp3ff3Pn99/c+f03d37/zZ3ff3Pn99/c+f03d37/zZ3ff3Pn99/c+f23dH7/LZ3ff0vn99/S+f23dH7/LZ3ff0vn99/S+f23dH7/LX3ff2Xp+/4rS9/3X1n6vv/K0vf9V5a+77+y9H3/laXv+68sfd9/Zen7/itL5/df1/n913V+/3Wd33/N739VG3/n99/O97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Szve/ks73v5LO97+Kne9/FTvf/yp2vv9V7Hz/q7j0ff+Nne9/FTvf/yp2vv9V7Hz/q9j5/lex8/2vYuf7X8XO97+Kne9/FTvf/yp2vv9VNL//1e2j01rc/fiPDt5GnXK6fXAOX3O1fq9uOVfr9/WWc7XeAzScq/n9ulrO1Xpv0XKuxvuQWGK+zdW/nqusZRvHZYE87wf7kg6H7dZ91EH2o0NYv9gY73FU2QhsnrIx3putUfzX0Wta0ms2IWzHBrkbtD9inuI25LgudwcHdzTmUvZP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OdkmkF15nIDC1u4/nIAP+wSCP5iA630CvvcJhN4nIL1PIPY+gWR9Aq83n4xx7X0C1u/E1QmYvxNXJpDM34lrEzB/J65NwPyduDYB83fiygSOt8t1y/50rFtyeXARx/vZVs86VPuyjLk1zM6t/vGscOosOXVWPHVWOj4rp+2sP4Tazjq8fDrxbjtL/ON3HW9uVz3LnTrLnzornDpLTp0VT511rNclTdnOuhT441nrqbPyqbPKmbOOt3qpnuVOneVPnXVcG5f/fjsruccf7R5vK1E9K546K506az11Vj51VjlxVlqWU2cdqxzCflaI/vGscOosOXVWPHVWOnXWeuqsfOqscuas4x8PVs9yp846VRvuVG24J7WR8n5Wdo9nxVNnpVNnrafOyqfOKmfO8sups850Dsn7U2eFU2ed6RzScYx8+bvbUvn08JuwdJwblrSVblnT4znhxDly4px44px0ootPx8FL9ax86qxy5qy0nDrLnTrLnzornDpLTp0VT511qjbSqdpIp2ojnaqNU343HTvX11eLY99a/Obeixycc+Iv//j9AZXvySfOKT8/59itVs5xP2eQT1yZ84kr87FLLXmrgz+Wcrdz4olz0olz1sp8js7JJxiUn59z7Ewr55yog3KiDsqJOign/k7LiTv0sRutnLOeOOeHdfCfl//0//2nf//bP/23f/nn/30549f/+H/+9b//x9/+7V+//uN//P/+1/a//Ld//9u//Mvf/ud//V///m///Z//x//593/+r//yb//91//2l+Xr//0/q1/9X1dfwmU0v2S/dHXrXy8X1Xj5z+H3/x7z5X9P+df//usEyXn9q+Tif/0Xv88IS/nrGpy7jO0yvv8/",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "pSymm"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "custody_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "custody_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "pSymm::withdraw_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "pSymm::withdraw_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "pSymm::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "pSymm::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "pSymm::get_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "pSymm::get_config_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "custody_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "pSymm::deposit_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "pSymm::deposit_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "101": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "103": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "104": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "105": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "107": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "108": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "109": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "110": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "123": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "128": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "131": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "134": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "137": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "138": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "140": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "141": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "142": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "146": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "147": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "148": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "149": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "150": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "152": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "153": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "154": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "155": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "157": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "163": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\nmod test;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateSet<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:insert\n    pub fn insert<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        let (retrieved_notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < retrieved_notes.len() {\n                let retrieved_note = retrieved_notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, retrieved_note, note_hash);\n            }\n        }\n\n        // Since the notes were already destroyed, we no longer need the additional data in RetrievedNote and can\n        // discard it.\n        retrieved_notes.map(|retrieved_note| retrieved_note.note)\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, retrieved_note: RetrievedNote<Note>) {\n        let note_hash = compute_note_hash_for_read_request(retrieved_note, self.storage_slot);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, retrieved_note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note> PrivateSet<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes<let N: u32>(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\n    where\n        Note: Packable<N>,\n    {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "165": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "181": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    // Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "183": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "184": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "186": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "187": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "189": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "191": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "195": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "20": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "219": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "221": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "264": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "279": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "281": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "282": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "292": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "296": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "298": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "299": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "308": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "319": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "333": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "337": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "338": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "354": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "355": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "357": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "363": {
      "path": "/home/qbit/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "39": {
      "path": "std/ops/arith.nr",
      "source": "// docs:start:add-trait\npub trait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field {\n    fn add(self, other: Field) -> Field {\n        self + other\n    }\n}\n\nimpl Add for u128 {\n    fn add(self, other: u128) -> u128 {\n        self + other\n    }\n}\nimpl Add for u64 {\n    fn add(self, other: u64) -> u64 {\n        self + other\n    }\n}\nimpl Add for u32 {\n    fn add(self, other: u32) -> u32 {\n        self + other\n    }\n}\nimpl Add for u16 {\n    fn add(self, other: u16) -> u16 {\n        self + other\n    }\n}\nimpl Add for u8 {\n    fn add(self, other: u8) -> u8 {\n        self + other\n    }\n}\nimpl Add for u1 {\n    fn add(self, other: u1) -> u1 {\n        self + other\n    }\n}\n\nimpl Add for i8 {\n    fn add(self, other: i8) -> i8 {\n        self + other\n    }\n}\nimpl Add for i16 {\n    fn add(self, other: i16) -> i16 {\n        self + other\n    }\n}\nimpl Add for i32 {\n    fn add(self, other: i32) -> i32 {\n        self + other\n    }\n}\nimpl Add for i64 {\n    fn add(self, other: i64) -> i64 {\n        self + other\n    }\n}\n\n// docs:start:sub-trait\npub trait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field {\n    fn sub(self, other: Field) -> Field {\n        self - other\n    }\n}\n\nimpl Sub for u128 {\n    fn sub(self, other: u128) -> u128 {\n        self - other\n    }\n}\nimpl Sub for u64 {\n    fn sub(self, other: u64) -> u64 {\n        self - other\n    }\n}\nimpl Sub for u32 {\n    fn sub(self, other: u32) -> u32 {\n        self - other\n    }\n}\nimpl Sub for u16 {\n    fn sub(self, other: u16) -> u16 {\n        self - other\n    }\n}\nimpl Sub for u8 {\n    fn sub(self, other: u8) -> u8 {\n        self - other\n    }\n}\nimpl Sub for u1 {\n    fn sub(self, other: u1) -> u1 {\n        self - other\n    }\n}\n\nimpl Sub for i8 {\n    fn sub(self, other: i8) -> i8 {\n        self - other\n    }\n}\nimpl Sub for i16 {\n    fn sub(self, other: i16) -> i16 {\n        self - other\n    }\n}\nimpl Sub for i32 {\n    fn sub(self, other: i32) -> i32 {\n        self - other\n    }\n}\nimpl Sub for i64 {\n    fn sub(self, other: i64) -> i64 {\n        self - other\n    }\n}\n\n// docs:start:mul-trait\npub trait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field {\n    fn mul(self, other: Field) -> Field {\n        self * other\n    }\n}\n\nimpl Mul for u128 {\n    fn mul(self, other: u128) -> u128 {\n        self * other\n    }\n}\nimpl Mul for u64 {\n    fn mul(self, other: u64) -> u64 {\n        self * other\n    }\n}\nimpl Mul for u32 {\n    fn mul(self, other: u32) -> u32 {\n        self * other\n    }\n}\nimpl Mul for u16 {\n    fn mul(self, other: u16) -> u16 {\n        self * other\n    }\n}\nimpl Mul for u8 {\n    fn mul(self, other: u8) -> u8 {\n        self * other\n    }\n}\nimpl Mul for u1 {\n    fn mul(self, other: u1) -> u1 {\n        self * other\n    }\n}\n\nimpl Mul for i8 {\n    fn mul(self, other: i8) -> i8 {\n        self * other\n    }\n}\nimpl Mul for i16 {\n    fn mul(self, other: i16) -> i16 {\n        self * other\n    }\n}\nimpl Mul for i32 {\n    fn mul(self, other: i32) -> i32 {\n        self * other\n    }\n}\nimpl Mul for i64 {\n    fn mul(self, other: i64) -> i64 {\n        self * other\n    }\n}\n\n// docs:start:div-trait\npub trait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field {\n    fn div(self, other: Field) -> Field {\n        self / other\n    }\n}\n\nimpl Div for u128 {\n    fn div(self, other: u128) -> u128 {\n        self / other\n    }\n}\nimpl Div for u64 {\n    fn div(self, other: u64) -> u64 {\n        self / other\n    }\n}\nimpl Div for u32 {\n    fn div(self, other: u32) -> u32 {\n        self / other\n    }\n}\nimpl Div for u16 {\n    fn div(self, other: u16) -> u16 {\n        self / other\n    }\n}\nimpl Div for u8 {\n    fn div(self, other: u8) -> u8 {\n        self / other\n    }\n}\nimpl Div for u1 {\n    fn div(self, other: u1) -> u1 {\n        self / other\n    }\n}\n\nimpl Div for i8 {\n    fn div(self, other: i8) -> i8 {\n        self / other\n    }\n}\nimpl Div for i16 {\n    fn div(self, other: i16) -> i16 {\n        self / other\n    }\n}\nimpl Div for i32 {\n    fn div(self, other: i32) -> i32 {\n        self / other\n    }\n}\nimpl Div for i64 {\n    fn div(self, other: i64) -> i64 {\n        self / other\n    }\n}\n\n// docs:start:rem-trait\npub trait Rem {\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u128 {\n    fn rem(self, other: u128) -> u128 {\n        self % other\n    }\n}\nimpl Rem for u64 {\n    fn rem(self, other: u64) -> u64 {\n        self % other\n    }\n}\nimpl Rem for u32 {\n    fn rem(self, other: u32) -> u32 {\n        self % other\n    }\n}\nimpl Rem for u16 {\n    fn rem(self, other: u16) -> u16 {\n        self % other\n    }\n}\nimpl Rem for u8 {\n    fn rem(self, other: u8) -> u8 {\n        self % other\n    }\n}\nimpl Rem for u1 {\n    fn rem(self, other: u1) -> u1 {\n        self % other\n    }\n}\n\nimpl Rem for i8 {\n    fn rem(self, other: i8) -> i8 {\n        self % other\n    }\n}\nimpl Rem for i16 {\n    fn rem(self, other: i16) -> i16 {\n        self % other\n    }\n}\nimpl Rem for i32 {\n    fn rem(self, other: i32) -> i32 {\n        self % other\n    }\n}\nimpl Rem for i64 {\n    fn rem(self, other: i64) -> i64 {\n        self % other\n    }\n}\n\n// docs:start:neg-trait\npub trait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field {\n    fn neg(self) -> Field {\n        -self\n    }\n}\n\nimpl Neg for i8 {\n    fn neg(self) -> i8 {\n        -self\n    }\n}\nimpl Neg for i16 {\n    fn neg(self) -> i16 {\n        -self\n    }\n}\nimpl Neg for i32 {\n    fn neg(self) -> i32 {\n        -self\n    }\n}\nimpl Neg for i64 {\n    fn neg(self) -> i64 {\n        -self\n    }\n}\n// docs:end:neg-trait-impls\n"
    },
    "392": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "51": {
      "path": "/home/qbit/Desktop/work/otc-noirhack/contracts/psymm/src/main.nr",
      "source": "mod config;\nmod types;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract pSymm {\n    // Corrected imports based on usage\n    use std::ops::{Add, Sub}; // Keep Add/Sub if BalanceSet methods return values needing them, otherwise remove. Re-evaluating: BalanceSet add/sub handle ops internally. Remove.\n\n    use dep::aztec::{\n        context::PrivateContext, // Keep PrivateContext as it's used in function signatures implicitly via #[private]\n        macros::{\n            functions::{initializer, private, public, view}, // Removed internal, utility\n            storage::storage,\n        },\n        // Removed unused log imports\n        prelude::{AztecAddress, Map, PublicImmutable}, // Removed PublicContext, PublicMutable\n        // Removed unused Serialize import\n    };\n\n    // Removed unused uint_note imports\n    use dep::token::Token;\n    // Removed unused ToField import\n\n    use crate::types::balance_set::BalanceSet;\n    use crate::config::Config;\n\n    #[storage]\n    struct Storage<Context> {\n        /// L2 token address for custody operations\n        config: PublicImmutable<Config, Context>,\n        /// Mapping of custody_id to private balance sets\n        custody_balances: Map<Field, BalanceSet<Context>, Context>,\n    }\n\n    /// Initialize with the L2 token address\n    #[public]\n    #[initializer]\n    fn constructor(token: AztecAddress) {\n        storage.config.initialize(Config { token });\n    }\n\n    /// Read-only view of the contract config\n    #[private]\n    #[view]\n    fn get_config() -> Config {\n        storage.config.read()\n    }\n\n    // docs:start:deposit\n    /// Deposit `amount` of L2 token into private custody under `custody_id`\n    #[private]\n    fn deposit(custody_id: Field, amount: u128, nonce: Field) {\n        let caller = context.msg_sender();\n        let cfg = storage.config.read();\n\n        Token::at(cfg.token)\n            .transfer_in_private(caller, context.this_address(), amount, nonce)\n            .call(&mut context);\n\n        // 2) Update custody balance by adding a new note owned by the caller\n        storage.custody_balances.at(custody_id).add(caller, amount);\n\n        // 3) Emit an unconstrained note for off-chain indexing (Optional)\n        // encode_and_encrypt_note_unconstrained(\n        //     &mut context,\n        //     caller, // Or perhaps context.this_address() depending on indexing needs\n        //     custody_id, // Include custody_id in the note? Need a custom note type.\n        // );\n    }\n    // docs:end:deposit\n\n    // docs:start:withdraw\n    /// Withdraw `amount` of L2 token from private custody under `custody_id`\n    #[private]\n    fn withdraw(custody_id: Field, amount: u128) {\n        let caller = context.msg_sender();\n\n        // 1) Update custody balance by subtracting notes owned by the caller\n        // This implicitly checks for sufficient balance and handles note nullification.\n        // It might return change note(s) if the subtracted notes' sum exceeds `amount`.\n        storage.custody_balances.at(custody_id).sub(caller, amount);\n\n        // 2) Transfer `amount` of L2 token back to caller (private)\n        let cfg = storage.config.read();\n        Token::at(cfg.token)\n            .transfer(caller, amount)\n            .call(&mut context);\n\n        // 3) Emit an unconstrained note for off-chain indexing (Optional)\n        // encode_and_encrypt_note_unconstrained(\n        //     &mut context,\n        //     caller, // Or perhaps context.this_address()\n        //     custody_id, // Include custody_id?\n        // );\n    }\n    // docs:end:withdraw\n}\n"
    },
    "52": {
      "path": "/home/qbit/Desktop/work/otc-noirhack/contracts/psymm/src/types/balance_set.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, UtilityContext},\n    note::{\n        note_emission::OuterNoteEmission, note_getter_options::SortOrder,\n        note_interface::NoteProperties, retrieved_note::RetrievedNote,\n    },\n    protocol_types::{address::AztecAddress, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n};\nuse dep::aztec::prelude::{NoteGetterOptions, NoteViewerOptions, PrivateSet};\nuse dep::uint_note::uint_note::UintNote;\nuse std::ops::Add;\n\npub struct BalanceSet<Context> {\n    pub set: PrivateSet<UintNote, Context>,\n}\n\nimpl<Context> BalanceSet<Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { set: PrivateSet::new(context, storage_slot) }\n    }\n}\n\nimpl BalanceSet<UtilityContext> {\n    pub unconstrained fn balance_of(self: Self) -> u128 {\n        self.balance_of_with_offset(0)\n    }\n\n    pub unconstrained fn balance_of_with_offset(self: Self, offset: u32) -> u128 {\n        let mut balance = 0 as u128;\n        // docs:start:view_notes\n        let mut options = NoteViewerOptions::new();\n        let notes = self.set.view_notes(options.set_offset(offset));\n        // docs:end:view_notes\n        for i in 0..options.limit {\n            if i < notes.len() {\n                balance = balance + notes.get_unchecked(i).get_value();\n            }\n        }\n        if (notes.len() == options.limit) {\n            balance = balance + self.balance_of_with_offset(offset + options.limit);\n        }\n\n        balance\n    }\n}\n\nimpl BalanceSet<&mut PrivateContext> {\n    pub fn add(self: Self, owner: AztecAddress, addend: u128) -> OuterNoteEmission<UintNote> {\n        if addend == 0 as u128 {\n            OuterNoteEmission::new(Option::none())\n        } else {\n            // We fetch the nullifier public key hash from the registry / from our PXE\n            let mut addend_note = UintNote::new(addend, owner);\n\n            // docs:start:insert\n            OuterNoteEmission::new(Option::some(self.set.insert(addend_note)))\n            // docs:end:insert\n        }\n    }\n\n    pub fn sub(self: Self, owner: AztecAddress, amount: u128) -> OuterNoteEmission<UintNote> {\n        let subtracted = self.try_sub(amount, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL);\n\n        // try_sub may have substracted more or less than amount. We must ensure that we subtracted at least as much as\n        // we needed, and then create a new note for the owner for the change (if any).\n        assert(subtracted >= amount, \"Balance too low\");\n        self.add(owner, subtracted - amount)\n    }\n\n    // Attempts to remove 'target_amount' from the owner's balance. try_sub returns how much was actually subtracted\n    // (i.e. the sum of the value of nullified notes), but this subtracted amount may be more or less than the target\n    // amount.\n    // This may seem odd, but is unfortunately unavoidable due to the number of notes available and their amounts being\n    // unknown. What try_sub does is a best-effort attempt to consume as few notes as possible that add up to more than\n    // `target_amount`.\n    // The `max_notes` parameter is used to fine-tune the number of constraints created by this function. The gate count\n    // scales relatively linearly with `max_notes`, but a lower `max_notes` parameter increases the likelihood of\n    // `try_sub` subtracting an amount smaller than `target_amount`.\n    pub fn try_sub(self: Self, target_amount: u128, max_notes: u32) -> u128 {\n        // We are using a preprocessor here (filter applied in an unconstrained context) instead of a filter because\n        // we do not need to prove correct execution of the preprocessor.\n        // Because the `min_sum` notes is not constrained, users could choose to e.g. not call it. However, all this\n        // might result in is simply higher DA costs due to more nullifiers being emitted. Since we don't care\n        // about proving optimal note usage, we can save these constraints and make the circuit smaller.\n        let options = NoteGetterOptions::with_preprocessor(preprocess_notes_min_sum, target_amount)\n            .sort(UintNote::properties().value, SortOrder.DESC)\n            .set_limit(max_notes);\n        let notes = self.set.pop_notes(options);\n\n        let mut subtracted = 0 as u128;\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                subtracted = subtracted + note.get_value();\n            }\n        }\n\n        subtracted\n    }\n}\n\n// Computes the partial sum of the notes array, stopping once 'min_sum' is reached. This can be used to minimize the\n// number of notes read that add to some value, e.g. when transferring some amount of tokens.\n// The preprocessor (a filter applied in an unconstrained context) does not check if total sum is larger or equal to\n// 'min_sum' - all it does is remove extra notes if it does reach that value.\n// Note that proper usage of this preprocessor requires for notes to be sorted in descending order.\npub fn preprocess_notes_min_sum(\n    notes: [Option<RetrievedNote<UintNote>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    min_sum: u128,\n) -> [Option<RetrievedNote<UintNote>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    let mut selected = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let mut sum = 0 as u128;\n    for i in 0..notes.len() {\n        // Because we process notes in retrieved order, notes need to be sorted in descending amount order for this\n        // filter to be useful. Consider a 'min_sum' of 4, and a set of notes with amounts [3, 2, 1, 1, 1, 1, 1]. If\n        // sorted in descending order, the filter will only choose the notes with values 3 and 2, but if sorted in\n        // ascending order it will choose 4 notes of value 1.\n        if notes[i].is_some() & sum < min_sum {\n            let retrieved_note = notes[i].unwrap_unchecked();\n            selected[i] = Option::some(retrieved_note);\n            sum = sum.add(retrieved_note.note.get_value());\n        }\n    }\n    selected\n}\n\n"
    },
    "54": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "55": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "64": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "65": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "69": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "81": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "86": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "90": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "91": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "94": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "95": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "98": {
      "path": "/home/qbit/nargo/github.com/AztecProtocol/aztec-packages/v0.85.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    }
  }
}
