{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":13766392709643324131,"abi":{"parameters":[{"name":"note","type":{"kind":"struct","path":"Note","fields":[{"name":"nullifier","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"amount","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"token","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"secret_nonce","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"note_a","type":{"kind":"struct","path":"Note","fields":[{"name":"nullifier","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"amount","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"token","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"secret_nonce","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"note_b","type":{"kind":"struct","path":"Note","fields":[{"name":"nullifier","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"amount","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"token","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"secret_nonce","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"note_index","type":{"kind":"field"},"visibility":"private"},{"name":"note_hash_path","type":{"kind":"array","length":10,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},"visibility":"private"},{"name":"note_commitment","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"noteA_commitment","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"noteB_commitment","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"nullifier_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"root","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"note_custody_id","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"noteA_custody_id","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"noteB_custody_id","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}}},"bytecode":"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","debug_symbols":"7Z3RrizFkUX/5T7zUJkZWZnpXxmNLIyxdSUEFuCRRpb/fRq453DHFU3K25YrljrejKngRG+2a28C9zp/+/DHr//w1z///uO3f/ruhw+/+6+/ffjmu6++/PHjd98+/uhvH9Z5/Pxf/vCXL7/96Y9/+PHL73/88Lsyyvriw9ff/vGn/zjG37/48KeP33z94Xdn/fsXl4fbHP3Tw23V8/3hWpyHyyzz7a88W/n14ePv//3FY50Sa50aa50Wax2LtU6Ptc4Za50Ra50Za50Vap0R6608Yr2VR6y38oj1Vh6x3soj1lt5xHorj1hv5RHrrTxivZVnrLfyjPVWnrHeyjPWW3nGeivPWG/lGeutPGO9lWest/KM9VZesd7KK9ZbecV6K69Yb+UV6628Yr2V13/4rVxnPz89XOewyzr/4bdya+V4e7h9/vDhPNytvT3czX59uCzn4bHedx6rjc8f/vmDzlf5oOs1Pmg5juNlPml5mU9aX+aTtpf5pPYyn7S/zCc9X+aTvkhDenzSF6lIj0/6Mh2pvExHKi/TkcrLdKTyMh2p2Mt80pfpSOVlOlJ5mY5UXqYjlZfpSPVlOlJ9mY5UX6Yj1ZfpSNVe5pO+TEeqL9OR6st0pPoyHam+TEdqL9OR2st0pPYyHam9TEdq9jKf9GU6UnuZjtSedKT19iPK/Gyfxyf9ZWpKU0uZskOaKtJUlaaaNGXSVJemTmlK8oZJ3jDJG13yRpe80SVvdMkbXfJGl7zRJW90yRtd8kaXvHFK3jglb5ySN07JG6fkjVPyxil545S8cUreePKN17newres/z91jchSj/H2cLX2b4z13/4/JpfjyfdjIcsX8vKVvHwjL2/k5Tt5+ZO8/CAvP8nLkxN2khN2khN2khN2khN2khN2khN2khN2khN2khN2khN2kRN2kRN2kRN2kRN2kRN2kRN2kRN2kRN2kRN2gRO2HOCELQc4YcsBTthygBP28e+DycuDE7Yc4IQtBzhhywFO2HKQE7aQE7aQE7aQE7aQE7aQE7aQE7aQE7aQE7aQE7aQE7aSE7aSE7aSE7aSE7aSE7aSE7aSE7aSE7aSE7aSE7aRE7aRE7aRE7aRE7aRE7aRE7aRE7aRE7aRE7aRE9bICWvkhDVywho5YY2csEZOWCMnrJET1sgJa+SE7eSE7eSE7eSE7eSE7eSE7eSE7eSE7eSE7eSE7eSEPckJe5IT9iQn7ElO2JOcsCc5YU9ywp7khD3JCUtmOhUy06mQmU6FzHQqZKZTITOdCpnpVMhMp0JmOhUy06mQmU6FzHQqZKZTITOdCpnpVMhMp0JmOhUy06mQmU6FzHQqZKZTITOdCpnpVMhMp0JmOhUy06mQmU6FzHQqZKZTITOdCpnpVMlMp0pmOlUy06mSmU71ACdsJTOdKpnpVMlMp0pmOlUy06mSmU6VzHSqZKZTJTOdKpnpVMlMp0pmOlUy06mSmU6VzHSqZKZTDc10qrOfnx6uc9h1+cgJ247a3h4+Rr0uHzlht8tHTtjt8pETdrt85ITdLh85YVspb2+bVprztomcsLf95vQamhZ1nyyhOVQ3yhK5b9woS+gmc58soTvSfbJYyuLJErrX3SdL6MZ4nyyhu+h9smTLdWXJluvJEpoFd6Ms2XJdWbLlurJky3VlsZTFkyVbritLtlxXlmy5rizZcl1ZsuV6soTmMd4oS7ZcV5Zsua4s2XJdWSxl8WTJluvKki3XlSVbritLtlxXlmy5niyhmag3ypIt15UlW64rS7ZcVxZLWTxZsuW6smTLdWXJluvK4rfc1da7LLN+/kl/mVrK1BOq7W6qSFNVmmrSlElTXZo6pakhTUneGJI3puSNKXljSt6Ykjem5I0peWNK3piSN6bkjSl5Y0neWJI3luSNJXljSd5YkjeW5I0leWNJ3liKN5rPwKlHe//uWzmOTay39wrQy28/+vif2Nuzj/8FlH9M0+ZDbW7bpobapoXaxkJt00Ntc4baZoTaZobaZkXapoR6F5dQ7+Lyr7+L+yifnj2P8W/8h8/Nt9xbadzVjbt6565+clcf3NUnd/WFXb0e3NULd3VumlZumlZumlZumlZumlZumlZumlZumjZumjZumjZumjZumjZumjZumjZumjZumjZumjZumho3TY2bpsZNU+OmqXHT1Lhpatw0NW6aGjdNjZumnZumnZumnZumnZumnZumnZumnZumnZumnZumnZumJzdNT26antw0PblpenLT9OSm6clN05Obpic3TU9umg5umg5umg5umg5umg5umg5umg5umg5umg5umg5umk5umk5umk5umk5umk5umk5umk5umk5umk5umk5umi5umi5umi5umi5umi5umi5umi5umi5umi5umi5smtoRN003v3De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","file_map":{"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"20":{"source":"use crate::runtime::is_unconstrained;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[foreign(keccakf1600)]\nfn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n\n#[no_predicates]\npub(crate) fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n\nmod tests {\n    use super::keccak256;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x5a, 0x50, 0x2f, 0x9f, 0xca, 0x46, 0x7b, 0x26, 0x6d, 0x5b, 0x78, 0x33, 0x65, 0x19,\n            0x37, 0xe8, 0x05, 0x27, 0x0c, 0xa3, 0xf3, 0xaf, 0x1c, 0x0d, 0xd2, 0x46, 0x2d, 0xca,\n            0x4b, 0x3b, 0x1a, 0xbf,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn hash_hello_world() {\n        let input = \"Hello world!\".as_bytes();\n        let result = [\n            0xec, 0xd0, 0xe1, 0x8, 0xa9, 0x8e, 0x19, 0x2a, 0xf1, 0xd2, 0xc2, 0x50, 0x55, 0xf4, 0xe3,\n            0xbe, 0xd7, 0x84, 0xb5, 0xc8, 0x77, 0x20, 0x4e, 0x73, 0x21, 0x9a, 0x52, 0x3, 0x25, 0x1f,\n            0xea, 0xab,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn var_size_hash() {\n        let input = [\n            189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205,\n            206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,\n            223,\n        ];\n        let result = [\n            226, 37, 115, 94, 94, 196, 72, 116, 194, 105, 79, 233, 65, 12, 30, 94, 181, 131, 170,\n            219, 171, 166, 236, 88, 143, 67, 255, 160, 248, 214, 39, 129,\n        ];\n        assert_eq(keccak256(input, 13), result);\n    }\n\n    #[test]\n    fn hash_longer_than_136_bytes() {\n        let input = \"123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789\"\n            .as_bytes();\n        assert(input.len() > 136);\n\n        let result = [\n            0x1d, 0xca, 0xeb, 0xdf, 0xd9, 0xd6, 0x24, 0x67, 0x1c, 0x18, 0x16, 0xda, 0xd, 0x8a, 0xeb,\n            0xa8, 0x75, 0x71, 0x2c, 0xc, 0x89, 0xe0, 0x25, 0x2, 0xe8, 0xb6, 0x5e, 0x16, 0x5, 0x55,\n            0xe4, 0x40,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n}\n","path":"std/hash/keccak.nr"},"21":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    /// Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"62":{"source":"fn compute_merkle_root<let N: u32>(leaf: [u8; 32], index: Field, hash_path: [[u8; 32]; N]) -> [u8; 32] {\n    let index_bits: [u1; N] = index.to_le_bits();\n    let mut current = leaf;\n    for i in 0..N {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        let mut acc: [u8; 64] = [0; 64];\n        for i in 0..32 {\n            acc[i] = hash_left[i];\n            acc[i + 32] = hash_right[i];\n        }\n        current = std::hash::keccak256(acc, acc.len());\n    }\n    current\n}\n\nstruct Note {\n    nullifier: [u8; 32],\n    amount: [u8; 32], // LE-encoded (0x1234.. = [.., 0x34, 0x12])\n    token: [u8; 32],\n    secret_nonce: [u8; 32],\n}\n\nfn hashNote(note: Note, custody_id: [u8; 32]) -> [u8; 32] {\n    let mut acc: [u8; 160] = [0; 160]; // 32 * 5 = 160 bytes\n    \n    // Concatenate all inputs\n    for i in 0..32 {\n        acc[i] = note.nullifier[i];\n        acc[i + 32] = note.amount[i];\n        acc[i + 64] = note.token[i];\n        acc[i + 96] = custody_id[i];\n        acc[i + 128] = note.secret_nonce[i];\n    }\n    \n    // Hash the concatenated array\n    std::hash::keccak256(acc, acc.len())\n}\n\n// CTC\n// Split note into note_a + note_b\nfn main(\n    note: Note, note_a: Note, note_b: Note,\n    note_index: Field, note_hash_path: [[u8; 32]; 10], // commitment merkle\n    note_commitment: [u8; 32],\n    noteA_commitment: [u8; 32],\n    noteB_commitment: [u8; 32],\n    nullifier_hash: pub [u8; 32], root: pub [u8; 32], note_custody_id: pub [u8; 32],\n    noteA_custody_id: [u8; 32], noteB_custody_id: [u8; 32]\n) {\n    // Verify nullifier hash\n    let computed_nullifier = std::hash::keccak256(note.nullifier, note.nullifier.len());\n    assert(nullifier_hash == computed_nullifier);\n\n    // Verify note commitment\n    let computed_note_commitment = hashNote(note, note_custody_id);\n    assert(note_commitment == computed_note_commitment);\n\n    // Verify merkle root\n    let computed_root = compute_merkle_root(note_commitment, note_index, note_hash_path);\n    assert(root == computed_root);\n\n    // Verify tokens match\n    for i in 0..32 {\n        assert(note.token[i] == note_a.token[i]);\n        assert(note.token[i] == note_b.token[i]);\n    }\n\n    // Verify amount splitting (byte by byte addition with carry)\n    // LeToInt(note.amount) == LEtoInt(noteA.amount) + LEtoInt(noteB.amount)\n    let mut carry: u8 = 0;\n    for i in 0..32 {\n        let sum = (note_a.amount[i] as u16) + (note_b.amount[i] as u16) + (carry as u16);\n        assert(note.amount[i] == (sum % 256) as u8);\n        carry = (sum / 256) as u8;\n    }\n    assert(carry == 0); // Ensure no overflow\n\n    // Verify note commitments\n    let computed_noteA_commitment = hashNote(note_a, noteA_custody_id);\n    let computed_noteB_commitment = hashNote(note_b, noteB_custody_id);\n    assert(noteA_commitment == computed_noteA_commitment);\n    assert(noteB_commitment == computed_noteB_commitment);\n}\n\n","path":"/home/qbit/Desktop/work/mono-contracts-repo/noir/pSymm/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert","directive_to_radix"]}